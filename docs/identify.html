<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Quasi-Experimental Methods – Kevin's PSPE Resources</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<link href="./multivariate.html" rel="next">
<link href="./glm.html" rel="prev">
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="mathjax-config.js"></script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./glm.html">Changing Soon</a></li><li class="breadcrumb-item"><a href="./identify.html"><span class="chapter-title">Quasi-Experimental Methods</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Kevin’s PSPE Resources</a> 
    </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Theoretical Statistics</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./random.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Random Variables</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./inference.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Statistical Inference</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./mle.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Maximum Likelihood</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ols.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Least Squares Theory</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./causal.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Theoretical Causal Inference</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Applied Statistics</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./thecauses.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Applied Causal Inference</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stats.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Applied Statistical Models</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Game Theory</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./games.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Guide to Game Theory</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true">
 <span class="menu-text">Mathematics</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./linear.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Linear Algebra</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./calc.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Calculus and Probability</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true">
 <span class="menu-text">Changing Soon</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./glm.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Generalised Linear Model</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./identify.html" class="sidebar-item-text sidebar-link active"><span class="chapter-title">Quasi-Experimental Methods</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./multivariate.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Multivariate Methods</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul class="collapse">
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#non-compliance-designs" id="toc-non-compliance-designs" class="nav-link" data-scroll-target="#non-compliance-designs">Non-Compliance Designs</a></li>
  <li><a href="#sharp-regression-discontinuity" id="toc-sharp-regression-discontinuity" class="nav-link" data-scroll-target="#sharp-regression-discontinuity">Regression Discontinuity</a></li>
  <li><a href="#examiner-designs" id="toc-examiner-designs" class="nav-link" data-scroll-target="#examiner-designs">Examiner Designs</a></li>
  <li><a href="#shift-share-instruments" id="toc-shift-share-instruments" class="nav-link" data-scroll-target="#shift-share-instruments">Shift-Share Instruments</a></li>
  <li><a href="#differences-in-differences" id="toc-differences-in-differences" class="nav-link" data-scroll-target="#differences-in-differences">Differences-in-Differences</a></li>
  <li><a href="#selection-on-observables" id="toc-selection-on-observables" class="nav-link" data-scroll-target="#selection-on-observables">Selection on Observables</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./glm.html">Changing Soon</a></li><li class="breadcrumb-item"><a href="./identify.html"><span class="chapter-title">Quasi-Experimental Methods</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-title">Quasi-Experimental Methods</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>In the <a href="./causal.html">chapter 5</a>, we introduced the frameworks of causal inference, and how randomisation can establish causality.</p>
<p>However, in the social sciences, we cannot always run randomised experiments where we control the assignment of treatment. In fact, in most scenarios, we have to rely on observational data. In this chapter, we introduce methods to identify causal effects when randomisation is not possible.</p>
<p><br></p>
<section id="overview" class="level2">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<p>In <a href="./causal.html">chapter 5</a>, we discussed how randomised experiments can establish causality. However, in the social sciences, randomised experiments where researchers control treatment assignment are not always possible to implement. Sometimes even with randomisation, something goes wrong, and we need another way to establish causality.</p>
<p>As a result, a series of quasi-experimental designs have been developed in order to estimate causal effects. These designs range in terms of credibility, and can generally only be implemented in certain scenarios where the real-world aligns with the specific design. The main designs, in order of credibility, are:</p>
<table class="table-bordered caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 60%">
<col style="width: 15%">
</colgroup>
<thead>
<tr class="header">
<th>Design</th>
<th>When to Use</th>
<th>Estimands</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="#non-compliance-designs">Non-Compliance Designs</a></td>
<td>When we have a randomised experiment, but some individuals do not comply with the treatment we assigned with them.</td>
<td>LATE, ITT</td>
</tr>
<tr class="even">
<td><a href="#sharp-regression-discontinuity">Regression Discontinuity</a></td>
<td>When treatment is assigned in the real-world by some cut-off value of some variable.</td>
<td>LATE</td>
</tr>
<tr class="odd">
<td><a href="#examiner-designs">Examiner Instruments</a></td>
<td>When treatment assignment is influenced by the quasi-random assignment of individuals to decision makers (examiners), such as judges, doctors, caseworkers, etc.</td>
<td>LATE</td>
</tr>
<tr class="even">
<td><a href="#shift-share-instruments">Shift-Share Instruments</a></td>
<td>When treatment is assigned based on some exposure (share) to some exogenous/random shock (shift).</td>
<td>LATE</td>
</tr>
<tr class="odd">
<td><a href="#differences-in-differences">Differences-in-Differences</a></td>
<td>When there is variation in time of implementation of treatments between areas/units.</td>
<td>ATT</td>
</tr>
<tr class="even">
<td><a href="#selection-on-observables">Selection on Observables</a></td>
<td>When treatment is believed to be assigned based on a set of variables (covariates) that we can observe.</td>
<td>ATE, ATT</td>
</tr>
</tbody>
</table>
<p>We will explore each of these designs in more details below.</p>
<p><br></p>
</section>
<section id="non-compliance-designs" class="level2">
<h2 class="anchored" data-anchor-id="non-compliance-designs">Non-Compliance Designs</h2>
<p>When we assign individuals to treatment/control in <a href="./causal.html#randomised-experiments">randomised experiments</a>, we often cannot guarantee that individuals will actually follow through with treatment. Let us assume an <strong>encouragement</strong> <span class="math inline">\(Z_t \in \{0, 1\}\)</span>, which is our treatment assignment. Then, we have the <strong>treatment</strong> variable <span class="math inline">\(D_t \in \{0,1\}\)</span>, which is someone who actually took the treatment or not. Given this framework, we can divide all units <span class="math inline">\(i\)</span> into 4 categories:</p>
<ol type="1">
<li>Compliers: People who comply with encouragement <span class="math inline">\(Z_i\)</span>. Their <span class="math inline">\(Z_i = D_i\)</span>.</li>
<li>Always-takers: People who no matter what encouragement <span class="math inline">\(Z_i\)</span> is, always take treatment.</li>
<li>Never-takers: People who no matter their encouragement <span class="math inline">\(Z_i\)</span> is, never take treatment.</li>
<li>Defiers: People who do the opposite of encouragement <span class="math inline">\(Z_i\)</span>, so always <span class="math inline">\(D_i ≠ Z_i\)</span>.</li>
</ol>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Principle Strata
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>We can visually show what will happen with all 4 types of people in a table, called the principal strata:</p>
<table class="table-bordered caption-top table">
<tbody>
<tr class="odd">
<td></td>
<td><span class="math inline">\(Z_i = 1\)</span></td>
<td><span class="math inline">\(Z_i = 0\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(D_i = 1\)</span></td>
<td>Complier/Always-Taker</td>
<td>Defier/Always-Taker</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(D_i = 0\)</span></td>
<td>Defier/Never-Taker</td>
<td>Complier/Never-Taker</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>The idea of the non-compliance designs is to use our encouragement/treatment assignment <span class="math inline">\(Z\)</span> as an <a href="./ols.html#instrumental-variables-estimator">instrument</a> for <span class="math inline">\(D\)</span> - actually taking the treatment.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset nav-pills">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-1-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-1" role="tab" aria-controls="tabset-1-1" aria-selected="true" aria-current="page">Assumptions</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-2" role="tab" aria-controls="tabset-1-2" aria-selected="false">Identification</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-3" role="tab" aria-controls="tabset-1-3" aria-selected="false">Graphical Identification</a></li></ul>
<div class="tab-content nav-pills">
<div id="tabset-1-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-1-1-tab">
<p>There are 4 assumptions to the non-compliance designs:</p>
<ol type="1">
<li><strong>Relevance</strong>: <span class="math inline">\(Z\)</span> must be correlated to <span class="math inline">\(D\)</span>, i.e.&nbsp;<span class="math inline">\(Cov(Z,D)≠0\)</span>. Or in other words, compilers must exist, or else, encouragement <span class="math inline">\(Z\)</span> would not affect treatment <span class="math inline">\(D\)</span>.</li>
<li><strong>Ignorability/Exogneity</strong>: There is no backdoor path between <span class="math inline">\(Z\)</span> and <span class="math inline">\(D\)</span>, and no backdoor path between <span class="math inline">\(Z\)</span> and <span class="math inline">\(Y\)</span> (we can do controls/selection on observables to account for this). This is generally met if our <span class="math inline">\(Z\)</span> in our non-compliance design is randomly assigned.</li>
<li><strong>Exclusions Restriction</strong>: <span class="math inline">\(Z\)</span> must only have an effect on <span class="math inline">\(Y\)</span> through <span class="math inline">\(D\)</span>. <span class="math inline">\(Z\)</span> must not have any independent effect on <span class="math inline">\(Y\)</span>.</li>
<li><strong>Monotonicity</strong>: There are no defiers - people who do the opposite of their encouragement <span class="math inline">\(Z\)</span>, no matter what <span class="math inline">\(Z\)</span> they get.</li>
</ol>
<p>We have two estimands of interest. The <strong>Intent to Treat (ITT)</strong> is the ATE of <span class="math inline">\(Z\)</span> on <span class="math inline">\(Y\)</span>. This is the effect of encouragement:</p>
<p><span class="math display">\[
\tau_{ITT} = \E(Y_t|Z_t = 1) - \E(Y_t | Z_t = 0)
\]</span></p>
<p>However, the ITT does not tell us anything about the effect of <span class="math inline">\(D\)</span> (the treatment), only <span class="math inline">\(Z\)</span> (the encouragement). The <strong>Local Average Treamtment Effect (LATE)</strong> provides the effect of the treatment <span class="math inline">\(D\)</span> on <span class="math inline">\(Y\)</span> for compliers (so the ITT or ATE for compliers):</p>
<p><span class="math display">\[
\tau_{LATE} = \E(\tau_t | \mathrm{compliers})
\]</span></p>
<p>The LATE is generally not equivalent to the ATT or the ATE.</p>
</div>
<div id="tabset-1-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-2-tab">
<p>The ITT itself is identifiable under exogeneity/ignorability alone, since <span class="math inline">\(Z\)</span> is randomly assigned in non-compliance designs.</p>
<p>To identify the LATE, we will need all 4 assumptions. Let us define <span class="math inline">\(c\)</span> as compliers, <span class="math inline">\(a\)</span> as always-takers, <span class="math inline">\(n\)</span> as never-takers, and <span class="math inline">\(d\)</span> as defiers. We can break down the ITT into a weighted average:</p>
<p><span class="math display">\[
\tau_{ITT} = \tau_{ITT}^c \P(c) + \tau_{ITT}^a \P(a) + \tau_{ITT}^n \P(n) + \tau_{ITT}^d \P(d)
\]</span></p>
<p>We know that under our assumption of monotonicity, we assume no defiers, so the probability of a defier is <span class="math inline">\(\P(d) = 0\)</span>:</p>
<p><span class="math display">\[
\tau_{ITT} = \tau_{ITT}^c \P(c) + \tau_{ITT}^a \P(a) + \tau_{ITT}^n \P(n)
\]</span></p>
<p>Our exclusions restriction says that <span class="math inline">\(Z\)</span> has no independent effect on <span class="math inline">\(Y\)</span>. The ITT is the relationship between <span class="math inline">\(Z\)</span> and <span class="math inline">\(Y\)</span>. But since always-takers and never-takers ignore <span class="math inline">\(Z\)</span> when deciding treatment, <span class="math inline">\(Z\)</span> has no effect of them on <span class="math inline">\(Y\)</span>. Thus, we can further simplify:</p>
<p><span class="math display">\[
\tau_{ITT} = \tau_{ITT}^c \P(c)
\]</span></p>
<p>Remember that the <span class="math inline">\(\tau_{ITT}\)</span> for compliers, <span class="math inline">\(\tau_{ITT}^c = \tau_{ATE}\)</span>. So, let us isolate it to get:</p>
<p><span class="math display">\[
\tau_{LATE} = \frac{\tau_{ITT}}{\P(c)} \ = \ \frac{\E(Y_i | Z_i = 1) - \E(Y_i | Z_i = 0)}{\E(D_i | Z_i = 1) - \E(D_i | Z_i = 0)}
\]</span></p>
<p>For estimation, we could our sample equivalents in. Alternatively, we can use 2SLS (shown below), which produces equivalent estimates.</p>
</div>
<div id="tabset-1-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-3-tab">
<p>The typical <span class="math inline">\(Z\)</span> setup in instrumental variables (and the non-compliance design) is:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-1350479199.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:35.0%"></p>
</figure>
</div>
<p>Since we use only the compliers (the part of <span class="math inline">\(D\)</span> that is explained by <span class="math inline">\(Z\)</span>) for the LATE, <span class="math inline">\(Z\)</span> determines <span class="math inline">\(D\)</span>, and not <span class="math inline">\(U\)</span>. Thus, we have broken the link <span class="math inline">\(U \rightarrow D\)</span>, thus eliminating our confounder problem. The weaknesses of the design are the numerous possible violations:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-390858332.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:60.0%"></p>
</figure>
</div>
<p>In a non-compliance design, since <span class="math inline">\(Z\)</span> is randomly assigned, ignorability is generally not a huge concern. Relevance is generally met assuming we have compliers. Our main concern is the exclusions restriction.</p>
</div>
</div>
</div>
<p>To estimate the LATE in a non-compliance design, we typically use the 2-stage least squares estimator, as was detailed <a href="./ols.html#instrumental-variables-estimator">previously</a>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>late <span class="ot">&lt;-</span> fixest<span class="sc">::</span><span class="fu">feols</span>(Y <span class="sc">~</span> <span class="dv">1</span> <span class="sc">|</span> D <span class="sc">~</span> Z, <span class="at">data =</span> mydata, <span class="at">se =</span> <span class="st">"hetero"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The 2SLS estimator (and IV estimator) are biased in small sample sizes, but asymptotically consistent, so we should be more careful when dealing with small samples.</p>
<p>When interpreting the LATE, we must be careful. The LATE is only the causal effect of taking the treatment for compliers. However, we cannot say anything about non-compliers, and we must be careful about generalising. We generally do not know who the compliers are as well, and different <span class="math inline">\(Z\)</span> can result in different compliers.</p>
<p><br></p>
</section>
<section id="sharp-regression-discontinuity" class="level2">
<h2 class="anchored" data-anchor-id="sharp-regression-discontinuity">Regression Discontinuity</h2>
<p>Regression discontinuity designs are used when treatment is assigned based on some cutoff. For example, perhaps students only get scholarships if they get a certain score or above, or people get something after a certain age.</p>
<p>We have some treatment <span class="math inline">\(D_t\)</span>. There is some <strong>forcing variable</strong> <span class="math inline">\(X_t\)</span> that perfectly determines <span class="math inline">\(D_t\)</span> at some cutoff point <span class="math inline">\(X_t = c\)</span>.</p>
<p><span class="math display">\[
D_t = \begin{cases}
1 &amp; \text{if } X_t &gt; c \\
0 &amp; \text{if } X_t ≤ c
\end{cases}
\]</span></p>
<p>The idea is that right below and above the cutoff, individuals <span class="math inline">\(t\)</span> are very similar. Thus, we have quasi-random variation and comparable treatment-control groups at the cutoff which we can use to find the treatment effect at the cutoff point.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset nav-pills">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-2-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-2-1" role="tab" aria-controls="tabset-2-1" aria-selected="true">Assumptions</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-2-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-2-2" role="tab" aria-controls="tabset-2-2" aria-selected="false">Identification</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-2-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-2-3" role="tab" aria-controls="tabset-2-3" aria-selected="false">Graphical Example</a></li></ul>
<div class="tab-content nav-pills">
<div id="tabset-2-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-2-1-tab">
<p>There are 2 main assumptions for sharp regression discontinuity:</p>
<ol type="1">
<li><strong>Continuity</strong>: the potential outcomes <span class="math inline">\(\pt\)</span> and <span class="math inline">\(\pc\)</span>’s averages are continuous at cutoff <span class="math inline">\(X_t = c\)</span>. There can be no breaks or jumps in potential outcomes:</li>
</ol>
<p><span class="math display">\[
\begin{align}
&amp; \lim\limits_{\epsilon \rightarrow 0} \E (\pt | X_t = c + \epsilon) = \E (\pt | X_t = c) \\
&amp; \lim\limits_{\epsilon \rightarrow 0} \E (\pc | X_t = c + \epsilon) = \E (\pc | X_t = c) \\
\end{align}
\]</span></p>
<ol start="2" type="1">
<li><strong>Perfect Compliance</strong>: The cutoff <span class="math inline">\(X_t = c\)</span> perfectly decides who gets the treatment and who does not get the treatment.</li>
</ol>
<p>Our estimand is the <strong>Local Average Treatment Effect (LATE)</strong> at the cutoff point <span class="math inline">\(X_t = c\)</span>:</p>
<p><span class="math display">\[
\tau_{LATE} = \E(\pt - \pc | X_t = c)
\]</span></p>
</div>
<div id="tabset-2-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-2-2-tab">
<p>We can identify the LATE with the continuity assumption. We start with the LATE:</p>
<p><span class="math display">\[
\tau_{LATE} = \E(\pt | X_t = c) - \E(\pc | X_t = c)
\]</span></p>
<p>And using the assumption of continuity, we can substitute the expectations at <span class="math inline">\(X_t = c\)</span> with limits. We also know that if a limit exists, then both one-sided limits must be equal:</p>
<p><span class="math display">\[
\begin{align}
\tau_{LATE} &amp; = \lim\limits_{\epsilon \rightarrow 0} \E (\pt | X_t = c + \epsilon) - \lim\limits_{\epsilon \rightarrow 0} \E (\pc | X_t = c + \epsilon) \\
&amp; = \lim\limits_{\epsilon \rightarrow 0^+} \E (\pt | X_t = c + \epsilon) - \lim\limits_{\epsilon \rightarrow 0^-} \E (\pc | X_t = c + \epsilon)
\end{align}
\]</span></p>
<p>And we know we that individuals above the cutoff are assigned to treatment, and individuals below are assigned to control, so we can observe both of the above terms, and get:</p>
<p><span class="math display">\[
\tau_{LATE} = \lim\limits_{\epsilon \rightarrow 0^+} \E (Y_t | X_t = c + \epsilon) - \lim\limits_{\epsilon \rightarrow 0^-} \E (Y_t | X_t = c + \epsilon)
\]</span></p>
</div>
<div id="tabset-2-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-2-3-tab">
<p>The idea of regression discontinuity is shown below. The Red is the potential outcomes <span class="math inline">\(\pt\)</span>, and the red is the potential outcomes <span class="math inline">\(\pc\)</span>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-3203444067.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:50.0%"></p>
</figure>
</div>
<p>Any difference in observed outcomes at the cutoff <span class="math inline">\(X_t = c\)</span> should be the treatment effect <span class="math inline">\(\tau_{LATE}\)</span> at the cutoff.</p>
</div>
</div>
</div>
<p>To estimate a regression discontinuity, we model of potential outcomes <span class="math inline">\(\pt\)</span> and <span class="math inline">\(\pc\)</span>, and find the “discontinuity” at the cutoff.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset nav-pills">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-3-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-3-1" role="tab" aria-controls="tabset-3-1" aria-selected="true">Nonparametric</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-3-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-3-2" role="tab" aria-controls="tabset-3-2" aria-selected="false">Parameters</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-3-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-3-3" role="tab" aria-controls="tabset-3-3" aria-selected="false">Parametric</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-3-4-tab" data-bs-toggle="tab" data-bs-target="#tabset-3-4" role="tab" aria-controls="tabset-3-4" aria-selected="false">Falsification</a></li></ul>
<div class="tab-content nav-pills">
<div id="tabset-3-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-3-1-tab">
<p>The current “state of the art” RDD is to assume <span class="math inline">\(\pt\)</span> and <span class="math inline">\(\pc\)</span> are nonparametric (no functional form), and use a non-linear method to model them.</p>
<p>First, We need to recenter our forcing variable <span class="math inline">\(X_t\)</span> so that the cutoff <span class="math inline">\(c = 0\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>my_data<span class="sc">$</span>X <span class="ot">&lt;-</span> my_data<span class="sc">$</span>X <span class="sc">-</span> c</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then, we should filter our data such that only observations within our bandwidth are included (so observations between <span class="math inline">\(c - h ≤ X_t ≤ c + h\)</span>). Selecting a bandwidth will be discussed in the next tab:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>my_data <span class="ot">&lt;-</span> mydata <span class="sc">%&gt;%</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(X <span class="sc">&lt;=</span> h) <span class="sc">%&gt;%</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(X <span class="sc">&gt;=</span> <span class="sc">-</span>h)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then, we can estimate the LATE with the <em>rdrobust</em> package:</p>
</div>
<div id="tabset-3-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-3-2-tab">
<p>We need to make 3 choices when fitting nonparametric models: polynomial <span class="math inline">\(p\)</span>, kernel <span class="math inline">\(K(\cdot)\)</span>, and bandwidth <span class="math inline">\(h\)</span>.</p>
<ul>
<li><span class="math inline">\(p\)</span> is the flexibility of the model. We generally just use <span class="math inline">\(p = 1\)</span>.</li>
<li><span class="math inline">\(K(\cdot)\)</span> is how we weight each observation <span class="math inline">\(t\)</span>. We usually default to a <em>triangular kernel</em> (linearly decreases weight as distance to <span class="math inline">\(c\)</span> increases).</li>
</ul>
<p><span class="math inline">\(h\)</span> is the bandwidth - how much data around <span class="math inline">\(X_t = c\)</span> to consider in our model. <span class="math inline">\(h\)</span> is the most important parameter. The figure below shows how changing cutoffs changes our results:</p>
<p>When <span class="math inline">\(h\)</span> is larger, bias increases, but variance decreases. When <span class="math inline">\(h\)</span> is smaller, bias decreases, but variance increases. This is because we ideally want to only have points very close to cutoff <span class="math inline">\(c\)</span>, but limiting your observations increases variance.</p>
<p>Cattaneo et al (2020) have proposed a optimal bandwidth formula that minimises the Mean Squared Error, which is Bias plus Variance. The standard errors are an issue, so there are undersmoothing and robust bias correction methods.</p>
<p>We can show robustness of our results by just reporting different estimates from different choices of bandwidth <span class="math inline">\(h\)</span>.</p>
</div>
<div id="tabset-3-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-3-3-tab">
<p>We can also assume <span class="math inline">\(\pt\)</span> and <span class="math inline">\(\pc\)</span> take some functional form, for example - linear:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-2514976826.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:50.0%"></p>
</figure>
</div>
<p>For linear models with different slopes, we estimate the regression:</p>
<p><span class="math display">\[
Y_t = \gamma + \tau D_t + \alpha X_t + \beta(X_tD_t)
\]</span></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>late <span class="ot">&lt;-</span> fixest<span class="sc">::</span><span class="fu">feols</span>(Y <span class="sc">~</span> D<span class="sc">*</span>X, <span class="at">data =</span> my_data, <span class="at">se =</span> <span class="st">"hetero"</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(late)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<div id="tabset-3-4" class="tab-pane" role="tabpanel" aria-labelledby="tabset-3-4-tab">
<p>One concern is that there is manipulation around the threshold <span class="math inline">\(X_t = c\)</span>. For example, welfare programmes might have a maximum income cutoff, so individuals will intentionally forgo job opportunities to select into treatment. McCray (2008) has a density test that can be implemented:</p>
<p>Another concern is that we might have mistakenly concluded a treatment effect, when our actual function is not plotted correct. In the figure below, we fit linear models for <span class="math inline">\(\pt\)</span> and <span class="math inline">\(\pc\)</span> (in black), which estimates a positive <span class="math inline">\(\tau_{LATE}\)</span>, but when visually inspecting, this is clear it is not the case:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-1094811301.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:60.0%"></p>
</figure>
</div>
<p>The way to test for this is to simply visualise using <em>rdplot</em>:</p>
</div>
</div>
</div>
<p>An extension to the regression discontinuity design is the <strong>fuzzy-regression discontinuity design</strong>, when treatment is assigned based on some cutoff, but there is some non-compliance. Some people over the cutoff may on average be treated, but compliance is not perfect.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset nav-pills">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-4-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-4-1" role="tab" aria-controls="tabset-4-1" aria-selected="true">Setup</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-4-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-4-2" role="tab" aria-controls="tabset-4-2" aria-selected="false">Estimands</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-4-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-4-3" role="tab" aria-controls="tabset-4-3" aria-selected="false">Identification</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-4-4-tab" data-bs-toggle="tab" data-bs-target="#tabset-4-4" role="tab" aria-controls="tabset-4-4" aria-selected="false">Estimation</a></li></ul>
<div class="tab-content nav-pills">
<div id="tabset-4-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-4-1-tab">
<p>In a fuzzy regression discontinuity, we will have an encouragement variable <span class="math inline">\(Z_t\)</span>, and a treatment variable <span class="math inline">\(D_t\)</span> that is associated with <span class="math inline">\(Z_t\)</span>. The forcing variable <span class="math inline">\(X_t\)</span> perfectly determines encouragement <span class="math inline">\(Z_t\)</span> at cutoff <span class="math inline">\(X_t = c\)</span>:</p>
<p><span class="math display">\[
Z_t = \begin{cases}
1 &amp; \text{if } X_t &gt; c \\
0 &amp; \text{if } X_t ≤ c
\end{cases}
\]</span></p>
<p>The assumptions are:</p>
<ol type="1">
<li><strong>Augmeneted Continuity</strong>: Potential outcomes <span class="math inline">\(\E(\pt, \pc | X_i = x)\)</span> are continuous.</li>
<li>Our instrumental variable assumptions of Monotonicity, exclusions restriction, and relevance of <span class="math inline">\(Z_t\)</span> must be met.</li>
</ol>
</div>
<div id="tabset-4-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-4-2-tab">
<p>Our estimands are the <strong>Local Intent to Treat (LITT)</strong>, the effect of encouragement <span class="math inline">\(Z_t\)</span> at the threshold:</p>
<p><span class="math display">\[
\tau_{LITT} = \E(\pt - \pc | X_i = c)
\]</span></p>
<p>And the <strong>Local Average Treatment Effect (LATE)</strong> for compliers at the threshold:</p>
<p><span class="math display">\[
\tau_{LATE} = \E(\pt - \pc | X_i = c, \ \mathrm {complier})
\]</span></p>
<p>A complier is a unit <span class="math inline">\(t\)</span> who has <span class="math inline">\(D_t = 1\)</span> if above the cutoff <span class="math inline">\(X_t = c\)</span>, and <span class="math inline">\(D_t = 0\)</span> if not. Note that this is only the treatment effect at the cutoff for compliers - and is not generally generalisable.</p>
</div>
<div id="tabset-4-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-4-3-tab">
<p>The LITT is essentially the sharp regression discontinuity of <span class="math inline">\(Z_t\)</span> on <span class="math inline">\(Y_t\)</span>, so it is identified as:</p>
<p><span class="math display">\[
\tau_{LITT} = \lim\limits_{\epsilon \rightarrow 0^+} \E (Y_t | X_t = c + \epsilon) - \lim\limits_{\epsilon \rightarrow 0^-} \E (Y_t | X_t = c + \epsilon)
\]</span></p>
<p>The LATE is the LITT for compliers (based on the IV non-compliance identification), so it is identified as:</p>
<p><span class="math display">\[
\tau_{LATE} = \frac{\tau_{LITT}}{\P(\mathrm{compliers}|X_t = c)}
\]</span></p>
</div>
<div id="tabset-4-4" class="tab-pane" role="tabpanel" aria-labelledby="tabset-4-4-tab">
<p>To estimate the LATE, first we estimate the <span class="math inline">\(\tau_{LITT}\)</span> from a sharp regression discontinuity with treatment of <span class="math inline">\(Z_t\)</span>, forcing variable <span class="math inline">\(X_t\)</span>, and outcome <span class="math inline">\(Y_t\)</span>.</p>
<p>Then, we can estimate the proportion of compliers at the cutoff <span class="math inline">\(X_t = c\)</span>, by running a sharp regression discontinuity with treatment of <span class="math inline">\(Z_t\)</span>, forcing variable <span class="math inline">\(X_t\)</span>, and outcome <span class="math inline">\(D_t\)</span>.</p>
<p>Then, we can calculate the <span class="math inline">\(\tau_{LATE}\)</span> as:</p>
<p><span class="math display">\[
\tau_{LATE} = \frac{\tau_{LITT}}{\P(\mathrm{compliers}|X_t = c)}
\]</span></p>
</div>
</div>
</div>
<p><br></p>
</section>
<section id="examiner-designs" class="level2">
<h2 class="anchored" data-anchor-id="examiner-designs">Examiner Designs</h2>
<p>Examiner designs are used in settings where individuals <span class="math inline">\(t\)</span> are assigned to evaluators/examiners, who have some discretion in assigning treatment.</p>
<p>The classic example is judges and sentencing. We want to study the effect of incarceration on an outcome. Individuals prosecuted of a crime are first randomly assigned to courtrooms, and those courtrooms decide if these individuals will be incarcerated. However, courtrooms differ in the propensity for defendants to be incracerated. Other common set-ups include asylum decisions assigned to officers, healthcare diagnoses assigned to doctors, and so on.</p>
<p>More generally, we have <span class="math inline">\(n\)</span> units, and <span class="math inline">\(K\)</span> examiners <span class="math inline">\(1, \dots, K\)</span> who have control over treatment status <span class="math inline">\(D_t\)</span>. Each unit <span class="math inline">\(t\)</span> is assigned to an examiner <span class="math inline">\(k\)</span> in a known way. The examiner <span class="math inline">\(k\)</span> unit <span class="math inline">\(t\)</span> is assigned to is stored in a categorical variable <span class="math inline">\(Q_t = k\)</span>.</p>
<p>Our assumptions for the examiner design are as follows:</p>
<ol type="1">
<li>Relevance: Each examiner <span class="math inline">\(k\)</span> should have a different propensity to assign treatment <span class="math inline">\(D\)</span>.</li>
<li>Exogeneity/Ignorability: Assignment to examiners should be as-if random. There should be no backdoor paths between assignment to examiner and <span class="math inline">\(Y\)</span>.</li>
<li>Exclusions Restriction: No direct relationship between assignment to examiner and <span class="math inline">\(Y\)</span>, that is not through <span class="math inline">\(D\)</span>. Exclusions restrictions can actually be allowed, as long as they occur randomly.</li>
<li>Monotonicity: Examiner behaviour must be ordered. This means that if examiner <span class="math inline">\(k\)</span> has a property, they should apply it to all subjects <span class="math inline">\(t\)</span>. For example, if <span class="math inline">\(k\)</span> is more likely in assigning <span class="math inline">\(D\)</span>, it must be more likely for every unit <span class="math inline">\(t\)</span> (this is an issue if an examiner has racial or gender biases for example).</li>
</ol>
<p>If these assumptions are met, we can use two estimation methods for our instrument - which is the propensity of an examiner <span class="math inline">\(k\)</span> assigning a treatment <span class="math inline">\(D_t = 1\)</span>.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset nav-pills">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-5-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-5-1" role="tab" aria-controls="tabset-5-1" aria-selected="true">Examiner Fixed-Effects</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-5-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-5-2" role="tab" aria-controls="tabset-5-2" aria-selected="false">Latent Instrument</a></li></ul>
<div class="tab-content nav-pills">
<div id="tabset-5-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-5-1-tab">
<p>The propensity of an examiner assigning treatment is also a time-invariant property - it does not change over time. Thus, we can use fixed effects for examiners to control for these propensities.</p>
<p>Thus, our instruments will be dummy variables <span class="math inline">\(Z_1, \dots, Z_{K-1}\)</span> (The <span class="math inline">\(k-1\)</span> is because we have to leave one category out). Any specific <span class="math inline">\(Z_k\)</span> takes a value <span class="math inline">\(Z_{tk} = 1\)</span> if unit <span class="math inline">\(t\)</span> was assigned to that specific examiner <span class="math inline">\(k\)</span>, and <span class="math inline">\(Z_{tk} = 0\)</span> if unit <span class="math inline">\(t\)</span> was not assigned to that specific examiner <span class="math inline">\(k\)</span>.</p>
<p>These dummy instruments will be included in the first stage to estimate <span class="math inline">\(\hat D_t\)</span>, then in the second stage, use <span class="math inline">\(\hat D_t\)</span> as an explanatory variable for <span class="math inline">\(Y_t\)</span>.</p>
<p>In R, the implementation is as follows:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>fixest<span class="sc">::</span><span class="fu">feols</span>(Y <span class="sc">~</span> <span class="dv">1</span> <span class="sc">|</span> D <span class="sc">~</span> <span class="fu">as.factor</span>(Z),</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>              <span class="at">data =</span> my_data, <span class="at">se =</span> <span class="st">"hetero"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<div id="tabset-5-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-5-2-tab">
<p>We want to use the fact that different examiners are different - that is, variation in treatment assignment propensity to examiners. Thus, we need to estimate the latent (unobserved) propensity of each examiner <span class="math inline">\(k\)</span>.</p>
<p>We do this by finding the probability of being assigned to treatment <span class="math inline">\(D_t = 1\)</span> for examiner <span class="math inline">\(k\)</span>, but ignoring unit <span class="math inline">\(t\)</span> themselves:</p>
<p><span class="math display">\[
\hat L_t^{(k)} = \frac{\overbrace{\sum_{j≠t} \mathbb I[Q_j = Q_t]D_j}^{\text{num of treated for examiner k }}}{\underbrace{\sum_{j≠t} \mathbb I[Q_j = Q_t]}_{\text{total num assigned to examiner k}}}
\]</span></p>
<p>Where <span class="math inline">\(\mathbb I[Q_j = Q_t]\)</span> is an indicator function that only takes the value of 1 if the examiner of unit <span class="math inline">\(j\)</span> is the same as the examiner of unit <span class="math inline">\(t\)</span>. We leave <span class="math inline">\(t\)</span> out in the sum because you do not want to use <span class="math inline">\(D\)</span> to measure the instrument, to avoid ignorability violations. We can estimate this in R:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>my_data<span class="sc">$</span>L <span class="ot">&lt;-</span> <span class="fu">ave</span>(my_data<span class="sc">$</span>D, my_data<span class="sc">$</span>Q, <span class="at">FUN =</span> mean)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Where D is the treatment variable, and Q is the assigned examiner variable.</p>
<p>We then use <span class="math inline">\(\hat L_t^{(k)}\)</span> as an instrument for <span class="math inline">\(D_t\)</span>, and use a instrumental variables/2-stage-least-squares estimator.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>fixest<span class="sc">::</span><span class="fu">feols</span>(Y <span class="sc">~</span> <span class="dv">1</span> <span class="sc">|</span> D <span class="sc">~</span> L, <span class="at">data =</span> my_data, <span class="at">se =</span> <span class="st">"hetero"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</div>
<p><br></p>
</section>
<section id="shift-share-instruments" class="level2">
<h2 class="anchored" data-anchor-id="shift-share-instruments">Shift-Share Instruments</h2>
<p>Shift-share instruments, also called Bartik Instruments, are a way to explore the impacts of exposure (shares) to exogenous-random shocks (shifts). Let us say we are interested in some effect of variable <span class="math inline">\(X\)</span> in some city/region/market <span class="math inline">\(\ell\)</span>.</p>
<p><span class="math display">\[
Y_\ell = \alpha + \beta X_\ell + \eps_\ell
\]</span></p>
<p>Where we assume there is endogeneity/confounders, such that <span class="math inline">\(\E(X_\ell \eps_\ell) ≠ 0\)</span>. Now, imagine we have a second dimension of observations called types <span class="math inline">\(k = 1, \dots, K\)</span>. That means for every area/region <span class="math inline">\(\ell\)</span> can be observed for all types <span class="math inline">\(k\)</span>, meaning we can have <span class="math inline">\(Y_{\ell k}, X_{\ell k}\)</span>. For example, you could say <span class="math inline">\(Y\)</span> is the observed value in the city <span class="math inline">\(\ell\)</span> for an industry/group <span class="math inline">\(k\)</span>.</p>
<p>Given <span class="math inline">\(Y_{\ell k}, X_{\ell k}\)</span>, we have two potential sources of variation:</p>
<ol type="1">
<li><strong>Shares</strong>: A unit and type varying <span class="math inline">\(Z_{\ell k}\)</span>, that varies for both type <span class="math inline">\(k\)</span> and city/region <span class="math inline">\(\ell\)</span>.</li>
<li><strong>Shifts</strong>: A type-varying change variable <span class="math inline">\(G_k\)</span>, that varies based on type <span class="math inline">\(k\)</span>, but applies to all cities/regions <span class="math inline">\(\ell\)</span> equally. This is a shock that affects all cities/regions <span class="math inline">\(\ell\)</span>.</li>
</ol>
<p>Interacting shifts and shares gets us <span class="math inline">\(S_\ell = \sum_k Z_{\ell k} \cdot G_k\)</span>, called a <strong>shift-share</strong>, that only varies at the city/region level <span class="math inline">\(\ell\)</span>. The share measures the exposure (share) to the shock (shift). Our idea is to use <span class="math inline">\(S_\ell\)</span> to instrument for <span class="math inline">\(X_\ell\)</span> from the original endogenous model.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Example: Great Migration
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Fouka, Mazumder, and Tabellin (2022) want to study how migration of new minority groups affects the social position of pre-existing minority groups. Specifically, they want to study how the great migration of Blacks from the south to northern states affected white American’s view on previous European immigrants.</p>
<p>In this example, <span class="math inline">\(\ell\)</span> is the unit for cities, and <span class="math inline">\(k\)</span> is the unit for Blacks from state <span class="math inline">\(k\)</span>. The shares <span class="math inline">\(Z_{\ell k}\)</span> are the number of Black migrants born in state <span class="math inline">\(k\)</span> living in city <span class="math inline">\(\ell\)</span> prior to the shock. The shift (shock) <span class="math inline">\(G_k\)</span> is the number of blacks born in state <span class="math inline">\(k\)</span>, who left that state during the great migration.</p>
<p>The shift-share <span class="math inline">\(S_\ell\)</span> is the exposure <span class="math inline">\(Z_{\ell k}\)</span>, the pre-shock number of blacks from state <span class="math inline">\(k\)</span>, multiplied to the <span class="math inline">\(G_k\)</span>, the number of blacks who left state <span class="math inline">\(k\)</span>. The expectation is that blacks are more likely to move to a city <span class="math inline">\(\ell\)</span> that already has a strong Black community from their home state <span class="math inline">\(k\)</span>.</p>
<p>This <span class="math inline">\(S_\ell\)</span> captures the predicted level of Black migration in a MSA, based on the timing of out-migration <span class="math inline">\(G_k\)</span> from different states <span class="math inline">\(k\)</span>. Thus, <span class="math inline">\(S_\ell\)</span> (as the predicted number of Black migration) should be correlated with <span class="math inline">\(X_\ell\)</span>, the amount of Black migrants in city <span class="math inline">\(\ell\)</span>.</p>
</div>
</div>
</div>
<p>There are two perspectives of assumptions for Shift-Share designs - making assumptions on the shares (which is more common with less types <span class="math inline">\(k\)</span>), and making assumptions on the shifts:</p>
<div class="tabset-margin-container"></div><div class="panel-tabset nav-pills">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-6-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-6-1" role="tab" aria-controls="tabset-6-1" aria-selected="true">Shares</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-6-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-6-2" role="tab" aria-controls="tabset-6-2" aria-selected="false">Shifts</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-6-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-6-3" role="tab" aria-controls="tabset-6-3" aria-selected="false">Average Causal Response</a></li></ul>
<div class="tab-content nav-pills">
<div id="tabset-6-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-6-1-tab">
<p>The assumptions based on the shares (also called exposure mapping), are:</p>
<ol type="1">
<li>The share <span class="math inline">\(Z_{\ell k}\)</span> must be relevant. For all <span class="math inline">\(k\)</span>, <span class="math inline">\(Z_{\ell k}\)</span> must predict <span class="math inline">\(X_\ell\)</span>.</li>
<li>Strict exogeneity: <span class="math inline">\(\E(Z_{\ell k} \eps_\ell) = 0\)</span>. This means the share <span class="math inline">\(Z_{\ell k}\)</span> must be both ignorable/exogenous, and have no direct effect on <span class="math inline">\(Y_\ell\)</span> that is not through <span class="math inline">\(X_\ell\)</span>.</li>
</ol>
<p>With these two assumptions, 2SLS with the shift-share instrument is consistent, (we do not need any assumptions on <span class="math inline">\(G_k\)</span>) and we can estimate the average causal response (notes provided on the third tab).</p>
<p>However, shares are often not exogenous. Thus, the shift perspective (next tab) provides an alternative framework.</p>
</div>
<div id="tabset-6-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-6-2-tab">
<p>Shares are often not exogenous. The shifts (shocks) perspective, which assumes endogenous shares, are:</p>
<ol type="1">
<li>Exogeneity of the shocks to confounding in the shares: <span class="math inline">\(\E(G_k | \eps_\ell Z_{\ell k})= \mu\)</span>. This basically says that every shock has the same mean <span class="math inline">\(\mu\)</span>, regardless of observable confounders in <span class="math inline">\(\eps\)</span> or shares <span class="math inline">\(Z_{\ell k}\)</span>.</li>
<li>Many uncorrelated shocks: This means the correlation between shocks of type <span class="math inline">\(k\)</span> and <span class="math inline">\(k'\)</span> is 0: <span class="math inline">\(Cov(G_k, G_{k'}) = 0\)</span>. The idea is that with many exogenous shocks, residual confounding bias from shares averages out.</li>
</ol>
<p>With these two assumptions, 2SLS with the shift-share instrument is consistent, and we can estimate the average causal response (notes provided on the third tab).</p>
</div>
<div id="tabset-6-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-6-3-tab">
<p>In Shift-Share instruments, we tend to deal with continuous treatment variables. Thus, instead of the average treatment effect (or local average treatment effect), we are concerned with the average causal response (ACR).</p>
<p><span class="math display">\[
\tau_{ACR} = \frac{\E(Y_i|Z_i = 1) - \E(Y_i | Z_i = 0)}{\E(X_i | Z_i = 1) - \E(X_i | Z_i = 0)}
\]</span></p>
<p>Under our IV assumptions, we can show this equals:</p>
<p><span class="math display">\[
\sum\limits_x w_x \times \E(Y_t^{(x)} - Y_t^{(x-1)})
\]</span></p>
<p>Where we can see the ACR is a weighted average of causal responses, with the weights <span class="math inline">\(w_x\)</span> are determined by the compliance at <span class="math inline">\(X = x\)</span>.</p>
</div>
</div>
</div>
<p>To estimate, we use the two-stage-least-squares estimator, as was detailed <a href="./ols.html#instrumental-variables-estimator">previously</a>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>late <span class="ot">&lt;-</span> fixest<span class="sc">::</span><span class="fu">feols</span>(Y <span class="sc">~</span> <span class="dv">1</span> <span class="sc">|</span> D <span class="sc">~</span> S, <span class="at">data =</span> mydata, <span class="at">se =</span> <span class="st">"hetero"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The 2SLS estimator (and IV estimator) are biased in small sample sizes, but asymptotically consistent, so we should be more careful when dealing with small samples.</p>
<p><br></p>
</section>
<section id="differences-in-differences" class="level2">
<h2 class="anchored" data-anchor-id="differences-in-differences">Differences-in-Differences</h2>
<p><br></p>
</section>
<section id="selection-on-observables" class="level2">
<h2 class="anchored" data-anchor-id="selection-on-observables">Selection on Observables</h2>
<div class="tabset-margin-container"></div><div class="panel-tabset nav-pills">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-7-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-7-1" role="tab" aria-controls="tabset-7-1" aria-selected="true">Assumptions</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-7-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-7-2" role="tab" aria-controls="tabset-7-2" aria-selected="false">Identification of ATE</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-7-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-7-3" role="tab" aria-controls="tabset-7-3" aria-selected="false">Identification of ATT</a></li></ul>
<div class="tab-content nav-pills">
<div id="tabset-7-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-7-1-tab">
<p>There are two assumptions for selection on observables:</p>
<p><strong>Conditional Ignorability</strong> (also called conditional independence) means that among units <span class="math inline">\(i\)</span> with identical confounder values <span class="math inline">\(\mathcal X_i\)</span>, treatment <span class="math inline">\(D_i\)</span> is as-if randomly assigned. Potential outcomes are independent from treatment within each specific confounder value <span class="math inline">\(\mathcal X_i = x\)</span>.</p>
<p><span class="math display">\[
(\pc, \pt) \ind D_t \ | \ \set X_t = x, \ \forall \ x \in \set X
\]</span></p>
<p>This assumption implies that given any value of confounders <span class="math inline">\(\set X_t = x\)</span>, potential outcomes are equivalent between treatment and control groups:</p>
<p><span id="eq-selectiononobservables"><span class="math display">\[
\begin{align}
&amp; \E(\pc|D_t = 1, \set X_t = x) \ = \ \E(\pc|D_t = 0, \set X_t = x) \ = \ \E(\pc|\set X_t = x) \\
&amp; \E(\pt|D_t = 1, \set X_t = x) \ = \ \E(\pt|D_t = 0, \set X_t = x) \ = \ \E(\pt|\set X_t = x)
\end{align}
\tag{12.1}\]</span></span></p>
<p><strong>Common Support</strong> is the second assumption, and it states for any unit <span class="math inline">\(t\)</span> with any value of <span class="math inline">\(\mathcal X_t\)</span>, they have a non-zero probability they can be assigned to both control and treatment.</p>
<p>A few tips for selection controls in set <span class="math inline">\(\set X\)</span>:</p>
<ul>
<li>Good controls are confounders <span class="math inline">\(X\)</span> who cause <span class="math inline">\(D\)</span> (i.e.&nbsp;<span class="math inline">\(X \rightarrow D\)</span>), and are associated with <span class="math inline">\(Y\)</span>. We want to control for all of these.</li>
<li>Bad controls include any variable that is caused by <span class="math inline">\(D\)</span>, i.e.&nbsp;<span class="math inline">\(D \rightarrow W\)</span>. We do not need to control for this because <span class="math inline">\(W\)</span> isn’t causing selection into <span class="math inline">\(D\)</span>, it is actually itself caused by <span class="math inline">\(D\)</span>. Another bad control is a variable <span class="math inline">\(Z\)</span> that only causes <span class="math inline">\(D\)</span>, and not <span class="math inline">\(Y\)</span>. This reduces the variation in <span class="math inline">\(D\)</span>, which may amplify any other confounders unaccounted for.</li>
<li>Neutral controls are variables that only cause <span class="math inline">\(Y\)</span> and are not associated with <span class="math inline">\(D\)</span>. They do not affect the causal identification, but can reduce our standard errors.</li>
</ul>
</div>
<div id="tabset-7-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-7-2-tab">
<p>Using these assumptions, we can first identify the CATE, which will allow us to identify the ATE. Let us first start with the definition of CATE (<a href="causal.html#def-cate" class="quarto-xref">definition&nbsp;<span>5.6</span></a>):</p>
<p><span class="math display">\[
\begin{align}
\tau_{CATE}(x) &amp; = \E(\pt - \pc \ | \ \set X_t = x) \\
&amp; = \E(\pt | \set X_t = x) - \E(\pc|\set X_t = x) \\
\end{align}
\]</span></p>
<p>Now, from the properties implied by conditional ignorability given in <a href="#eq-selectiononobservables" class="quarto-xref">eq.&nbsp;<span>12.1</span></a>, we get</p>
<p><span class="math display">\[
\begin{align}
\tau_{CATE}(x) &amp; = \E(\pt|D_i = 1, \set X_t = x) - \E(\pc|D_i = 0, \set X_t = x) \\
&amp; = \E(Y_{t}|D_t = 1, \mathcal X_t = x) - \E(Y_{t}|D_t = 0, \set X_t = x) \\
\end{align}
\]</span></p>
<p>And the second step above is because <span class="math inline">\(\pt|D_i = 1\)</span> and <span class="math inline">\(\pc|D_i = 0\)</span> are observable outcomes (<a href="causal.html#def-observedoutcomes" class="quarto-xref">definition&nbsp;<span>5.7</span></a>). Thus, with independence, we can identify the CATE with just observed outcomes.</p>
<p>Let us consider the definition of the ATE, which is <span class="math inline">\(\E(\pt - \pc)\)</span>. From the definition of expectation given in <a href="random.html#def-exp" class="quarto-xref">definition&nbsp;<span>1.2</span></a>, we can rewrite the ATE as</p>
<p><span class="math display">\[
\tau_{ATE} = \int\tau_{CATE}(x) \P(\mathcal x) dy
\]</span></p>
<p>Which is a weighted average. We established above that we can identify the CATE. Thus, we can plug the CATE into the ATE to get our identified ATE:</p>
<p><span class="math display">\[
\tau_{ATE} = \int [\E(Y_{t}|D_t = 1, \set X_t = x) - \E(Y_{t}|D_t = 0, \set X_t = x)] \P(x) dy
\]</span></p>
<p>And all the values in this equation are observed outcomes <span class="math inline">\(Y_t\)</span>, meaning if we control for set of confounders <span class="math inline">\(\mathcal X\)</span>, our correlation becomes a causal effect.</p>
</div>
<div id="tabset-7-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-7-3-tab">
<p>Using these assumptions, we can first identify the CATE, which will allow us to identify the ATT. Let us first start with the definition of CATE (<a href="causal.html#def-cate" class="quarto-xref">definition&nbsp;<span>5.6</span></a>):</p>
<p><span class="math display">\[
\begin{align}
\tau_{CATE}(x) &amp; = \E(\pt - \pc \ | \ \set X_t = x) \\
&amp; = \E(\pt | \set X_t = x) - \E(\pc|\set X_t = x) \\
\end{align}
\]</span></p>
<p>Now, from the properties implied by conditional ignorability given in <a href="#eq-selectiononobservables" class="quarto-xref">eq.&nbsp;<span>12.1</span></a>, we get</p>
<p><span class="math display">\[
\begin{align}
\tau_{CATE}(x) &amp; = \E(\pt|D_i = 1, \set X_t = x) - \E(\pc|D_i = 0, \set X_t = x) \\
&amp; = \E(Y_{t}|D_t = 1, \mathcal X_t = x) - \E(Y_{t}|D_t = 0, \set X_t = x) \\
\end{align}
\]</span></p>
<p>And the second step above is because <span class="math inline">\(\pt|D_i = 1\)</span> and <span class="math inline">\(\pc|D_i = 0\)</span> are observable outcomes (<a href="causal.html#def-observedoutcomes" class="quarto-xref">definition&nbsp;<span>5.7</span></a>). Thus, with independence, we can identify the CATE with just observed outcomes.</p>
<p>Let us consider the definition of the ATT, which is <span class="math inline">\(\E(\pc = \pt | D_i = 1)\)</span>. From the definition expectation given in <a href="random.html#def-exp" class="quarto-xref">definition&nbsp;<span>1.2</span></a>, we can rewrite the ATT as</p>
<p><span class="math display">\[
\tau_{ATT} = \int \tau_{CATE}(x) \P(x|D_t = 1) dy
\]</span></p>
<p>Which is a weighted average. We established above that we can identify the CATE. Thus, we can plug CATE into the ATE to get our identified ATT:</p>
<p><span class="math display">\[
\tau_{ATT} = \int [\E(Y_{t}|D_t = 1, \set X_t = x) - \E(Y_{t}|D_t = 0, \mathcal X_t = x)] \P(x|D_t = 1) dy
\]</span></p>
<p>And all the values in this equation are observed outcomes <span class="math inline">\(Y_t\)</span>, meaning if we control for set of confounders <span class="math inline">\(\mathcal X\)</span>, our correlation becomes a causal effect.</p>
</div>
</div>
</div>
<p>Assuming we meet the assumptions, there are multiple estimators, including regression, matching, propensity score matching, and weighting.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset nav-pills">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-8-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-8-1" role="tab" aria-controls="tabset-8-1" aria-selected="true">Regression</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-8-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-8-2" role="tab" aria-controls="tabset-8-2" aria-selected="false">Matching</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-8-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-8-3" role="tab" aria-controls="tabset-8-3" aria-selected="false">Propensity Scores</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-8-4-tab" data-bs-toggle="tab" data-bs-target="#tabset-8-4" role="tab" aria-controls="tabset-8-4" aria-selected="false">Weighting</a></li></ul>
<div class="tab-content nav-pills">
<div id="tabset-8-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-8-1-tab">
<p>Regression is the most popular estimator for selection on observables. There are two types of regression estimators.</p>
<p><strong>Classical linear regression</strong> with OLS and robust standard errors is used to estimate the ATE when we believe we have <u>constant treatment effects</u> for all units (where each unit <span class="math inline">\(t\)</span> has the same <span class="math inline">\(\tau\)</span> effect):</p>
<p><span class="math display">\[
\textcolor{purple}{Y_t^{(d)}} = \alpha + D_t\tau + \b x_t \b\gamma + \eps_t
\]</span></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>ate <span class="ot">&lt;-</span> fixest<span class="sc">::</span><span class="fu">feols</span>(Y <span class="sc">~</span> D <span class="sc">+</span> X1 <span class="sc">+</span> X2 <span class="sc">+</span> X3,</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>                     <span class="at">data =</span> mydata, <span class="at">se =</span> <span class="st">"hetero"</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(ate)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>However, classical linear regression is <strong>biased</strong> for the ATE if we have heterogenous treatment effects (different units have different <span class="math inline">\(\tau\)</span>). It actually is an unbiased estimator for a weighted average of the ATT and ATU, not the ATE.</p>
<p>Instead, with heterogeneity, we should use the <strong>Fully Interacted Estimator</strong>:</p>
<p><span class="math display">\[
\textcolor{purple}{Y_t^{(d)}} = \alpha + D_t \tau + (\b x_t - \bar{\b x})\b\beta + D_t(\b x_t - \bar{\b x})\b\gamma + \eps_t
\]</span></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>ate <span class="ot">&lt;-</span> estimatr<span class="sc">::</span><span class="fu">lm_lin</span>(Y <span class="sc">~</span> D, <span class="at">covariates =</span> <span class="sc">~</span> X1 <span class="sc">+</span> X2 <span class="sc">+</span> X3,</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>                        <span class="at">data =</span> my_data)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(ate)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The fully interacted estimator is slightly biased when estimating <span class="math inline">\(\tau_{ATE}\)</span>, but the bias is arbitrarily small in large sample sizes. When we have a good amount of data, we tend to default to this estimator.</p>
</div>
<div id="tabset-8-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-8-2-tab">
<p>Matching estimates missing potential outcomes/counterfactuals for each observation in the treated group, by matching an untreated observation to that treated observation. The matching process is done by similarity on covariates <span class="math inline">\(\set X\)</span>. Matching estimates the ATT:</p>
<p><span class="math display">\[
\hat\tau_{ATT} = \frac{1}{N_1} \sum\limits_{t:D_i = 1}^{N_1}(Y_t - \tilde Y_t)
\]</span></p>
<p>Where <span class="math inline">\(N_1\)</span> is the number of observations of units in the treatment group, <span class="math inline">\(Y_i\)</span> is the observed <span class="math inline">\(Y\)</span> of unit <span class="math inline">\(t\)</span> in the treated group, and <span class="math inline">\(\tilde Y_i\)</span> is the observed <span class="math inline">\(Y\)</span> value of the control unit matched to unit <span class="math inline">\(t\)</span>. Matching takes an average difference of the matched pairs.</p>
<p>We can also match multiple control units <span class="math inline">\(\tilde Y_t\)</span> to one treated unit <span class="math inline">\(t\)</span>, and average the value of those control units to create a closer match with the treated unit <span class="math inline">\(t\)</span>.</p>
<p>To determine what units are “closest” to each other in similarity of covariates <span class="math inline">\(\set X\)</span> for matching, the typical choice is mahalanobis distance, which calculates the distance between a unit <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>:</p>
<p><span class="math display">\[
D_M(i,j) = \sqrt{(\b x_i - \b x_j)^\top \b\Sigma_x^{-1}(\b x_i - \b x_j)}
\]</span></p>
<p>Where <span class="math inline">\(\b\Sigma_x\)</span> is the covariance matrix of confounders <span class="math inline">\(\set X\)</span>. The units in treatment and control that have the smallest distances are matched. Matching is done in R:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">#matching units</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>match_obj <span class="ot">&lt;-</span> MatchIt<span class="sc">::</span><span class="fu">matchit</span>(D <span class="sc">~</span> X1 <span class="sc">+</span> X2 <span class="sc">+</span> X3, <span class="at">data =</span> my_data,</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>                              <span class="at">method =</span> <span class="st">"nearest"</span>, <span class="at">distance =</span> <span class="st">"mahalanobis"</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>match_data <span class="ot">&lt;-</span> MatchIt<span class="sc">::</span><span class="fu">match.data</span>(match_obj, <span class="at">weights =</span> <span class="st">"nn_weights"</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">#estimate</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>att <span class="ot">&lt;-</span> estimatr<span class="sc">::</span><span class="fu">lm_robust</span>(Y <span class="sc">~</span> D, <span class="at">data =</span> match_data, <span class="at">weights =</span> nn_weights)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(att)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The matching estimator is prone to bias/poor-matches as the number of covariates you have increases. Generally, with many covaraites, propensity scores are more popular.</p>
</div>
<div id="tabset-8-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-8-3-tab">
<p>Propensity score matching is similar to matching, and also estimates the ATT.</p>
<p>However, instead of matching on covariates, it matches on the likelihood of a unit <span class="math inline">\(t\)</span> receiving treatment <span class="math inline">\(D_t = 1\)</span>, based on their covariate <span class="math inline">\(\set X_t\)</span> values. This likelihood/probability is called the propensity score.</p>
<p><span class="math display">\[
\pr_t(\set X_t) = \P(D_t = 1 | \set X_t)
\]</span></p>
<p>However, we do not actually observe <span class="math inline">\(\pr_t(\set X_t)\)</span>. We can estimate <span class="math inline">\(\pr_t(\set X_t)\)</span> with a binary response model with outcome <span class="math inline">\(D_t\)</span>, and explanatory variables <span class="math inline">\(\set X\)</span>. Then using the fitted probabilities <span class="math inline">\(\P(D_t = 1) = \hat\pr_t(\set X_t)\)</span>, we can conduct matching based on these estimates.</p>
<p>To implement propensity score matching in R, we start with our binary response variable. The most common choice is logistic regression, but random forest is also possible:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># logistic model</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>ps_model <span class="ot">&lt;-</span> <span class="fu">glm</span>(D <span class="sc">~</span> X1 <span class="sc">+</span> X2, <span class="at">data =</span> my_data, <span class="at">family =</span> <span class="st">"binomial"</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co"># rf model</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>ps_model <span class="ot">&lt;-</span> randomForest<span class="sc">::</span><span class="fu">randomForest</span>(D <span class="sc">~</span> X1 <span class="sc">+</span> X2,</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>                                       <span class="at">data =</span> my_data,</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>                                       <span class="at">na.action =</span> na.omit)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co"># estimate propensity scores</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>my_data<span class="sc">$</span>ps <span class="ot">&lt;-</span> <span class="fu">predict</span>(ps_model, <span class="at">type =</span> <span class="st">"response"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then, we conduct matching with the estimated propensity scores:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">#matching units</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>match_obj <span class="ot">&lt;-</span> MatchIt<span class="sc">::</span><span class="fu">matchit</span>(D <span class="sc">~</span> ps, <span class="at">data =</span> my_data,</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>                              <span class="at">method =</span> <span class="st">"nearest"</span>, <span class="at">distance =</span> <span class="st">"mahalanobis"</span>)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>match_data <span class="ot">&lt;-</span> MatchIt<span class="sc">::</span><span class="fu">match.data</span>(match_obj, <span class="at">weights =</span> <span class="st">"pscore_weights"</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co">#estimate</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>att <span class="ot">&lt;-</span> estimatr<span class="sc">::</span><span class="fu">lm_robust</span>(Y <span class="sc">~</span> D, <span class="at">data =</span> match_data,</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>                           <span class="at">weights =</span> pscore_weights)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(att)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<div id="tabset-8-4" class="tab-pane" role="tabpanel" aria-labelledby="tabset-8-4-tab">
<p>Matching only recovers the ATT. However, if we want the ATE, we can use propensity scores in a inverse probability weighting (IPW) estimator. It can be shown with math that the ATE with propensity scores <span class="math inline">\(\pr_t(\set X_t)\)</span> can be identified as:</p>
<p><span class="math display">\[
\tau_{ATE} = \E\left[ Y_t \cdot \frac{D_t - \pr_t(\set X_t)}{\pr_t(\set X_t)(1-\pr_t(\set X_t))} \right]
\]</span></p>
<p>We can use our sample equivalents to estimate the ATE:</p>
<p><span class="math display">\[
\begin{align}
\hat\tau_{ATE} &amp; = \frac{1}{N}\sum\limits_{i=1}^N\left(Y_t \cdot \frac{D_t - \hat\pr_t(\set X_t)}{\hat\pr_t(\set X_t)(1-\hat\pr_t(\set X_t))} \right) \\
&amp; = \frac{1}{N} \sum\limits_{i=1}^N\left( Y_tD_t\frac{1}{\hat\pr_t(\set X_t)} - Y_t(1-D_t)\frac{1}{1 - \hat\pr_t(\set X_t)}\right)
\end{align}
\]</span></p>
<p>We see that units who are unlikely to recieve treatment (low propensity scores) that actually get treated get weighted more, and units who are likely to be treated (high propensity scores) but don’t get treated also get weighted more.</p>
<p>We first estimate the propensity scores with either logistic or random forest:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># logistic model</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>ps_model <span class="ot">&lt;-</span> <span class="fu">glm</span>(D <span class="sc">~</span> X1 <span class="sc">+</span> X2, <span class="at">data =</span> my_data, <span class="at">family =</span> <span class="st">"binomial"</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co"># rf model</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>ps_model <span class="ot">&lt;-</span> randomForest<span class="sc">::</span><span class="fu">randomForest</span>(D <span class="sc">~</span> X1 <span class="sc">+</span> X2,</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>                                       <span class="at">data =</span> my_data,</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>                                       <span class="at">na.action =</span> na.omit)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="co"># estimate propensity scores</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>my_data<span class="sc">$</span>ps <span class="ot">&lt;-</span> <span class="fu">predict</span>(ps_model, <span class="at">type =</span> <span class="st">"response"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then, we calculate the weights and estimate:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>my_data<span class="sc">$</span>ipw <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(mydata<span class="sc">$</span>D <span class="sc">==</span> <span class="dv">1</span>, <span class="dv">1</span><span class="sc">/</span>my_data<span class="sc">$</span>ps, <span class="dv">1</span><span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>my_data<span class="sc">$</span>ps))</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>ate <span class="ot">&lt;-</span> estimatr<span class="sc">::</span><span class="fu">lm_robust</span>(Y<span class="sc">~</span>D, <span class="at">data =</span> my_data, <span class="at">weights =</span> ipw)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The IPW estimator is asymptotically consistent, but has poor small sample properties, and are sensitive to extreme values of <span class="math inline">\(\hat\pr_t(\set X_t)\)</span>.</p>
</div>
</div>
</div>
<p>We should generally be careful with selection on observables, as it is considered to be the least robust of the quasi-experimental designs. This is particularly the case in the social sciences, when there are tons and tons of unobservable confounders which are nearly impossible to control for.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./glm.html" class="pagination-link" aria-label="Generalised Linear Model">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-title">Generalised Linear Model</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./multivariate.html" class="pagination-link" aria-label="Multivariate Methods">
        <span class="nav-page-text"><span class="chapter-title">Multivariate Methods</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>