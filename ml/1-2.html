<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Step Function and Splines</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="1-2_files/libs/clipboard/clipboard.min.js"></script>
<script src="1-2_files/libs/quarto-html/quarto.js"></script>
<script src="1-2_files/libs/quarto-html/popper.min.js"></script>
<script src="1-2_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="1-2_files/libs/quarto-html/anchor.min.js"></script>
<link href="1-2_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="1-2_files/libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="1-2_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="1-2_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="1-2_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Step Function and Splines</h1>
<p class="subtitle lead">Lesson 1.2, Applied Machine Learning</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><a href="https://politicalscience.github.io/ml">Course Homepage</a></p>
<section id="contents" class="level2">
<h2 class="anchored" data-anchor-id="contents">Table of Contents</h2>
<ol type="1">
<li><a href="#step">Step Functions</a></li>
<li><a href="#stepr">Step Functions in R</a></li>
<li><a href="#splines">Splines</a></li>
<li><a href="#splinesr">Splines in R</a></li>
</ol>
<hr>
<p>Remember to load tidyverse.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let us also load the dataset we will be using for these examples (feel free to load your own dataset)</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">read_csv</span>(<span class="st">"voctaxdata.csv"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr>
<p><a href="#contents">Table of Contents</a> | <a href="https://politicalscience.github.io/ml">Course Homepage</a></p>
</section>
<section id="step" class="level1">
<h1>Step Functions</h1>
<p>Step Functions, also known as piecewise-constant models, are models that use piecewise functions.</p>
<ul>
<li>Piecewise functions are functions that are not continuous - they jump around.</li>
</ul>
<p>Essentially, Step Function models are created as following:</p>
<ol type="1">
<li>Divide <span class="math inline">\(x\)</span> into several small sections. For example, if <span class="math inline">\(x\)</span> is between <span class="math inline">\(0\)</span> and <span class="math inline">\(10\)</span>, we can divide <span class="math inline">\(x\)</span> into 10 different segments: <span class="math inline">\(x = [0,1), [1,2), ... [9, 10]\)</span>.</li>
<li>Then, we find the average <span class="math inline">\(y\)</span> value within each segment of <span class="math inline">\(x\)</span></li>
<li>Then, we graph the function as a constant - straight line of the average of <span class="math inline">\(y\)</span> within each segment.</li>
</ol>
<p><br></p>
<p>The result is a bunch of horizontal straight lines, that jump at the boundaries between sections. The more sections we add in the domain of <span class="math inline">\(x\)</span>, the more flexible our relationship will be. Take the following graphical example:</p>
<p><img src="stepfunction.png" class="img-fluid"></p>
<p><br></p>
<p>In more mathematical terms, a step function takes the following form:</p>
<p><span class="math display">\[
\hat{y} = \hat{\beta}_0 + \hat{\beta}_1 C_1(x) + \hat{\beta}_2 C_2(x) + ... + \hat{\beta}_d C_d(x)
\]</span></p>
<p>Where we transform <span class="math inline">\(x\)</span> into a set of dummy variables by defining a set of cutpoint thresholds <span class="math inline">\(c_1, c_2, ..., c_d\)</span> and function <span class="math inline">\(C_d(x)\)</span> is the following:</p>
<p><span class="math display">\[
C_0(x) = I(x &lt; c_1)
\]</span></p>
<p><span class="math display">\[
C_1(x) = I(c_1 ≤ x &lt; c_2)
\]</span></p>
<p><span class="math display">\[
C_2(x) = I(c_2 ≤ x &lt; c_3)
\]</span></p>
<p><span class="math display">\[
C_d(x) = I(c_d ≤ x)
\]</span></p>
<p>Where <span class="math inline">\(I(x)\)</span> is an indicator function, so when the inequality condition within the function is satisfied, <span class="math inline">\(I(x) = 1\)</span>, and when it is not satisfied, <span class="math inline">\(I(x) = 0\)</span></p>
<p>Where <span class="math inline">\(\hat{\beta}_d\)</span> is the average <span class="math inline">\(y\)</span> value within the corresponding <span class="math inline">\(C_d\)</span> section.</p>
<ul>
<li>This is important when we interpret the coefficients of the model.</li>
</ul>
<p><br></p>
<p>If we follow the above function, it basically means the following:</p>
<ul>
<li><p>If the <span class="math inline">\(x\)</span> input value fits into one of the sections, that section’s indicator function <span class="math inline">\(I(x)\)</span> will return 1, while all the other section’s indicator functions <span class="math inline">\(I(x)\)</span> will return 0. Since <span class="math inline">\(C(x) = I(x)\)</span>, <span class="math inline">\(C_d(X)\)</span> will return <span class="math inline">\(1\)</span> if <span class="math inline">\(x\)</span> is within the section, and will return <span class="math inline">\(0\)</span> if <span class="math inline">\(x\)</span> is not within the section.</p></li>
<li><p>That means all other section’s coefficients will be cancelled out since <span class="math inline">\(C(x)\)</span> for other sections will equal <span class="math inline">\(0\)</span>, meaning the only term remaining will be the section that specific <span class="math inline">\(x\)</span> value belongs to, since <span class="math inline">\(C(x)\)</span> for the correct section will equal <span class="math inline">\(1\)</span></p></li>
<li><p>Since all other sections are cancelled out, and the correct section has <span class="math inline">\(C(x) = 1\)</span>, the output function will be <span class="math inline">\(\hat{y} = \hat{\beta}_d * 1\)</span>. Since <span class="math inline">\(\hat{\beta}_d\)</span> is the mean <span class="math inline">\(y\)</span> value within that section, that is our estimate for the section.</p></li>
</ul>
<p><br></p>
<p>The weakness of step functions is that since they are piecewise, they are not continuous. That means at the boundaries of sections, there will be massive jumps. This is quite unrealistic - normally, a small change in <span class="math inline">\(x\)</span> shouldn’t drastically change <span class="math inline">\(y\)</span> like what occurs near the cutpoints of step functions.</p>
<p><br></p>
<hr>
<p><a href="#contents">Table of Contents</a> | <a href="https://politicalscience.github.io/ml">Course Homepage</a></p>
</section>
<section id="stepr" class="level1">
<h1>Step Functions in R</h1>
<p>Remember to load tidyverse.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let us also load the dataset we will be using for these examples (feel free to load your own dataset)</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">read_csv</span>(<span class="st">"voctaxdata.csv"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><br></p>
<section id="creating-the-model-in-r" class="level4">
<h4 class="anchored" data-anchor-id="creating-the-model-in-r">Creating the Model in R</h4>
<p>To implement step functions in R, we can use the <strong>lm()</strong> and <strong>cut()</strong> functions.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>step_model <span class="ot">&lt;-</span> <span class="fu">lm</span>(Y <span class="sc">~</span> <span class="fu">cut</span>(X, <span class="dv">4</span>), <span class="at">data =</span> df)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co"># summary() to show results</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(step_model)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>These are the parts of the syntax that can be altered:</p>
<ul>
<li><p><strong>step_model</strong> is the variable I am saving my model to. <em>You can name this anything you want to.</em></p></li>
<li><p><strong>Y</strong> is the Y variable (Dependent variable) you are trying to predict, and <strong>X</strong> is the X variables (independent variable) you are using to get your prediction. <em>Replace these with the variables you want to use.</em></p>
<ul>
<li>NOTE: Always put the Y variable before the X variable. Separate the two with a tilda <strong>~</strong></li>
<li>NOTE: You can add more simply by using a <strong>+</strong> sign and adding another variable.</li>
</ul></li>
<li><p><strong>3</strong> within the <strong>cut()</strong> function represents the number of cut points. <em>You can change this to anything you want to</em>.</p>
<ul>
<li>We will discuss how to choose the right polynomial in the next lesson about model selection.</li>
</ul></li>
<li><p><strong>df</strong> is the name of the data frame that I am drawing these X and Y variables from. <em>Replace this with the name of your data frame.</em></p></li>
</ul>
<p><br></p>
</section>
<section id="example-in-r" class="level4">
<h4 class="anchored" data-anchor-id="example-in-r">Example in R</h4>
<p>Take the example of the relationship between <strong>export volume</strong> and the <strong>globalisation of the economy</strong>. I will use 6 cut points for this model.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>step_model <span class="ot">&lt;-</span> <span class="fu">lm</span>(econglobal <span class="sc">~</span> <span class="fu">cut</span>(export, <span class="dv">6</span>), <span class="at">data =</span> df)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co"># use summary() function to print results</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(step_model)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = econglobal ~ cut(export, 6), data = df)

Residuals:
     Min       1Q   Median       3Q      Max 
-11.9045  -2.1969  -0.2085   2.5124  11.5618 

Coefficients:
                          Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)                69.1982     0.5500  125.81   &lt;2e-16 ***
cut(export, 6)(30.2,50.7]   9.2193     0.7014   13.14   &lt;2e-16 ***
cut(export, 6)(50.7,71.3]  14.5685     0.8187   17.80   &lt;2e-16 ***
cut(export, 6)(71.3,91.8]  19.0221     0.9526   19.97   &lt;2e-16 ***
cut(export, 6)(91.8,112]   19.5581     1.8516   10.56   &lt;2e-16 ***
cut(export, 6)(112,133]    19.0276     1.8516   10.28   &lt;2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 4.331 on 249 degrees of freedom
Multiple R-squared:  0.6994,    Adjusted R-squared:  0.6933 
F-statistic: 115.9 on 5 and 249 DF,  p-value: &lt; 2.2e-16</code></pre>
</div>
</div>
<p>You can see that the output creates different sections of <span class="math inline">\(x\)</span>, and the estimate produced is the mean <span class="math inline">\(y\)</span> of the respective section.</p>
<p><br></p>
<hr>
<p><a href="#contents">Table of Contents</a> | <a href="https://politicalscience.github.io/ml">Course Homepage</a></p>
</section>
</section>
<section id="splines" class="level1">
<h1>Splines</h1>
<p>Splines are the combination of <a href="https://politicalscience.github.io/ml/1-1.html">Polynomial Models</a> and <a href="#step">Step Function Models</a>. It is important to understand how both work before we progress to Splines.</p>
<p>As we discussed previously, Step Function cuts <span class="math inline">\(x\)</span> into sections, and uses the mean of <span class="math inline">\(y\)</span> as the prediction for that section of <span class="math inline">\(x\)</span>.</p>
<p>Splines take this a little further. Just like Step Functions, splines also cut <span class="math inline">\(x\)</span> into section. But instead of fitting a horizontal line at the mean of <span class="math inline">\(y\)</span>, splines fit a polynomial model within every single section of <span class="math inline">\(x\)</span>.</p>
<ul>
<li>Essentially, instead of a piecewise function of horizontal lines, this is piecewise function of polynomials.</li>
</ul>
<p>Just like Step Functions, the more cutpoints <span class="math inline">\(c\)</span> we make, the more flexible the function.</p>
<p><br></p>
<p>However, splines don’t just fit a polynomial within each section of <span class="math inline">\(x\)</span>. That would result in the same issue we saw in step functions: of giant changes in prediction at the border of sections.</p>
<p>Splines adjust for this issue by constraining the estimates so that there is:</p>
<ol type="1">
<li>No discontinuity at the cut points</li>
<li>The polynomials are smooth at the cut points.</li>
</ol>
<p>This is done with a truncated basis function, but we will not get into this, and trust R to do the math for us.</p>
<p><br></p>
<p>The result is that Splines are very good at following very complex patterns in the data, since they have the advantages of both polynomials and step functions. Splines are thus very useful for prediction of non-linear relationships.</p>
<p><br></p>
<hr>
<p><a href="#contents">Table of Contents</a> | <a href="https://politicalscience.github.io/ml">Course Homepage</a></p>
</section>
<section id="splinesr" class="level1">
<h1>Splines in R</h1>
<p>To implement Splines in R, you will need to install and load the <strong>splines</strong> library.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(splines)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Remember to load tidyverse.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let us also load the dataset we will be using for these examples (feel free to load your own dataset)</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">read_csv</span>(<span class="st">"voctaxdata.csv"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><br></p>
<section id="creating-the-model-in-r-1" class="level4">
<h4 class="anchored" data-anchor-id="creating-the-model-in-r-1">Creating the Model in R</h4>
<p>We can implement splines in R with the <strong>lm()</strong> and <strong>bs()</strong> functions. The syntax is as follows:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>spline_model <span class="ot">&lt;-</span> <span class="fu">lm</span>(Y <span class="sc">~</span> <span class="fu">bs</span>(X, <span class="at">df =</span> <span class="dv">6</span>, <span class="at">degree =</span> <span class="dv">3</span>), <span class="at">data =</span> df)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">#summary() to see output</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(spline_model)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>These are the parts of the syntax that can be altered:</p>
<ul>
<li><p><strong>spline_model</strong> is the variable I am saving my model to. <em>You can name this anything you want to.</em></p></li>
<li><p><strong>Y</strong> is the Y variable (Dependent variable) you are trying to predict, and <strong>X</strong> is the X variables (independent variable) you are using to get your prediction. <em>Replace these with the variables you want to use.</em></p>
<ul>
<li>NOTE: Always put the Y variable before the X variable. Separate the two with a tilda <strong>~</strong></li>
<li>NOTE: You can add more simply by using a <strong>+</strong> sign and adding another variable.</li>
</ul></li>
<li><p><strong>df = 6</strong> within the <strong>bs()</strong> function represents the number of cut points + 3. <em>You can change the number to anything you want to</em>.</p>
<ul>
<li>We will discuss how to choose the right polynomial in the next lesson about model selection.</li>
</ul></li>
<li><p><strong>degree = 3</strong> within the <strong>bs()</strong> function represents the degree of the polynomials you want to fit. <em>You can change the number to anything you want to</em>.</p>
<ul>
<li>The most common polynomial used is 3.</li>
</ul></li>
<li><p><strong>df</strong> is the name of the data frame that I am drawing these X and Y variables from. <em>Replace this with the name of your data frame.</em></p></li>
</ul>
<p><br></p>
</section>
<section id="prediction-in-r" class="level4">
<h4 class="anchored" data-anchor-id="prediction-in-r">Prediction in R</h4>
<p>If we are interested in prediction, we can use the <strong>predict()</strong> function. You can predict in-sample data by setting <strong>newdata</strong> = the data frame you used for regression. You can predict out-of-sample data by using a dataframe with the same variables but new values. The syntax is as follows:</p>
<ul>
<li>Note: this syntax for prediction works in general for any type of model, not just splines.</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">#create new df for comparison of actual and prediction</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>df_results <span class="ot">&lt;-</span> df <span class="sc">%&gt;%</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(Y) <span class="co">#optional, may help with readability</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co"># newdata is what values of X1, X2... to predict for.</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>df_results<span class="sc">$</span>prediction <span class="ot">&lt;-</span> <span class="fu">predict</span>(spline_model, <span class="at">newdata =</span> df)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co"># brief glimpse of the results</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(df_results)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>These are the parts of the syntax that can be altered:</p>
<ul>
<li><p><strong>df_results</strong> is the results data frame I am creating. <em>You can name this anything you want to.</em></p></li>
<li><p><strong>Y</strong> is the Y variable I am trying to predict. <em>Replace this with the name of your Y variable.</em></p></li>
<li><p><strong>spline_model</strong> is the variable I am saving my prior model to. <em>Rename this to what your prior model was named.</em></p></li>
<li><p><strong>df</strong> is the name of the data frame that houses the <span class="math inline">\(x\)</span> values I want to predict for. <em>Replace this with the name of your data frame with the</em> <span class="math inline">\(x\)</span> <em>values you want to predict with.</em></p></li>
</ul>
<p><br></p>
</section>
<section id="example-in-r-1" class="level4">
<h4 class="anchored" data-anchor-id="example-in-r-1">Example in R</h4>
<p>Take the example of the relationship between <strong>export volume</strong> and the <strong>globalisation of the economy</strong>. I will use 5 cut points for this model and cubic polynomials, then predict the <span class="math inline">\(y\)</span> values.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>spline_model <span class="ot">&lt;-</span> <span class="fu">lm</span>(econglobal <span class="sc">~</span> <span class="fu">bs</span>(export, <span class="at">df =</span> <span class="dv">8</span>, <span class="at">degree =</span> <span class="dv">3</span>), <span class="at">data =</span> df)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(spline_model)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = econglobal ~ bs(export, df = 8, degree = 3), data = df)

Residuals:
    Min      1Q  Median      3Q     Max 
-9.2765 -2.2952  0.0978  1.6022  9.8591 

Coefficients:
                                Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)                       66.800      1.566  42.652  &lt; 2e-16 ***
bs(export, df = 8, degree = 3)1   -3.434      3.830  -0.897   0.3708    
bs(export, df = 8, degree = 3)2    3.698      1.945   1.901   0.0585 .  
bs(export, df = 8, degree = 3)3    8.759      2.186   4.007 8.15e-05 ***
bs(export, df = 8, degree = 3)4   15.202      1.742   8.725 4.08e-16 ***
bs(export, df = 8, degree = 3)5   15.307      1.985   7.712 3.08e-13 ***
bs(export, df = 8, degree = 3)6   25.987      2.682   9.691  &lt; 2e-16 ***
bs(export, df = 8, degree = 3)7   20.712      4.208   4.922 1.57e-06 ***
bs(export, df = 8, degree = 3)8   21.430      3.066   6.989 2.59e-11 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 3.552 on 246 degrees of freedom
Multiple R-squared:  0.8002,    Adjusted R-squared:  0.7937 
F-statistic: 123.2 on 8 and 246 DF,  p-value: &lt; 2.2e-16</code></pre>
</div>
</div>
<p>Most of the above is hard to interpret. The coefficients are practically useless for us. However, we can use the Residual Standard Error and Multiple R-squared as normal.</p>
<p>Now let’s generate predictions:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">#create new df for comparison of actual and prediction</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>df_results <span class="ot">&lt;-</span> df <span class="sc">%&gt;%</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(econglobal) <span class="co">#optional, may help with readability</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co"># newdata is what values of X1, X2... to predict for.</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>df_results<span class="sc">$</span>prediction <span class="ot">&lt;-</span> <span class="fu">predict</span>(spline_model, <span class="at">newdata =</span> df)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co"># brief glimpse of the results</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(df_results)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 6 × 2
  econglobal prediction
       &lt;dbl&gt;      &lt;dbl&gt;
1       66.9       66.5
2       66.9       67.3
3       68.4       67.4
4       69.6       67.4
5       66.6       69.0
6       67.4       67.2</code></pre>
</div>
</div>
<p>With the dataframe above, you can compare the actual values in the dataset with the predictive values generated.</p>
<p><br></p>
<hr>
<p><a href="#contents">Table of Contents</a> | <a href="https://politicalscience.github.io/ml">Course Homepage</a></p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>