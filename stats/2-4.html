<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>2.4 Types of Distributions</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="2-4_files/libs/clipboard/clipboard.min.js"></script>
<script src="2-4_files/libs/quarto-html/quarto.js"></script>
<script src="2-4_files/libs/quarto-html/popper.min.js"></script>
<script src="2-4_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="2-4_files/libs/quarto-html/anchor.min.js"></script>
<link href="2-4_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="2-4_files/libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="2-4_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="2-4_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="2-4_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">2.4 Types of Distributions</h1>
<p class="subtitle lead">Lesson 2.4, Introductory Statistical Inference</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><a href="https://politicalscience.github.io/stats">Course Homepage</a></p>
<section id="contents" class="level2">
<h2 class="anchored" data-anchor-id="contents">Table of Contents</h2>
<ol type="1">
<li><a href="#uniform">Uniform Distribution</a></li>
<li><a href="#normal">Normal Distribution</a></li>
<li><a href="#binomial">Binomial Distribution</a></li>
<li><a href="#poisson">Poisson Distribution</a></li>
</ol>
<hr>
<p><a href="#contents">Table of Contents</a> | <a href="https://politicalscience.github.io/stats">Course Homepage</a></p>
</section>
<section id="uniform" class="level1">
<h1>Uniform Distribution</h1>
<p>A uniform distribution is created when a continuous random variable <span class="math inline">\(Y\)</span> has the same probability for every possible outcome.</p>
<ul>
<li><p>For example, take a continuous random variable that has the possible outcomes of any real number between <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>.</p></li>
<li><p>Every possible outcome has the same probability.</p></li>
<li><p>Thus, when graphing the probability function <span class="math inline">\(f(y)\)</span>, we get a straight horizontal line - i.e., for every possible outcome, the probability is the same, hence the same height for all values of <span class="math inline">\(y\)</span></p></li>
</ul>
<p><br></p>
<p>There are some properties of a Uniform Distributions of a random continuous variable <span class="math inline">\(Y\)</span>, with possible outcomes of all real numbers between <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span></p>
<ul>
<li><p>If the outcomes are all between <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, <span class="math inline">\(f(y) = \frac{1}{b-a}\)</span></p>
<ul>
<li><p>This is because the probability is uniform, so the probability of each outcome <span class="math inline">\(y\)</span> is just 1 divided by the total amount of outcomes.</p></li>
<li><p>The variable <span class="math inline">\(y\)</span> never appears in the probability density function <span class="math inline">\(f(y)\)</span>, since the distribution is uniform - i.e.&nbsp;the probability of an outcome is the same for all <span class="math inline">\(y\)</span>.</p></li>
</ul></li>
<li><p>The mean of random variable <span class="math inline">\(Y\)</span> is <span class="math inline">\(E(Y) = \frac{a+b}{2}\)</span></p></li>
<li><p>The variance of random variable <span class="math inline">\(Y\)</span> is <span class="math inline">\(V(Y)=\frac{(b-a)^2}{12}\)</span></p></li>
</ul>
<p><br></p>
<p>One common use of uniform distributions is in random number generators, where every number between <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> is allowed to be generated, and has the same probability of being generated.</p>
<p><br></p>
<hr>
<p><a href="#contents">Table of Contents</a> | <a href="https://politicalscience.github.io/stats">Course Homepage</a></p>
</section>
<section id="normal" class="level1">
<h1>Normal Distribution</h1>
<p>Normal distributions are arguably the most important distribution for understanding inferential statistics.</p>
<p>Normal distributions famously take the “bell curve” shape as shown in the image below:</p>
<p><img src="normal.png" class="img-fluid" style="width:60.0%"></p>
<p><br></p>
<p>As we see in the image above, there are a few properties of normal distributions:</p>
<ul>
<li><p>The mean <span class="math inline">\(\mu\)</span> and median <span class="math inline">\(\tilde{x}\)</span> are equal, and sit in the exact centre of the distribution.</p></li>
<li><p>The distribution is symmetrical on both sides of the mean <span class="math inline">\(\mu\)</span></p></li>
</ul>
<p><br></p>
<p>Furthermore, percentage of area under the curve remains constant in all normal distributions, no matter the actual value of the standard deviation <span class="math inline">\(\sigma\)</span> (as shown above in the figure)</p>
<ul>
<li><p>Within one standard deviation <span class="math inline">\(\sigma\)</span> of the mean <span class="math inline">\(\mu\)</span> on both sides, there contains 68.26% of the total area under the curve.</p></li>
<li><p>WIthin 2 standard deviations <span class="math inline">\(2 \sigma\)</span> of the mean <span class="math inline">\(\mu\)</span> on both sides, there contains 95.44% of the total area under the curve.</p></li>
<li><p>Within 3 standard deviations <span class="math inline">\(3 \sigma\)</span> of the mean <span class="math inline">\(\mu\)</span> on both sides, there contains 99.72% of the total area under the curve.</p></li>
</ul>
<p>Why is this useful?</p>
<ul>
<li><p>Well remember, area under the curve of a probability density function is the probability of an event occurring.</p></li>
<li><p>Thus, if some random variable is in a normal distribution, just by knowing the standard deviation, we can calculate the probabilities of a certain outcome.</p></li>
<li><p>This idea will become extremely useful in statistical inference.</p></li>
</ul>
<p><br></p>
<p>A normal distribution’s probability density function can be written as following, assuming that <span class="math inline">\(\mu\)</span> is the mean and <span class="math inline">\(\sigma\)</span> is the standard deviation:</p>
<p><span class="math display">\[
f(y)=\frac{1}{\sqrt{2 \pi} * \sigma} e^{-\frac{(x - \mu)^2}{2 \sigma ^2}}
\]</span></p>
<p><br></p>
<p>Normal distributions are frequently used in hypothesis testing, since the standard deviations <span class="math inline">\(\sigma\)</span> allow us to calculate the probability of a sample mean being in a certain interval. We will discuss more on this in sampling and inference.</p>
<p><br></p>
<hr>
<p><a href="#contents">Table of Contents</a> | <a href="https://politicalscience.github.io/stats">Course Homepage</a></p>
</section>
<section id="binomial" class="level1">
<h1>Binomial Distribution</h1>
<p>Binomial distribution is a discrete distribution for discrete random variables:</p>
<ul>
<li><p>Suppose we have a binary random variable - yes/no or success/fail.</p></li>
<li><p>Binomial distributions record the number of “successes” observed in multiple trials of the random variable.</p></li>
</ul>
<p>For example, if we flip a die 10 times, assuming we want heads (heads is our success category), what is the probability of getting each possible amount of successes?</p>
<ul>
<li>A binomial distribution would plot all possible outcomes 0 to 10, and the probability associated with each.</li>
</ul>
<p><br></p>
<p>Binomial Distributions must meet the following criteria:</p>
<ol type="1">
<li>Number of observations/trials is fixed - we are doing an action a specified amount of times (ex. flipping a coin exactly 10 times)</li>
<li>Each observation/trial is independent - one observation doesn’t affect the next (ex. flipping the first coin doesn’t affect the odds of the second coin).</li>
<li>The probability of success for each observation/trial must be the same (ex. flipping a coin, whether the 1st or 10th time, is always a probability of 0.5 of getting heads).</li>
</ol>
<p><br></p>
<p>The binomial distribution takes the following probability mass function (see <a href="https://politicalscience.github.io/stats/1-3.html">1.3 Counting</a> for more info on how combination works):</p>
<p><span class="math display">\[
p(y)= \binom ny p^y q^{n-y}
\]</span></p>
<p>Where:</p>
<ul>
<li><p><span class="math inline">\(y\)</span> is the number of successes (can take the value of 0 all the way to the number of observations/trials <span class="math inline">\(n\)</span>)</p></li>
<li><p><span class="math inline">\(n\)</span> is the number of trials</p></li>
<li><p><span class="math inline">\(p\)</span> is the probability of success in any trial</p></li>
<li><p><span class="math inline">\(q\)</span> is the probability of failure in any trial, which, according to probability rules, is also <span class="math inline">\(q=1-p\)</span></p></li>
<li><p><span class="math inline">\(p(y)\)</span> is the probability of a certain number of successes <span class="math inline">\(y\)</span></p></li>
</ul>
<p><br></p>
<p>These are a few extra properties of binomial distributions:</p>
<ul>
<li><p>Mean <span class="math inline">\(\mu = E(Y)= n*p\)</span></p></li>
<li><p>Variance <span class="math inline">\(\sigma ^2 = npq\)</span></p></li>
</ul>
<p><br></p>
<p>Binomial distributions are useful for the implementation of Logistic Regression.</p>
<p><br></p>
<hr>
<p><a href="#contents">Table of Contents</a> | <a href="https://politicalscience.github.io/stats">Course Homepage</a></p>
</section>
<section id="poisson" class="level1">
<h1>Poisson Distribution</h1>
<p>A Poisson distribution is a discrete distribution for discrete random variables:</p>
<ul>
<li>It measures the probability of a given number of events, occurring in an interval of time</li>
</ul>
<p>For example, consider a tech support call centre:</p>
<ul>
<li><p>It generally, on average, receives 3 calls per minute during the entire day.</p></li>
<li><p>Assume that the random event of receiving a call is independent - the timing of the first call does not change the probability of when the next will occur.</p></li>
<li><p>What are the chances of receiving less than 3 calls? What are the chances of receiving at least 5 calls? The Poisson distribution plots this.</p></li>
</ul>
<p><br></p>
<p>The probability mass function of a Poisson distribution is:</p>
<p><span class="math display">\[
p(y) = \frac{\lambda ^ y}{y!} e^{- \lambda}
\]</span></p>
<p>Where:</p>
<ul>
<li><p><span class="math inline">\(\lambda\)</span> is the expectation/average number of events that generally occurs within the time interval.</p></li>
<li><p><span class="math inline">\(y\)</span> is the number of occurrences we are interested in.</p></li>
<li><p>and <span class="math inline">\(p(y)\)</span> tells us the probability of <span class="math inline">\(y\)</span> occurrences occurring.</p></li>
</ul>
<p><br></p>
<p>The Poisson distribution has a very unique feature: Its expected value equals the variance:</p>
<p><span class="math display">\[
E(Y) = \sigma ^2 = \lambda
\]</span></p>
<p><br></p>
<p>The Poisson distribution is often used to model rare events, and is used in the Poisson regression for counts. For example, it can be used to predict the number of civil wars in a time period.</p>
<p><br></p>
<hr>
<p><a href="#contents">Table of Contents</a> | <a href="https://politicalscience.github.io/stats">Course Homepage</a></p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>