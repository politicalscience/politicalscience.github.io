<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Factor Analysis Models</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="2_files/libs/clipboard/clipboard.min.js"></script>
<script src="2_files/libs/quarto-html/quarto.js"></script>
<script src="2_files/libs/quarto-html/popper.min.js"></script>
<script src="2_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="2_files/libs/quarto-html/anchor.min.js"></script>
<link href="2_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="2_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="2_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="2_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="2_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: true
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Factor Analysis Models</h1>
            <p class="subtitle lead">Multivariate Statistics and Measurement</p>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="99">
    <h2 id="toc-title">Table of Contents</h2>
   
  <ul>
  <li><a href="#factor-analysis" id="toc-factor-analysis" class="nav-link active" data-scroll-target="#factor-analysis"><strong>Factor Analysis</strong></a>
  <ul class="collapse">
  <li><a href="#factor-analysis-models" id="toc-factor-analysis-models" class="nav-link" data-scroll-target="#factor-analysis-models">Factor Analysis Models</a></li>
  <li><a href="#exploratory-and-confirmatory-analysis" id="toc-exploratory-and-confirmatory-analysis" class="nav-link" data-scroll-target="#exploratory-and-confirmatory-analysis">Exploratory and Confirmatory Analysis</a></li>
  </ul></li>
  <li><a href="#one-factor-efa" id="toc-one-factor-efa" class="nav-link" data-scroll-target="#one-factor-efa"><strong>One-Factor EFA</strong></a>
  <ul class="collapse">
  <li><a href="#model-specification" id="toc-model-specification" class="nav-link" data-scroll-target="#model-specification">Model Specification</a></li>
  <li><a href="#assumptions-and-identification" id="toc-assumptions-and-identification" class="nav-link" data-scroll-target="#assumptions-and-identification">Assumptions and Identification</a></li>
  <li><a href="#estimation-process" id="toc-estimation-process" class="nav-link" data-scroll-target="#estimation-process">Estimation Process</a></li>
  <li><a href="#interpretation-of-factor-loadings" id="toc-interpretation-of-factor-loadings" class="nav-link" data-scroll-target="#interpretation-of-factor-loadings">Interpretation of Factor Loadings</a></li>
  <li><a href="#communality-and-reliability" id="toc-communality-and-reliability" class="nav-link" data-scroll-target="#communality-and-reliability">Communality and Reliability</a></li>
  <li><a href="#factor-scores" id="toc-factor-scores" class="nav-link" data-scroll-target="#factor-scores">Factor Scores</a></li>
  </ul></li>
  <li><a href="#multiple-factor-efa" id="toc-multiple-factor-efa" class="nav-link" data-scroll-target="#multiple-factor-efa"><strong>Multiple Factor EFA</strong></a>
  <ul class="collapse">
  <li><a href="#model-specification-1" id="toc-model-specification-1" class="nav-link" data-scroll-target="#model-specification-1">Model Specification</a></li>
  <li><a href="#model-identification" id="toc-model-identification" class="nav-link" data-scroll-target="#model-identification">Model Identification</a></li>
  <li><a href="#factor-rotation" id="toc-factor-rotation" class="nav-link" data-scroll-target="#factor-rotation">Factor Rotation</a></li>
  <li><a href="#factor-interpretation" id="toc-factor-interpretation" class="nav-link" data-scroll-target="#factor-interpretation">Factor Interpretation</a></li>
  </ul></li>
  <li><a href="#implementation-in-r" id="toc-implementation-in-r" class="nav-link" data-scroll-target="#implementation-in-r"><strong>Implementation in R</strong></a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>PCA, as we discussed in the last chapter, is essentially an <em>algorithm based</em> method of dimensional reduction. In this chapter, we will discuss Factor Analysis, a <em>model-based</em> method. These models specify some probability model that represents an approximation of the data-generating process, that allow us to model latent variables.</p>
<hr>
<section id="factor-analysis" class="level1">
<h1><strong>Factor Analysis</strong></h1>
<section id="factor-analysis-models" class="level3">
<h3 class="anchored" data-anchor-id="factor-analysis-models">Factor Analysis Models</h3>
<p>Factor Analysis models are Latent Variable Models, with a few characteristics:</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Explanation of Latent Variables
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>A latent variable is a variable that is not observed. Instead, we observe several variables that are indicators of the latent variable.</p>
<p>A measurement model represents how the observed indicators measure the true concept of interest, the latent variable.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-3108594497.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:35.0%"></p>
</figure>
</div>
<p>An example of latent variables is the measurement of personality traits.</p>
<p>We can measure personality traits by asking survey respondents many different questions, and asking them to respond on a scale of 0-10 on each question.</p>
<p>But, these answers to the questions are all measuring one latent variable - the personality.</p>
</div>
</div>
</div>
<ol type="1">
<li>All observed indicator variables (items) and latent variables (factors) are treated as continuous variables.</li>
<li>All distributions of the variables are specified as normal distributions.</li>
<li>All the observed variables (items) are treated as measures of latent variables.</li>
<li>The latent variables (factors) are on an equal footing with each other - associations between factors are represented with correlations.</li>
</ol>
<p>We can decide how many factors we need to properly measure the latent variables. We can assign predictions (factor scores) of the latent variable to create constructs of the latent variable to use in statistical analysis.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Example of Factor Analysis
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Below is a model of a factor analysis with 2 factors that are correlated (double sided arrow).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-1470139227.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:70.0%"></p>
</figure>
</div>
</div>
</div>
</div>
<p><br></p>
</section>
<section id="exploratory-and-confirmatory-analysis" class="level3">
<h3 class="anchored" data-anchor-id="exploratory-and-confirmatory-analysis">Exploratory and Confirmatory Analysis</h3>
<p>There are two types of factor analysis: Exploratory factor analysis and confirmatory factor analysis.</p>
<p>Exploratory factor analysis (<strong>EFA</strong>):</p>
<ul>
<li>We do not assume any number of factors, or what the factor pattern will look like.</li>
<li>Our aim is to find the smallest number of interpretable factors needed to explain the correlations between the observed items.</li>
<li>Models have minimum number of constraints on model parameters.</li>
</ul>
<p>Confirmatory factor analysis (<strong>CFA</strong>):</p>
<ul>
<li>Models have more than the minimum number of parameter constraints.</li>
<li>Can be used to study how well hypothesized measurement models fit the data.</li>
</ul>
<p><br></p>
<p><br></p>
<hr>
</section>
</section>
<section id="one-factor-efa" class="level1">
<h1><strong>One-Factor EFA</strong></h1>
<section id="model-specification" class="level3">
<h3 class="anchored" data-anchor-id="model-specification">Model Specification</h3>
<p>We denote the single latent factor (common factor) with <span class="math inline">\xi</span>. This latent variable is normally distributed with mean <span class="math inline">k</span> and variance <span class="math inline">\phi</span>:</p>
<p><span class="math display">
\xi \sim \mathcal N(k, \phi)
</span></p>
<p>We denote our observed indicator variables (items) by <span class="math inline">x_1, \dots, x_p</span>. Each item <span class="math inline">x_i</span> is related to the latent factor <span class="math inline">\xi</span> with a linear regression model:</p>
<p><span class="math display">
x_i = \tau_i + \lambda_i \xi + \delta_i
</span></p>
<p><span class="math inline">\lambda_i</span> is the slope, also called the <strong>factor loadings</strong>, which determine the associations between <span class="math inline">\xi</span> and <span class="math inline">x_i</span>. <span class="math inline">\delta_i</span> is the error term, called the <strong>unique factors</strong>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-3884145761.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:60.0%"></p>
</figure>
</div>
<p><br></p>
</section>
<section id="assumptions-and-identification" class="level3">
<h3 class="anchored" data-anchor-id="assumptions-and-identification">Assumptions and Identification</h3>
<p>There are several assumptions that the exploratory factor analysis model makes:</p>
<ol type="1">
<li>Error term <span class="math inline">\delta_i</span> is normally distributed with a mean of 0: <span class="math inline">\delta_i \sim \mathcal N(0, \theta_{ii})</span>. The variance <span class="math inline">\theta_{ii}</span> depends on which factor <span class="math inline">x_i</span> we are using.</li>
<li>Error terms <span class="math inline">\delta_1, \dots, \delta_p</span> are uncorrelated with each other. This implies that correlations between the items, are entirely explained by the factor. In other words, all <span class="math inline">x_i</span> are <em>conditionally independent</em> given <span class="math inline">\xi</span>.</li>
<li>Factor <span class="math inline">\xi</span> is uncorrelated with the error terms <span class="math inline">\delta_i</span>.</li>
</ol>
<p>There is also an issue of unique identification. This is because many different values of <span class="math inline">k, \phi, \tau_i, \lambda_i</span> can give the same observed means, variances, and covariances of the items <span class="math inline">x_1, \dots, x_n</span>.</p>
<p>Thus, we need to fix <span class="math inline">k</span> and <span class="math inline">\phi</span> of <span class="math inline">\xi \sim \mathcal N(k, \phi)</span> by assumption. The standard assumption is <span class="math inline">k = 0</span> and <span class="math inline">\phi =1</span>, so <span class="math inline">\xi \sim \mathcal N(0, 1)</span>. This makes <span class="math inline">\xi</span> take a standard normal distribution.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Other Choices of Assumption
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>We can also, instead of assuming <span class="math inline">k</span> and <span class="math inline">\phi</span> in <span class="math inline">\xi \sim \mathcal N(k, \phi)</span>, we can instead assume the size of <span class="math inline">\tau_i</span> and <span class="math inline">\lambda_i</span>. This also allows for a unique identification of the model.</p>
<p>The most common assumption is to choose one item (generally <span class="math inline">x_1</span>), and set <span class="math inline">\tau_1 = 0</span> and <span class="math inline">\lambda = 1</span>. Since <span class="math inline">x_1</span> is normally distributed, this implies that <span class="math inline">x_i \sim \mathcal N(k, \phi + \theta_{11})</span>.</p>
</div>
</div>
</div>
<p><br></p>
</section>
<section id="estimation-process" class="level3">
<h3 class="anchored" data-anchor-id="estimation-process">Estimation Process</h3>
<p>We know that our latent factor <span class="math inline">\xi \sim \mathcal N(k, \phi)</span>.</p>
<p>We know that <span class="math inline">x_i</span> is related to <span class="math inline">\xi</span> by <span class="math inline">x_i = \tau_i + \lambda_i \xi + \delta_i</span>, a linear regression. Thus, <span class="math inline">E(x_i|\xi) = \tau_i + \lambda_i \xi</span>. Since <span class="math inline">x_i</span> is also normally distributed, we can say <span class="math inline">x_i \sim \mathcal N(\tau_i + \lambda_i \xi, \ \lambda_i^2\phi +\theta_{ii})</span>.</p>
<p>We can construct a theoretical covariance matrix of all the items <span class="math inline">x_1, \dots x_p</span>, where the diagonals are the variances:</p>
<p><span class="math display">
\begin{pmatrix}
Var(x_1) = \lambda_1^2\phi + \theta_{11} &amp; Cov(x_1, x_2) = \lambda_1\phi\lambda_2 &amp; \dots &amp; Cov(x_1, x_p) = \lambda_1\phi\lambda_p \\
Cov(x_2, x_1) = \lambda_2\phi\lambda_1 &amp; Var(x_2) = \lambda_2^2 \phi + \theta_{22}&amp; \dots &amp; Cov(x_2, x_p) = \lambda_1\phi\lambda_p \\
\dots &amp; \dots &amp; \ddots &amp; \vdots \\
Cov(x_p, x_1) = \lambda_p\phi\lambda_1 &amp; Cov(x_p, x_2) = \lambda_p\phi\lambda_2 &amp; \dots &amp; Var(x_p) = \lambda_p^2 \phi + \theta_{pp}
\end{pmatrix}
</span></p>
<p>If we fix <span class="math inline">\xi \sim \mathcal N(0, 1)</span>, that implies <span class="math inline">\phi = 1</span>. This allows us to simplify the above theoretical covariance matrix.</p>
<p>The estimation process is to find the values of <span class="math inline">\lambda_i</span> and <span class="math inline">\theta_{ii}</span>, that make the above hypothetical covariance matrix, as close as possible to our observed covariance matrix from our sample with <span class="math inline">x_1, \dots, x_p</span>. This is generally done with maximum likelihood estimation.</p>
<p><br></p>
</section>
<section id="interpretation-of-factor-loadings" class="level3">
<h3 class="anchored" data-anchor-id="interpretation-of-factor-loadings">Interpretation of Factor Loadings</h3>
<p>The estimated factor loading, <span class="math inline">\widehat{\lambda_i}</span>, is the estimated covariance between the observed item <span class="math inline">x_i</span>, and the latent factor <span class="math inline">\xi</span>. If item <span class="math inline">x_i</span> has been standardised to a standard normal distribution, <span class="math inline">\widehat{\lambda_i}</span> is also the correlation between <span class="math inline">x_i</span> and <span class="math inline">\xi</span>.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Additional Note on Multiple Factors
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>When there are two or more factors, these interpretations of <span class="math inline">\widehat{\lambda_i}</span> only hold if the multiple factors are uncorrelated.</p>
<p>For correlated factors, the covariances and correlations between the factors are still dependent on <span class="math inline">\widehat{\lambda_i}</span>, but they need to be calculated with an additional calculation.</p>
</div>
</div>
</div>
<p>Interpretation of a factor <span class="math inline">\xi</span> is based on the items <span class="math inline">x_i</span> that have large (positive or negative) loadings <span class="math inline">\widehat{\lambda_i}</span> on the factor <span class="math inline">\xi</span>. For example, take this example below:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-2153557303.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:60.0%"></p>
</figure>
</div>
<p>We can see all the items are positively correlated with the factor. Thus, we could interpret the personality factor <span class="math inline">\xi</span> as a measure of status/power-oriented personality. We can see that <em>admire</em> and <em>success</em> carry larger weights (more important for the factor), while <em>rich</em> and <em>respect</em> carry less weight.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Rotation of Factors
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>In a one-factor model, the direction of the factor <span class="math inline">\xi</span> is not identified, so it can be chosen freely.</p>
<p>For example, we can change the sign of the values of the factors from <span class="math inline">\xi</span> to <span class="math inline">-\xi</span>.</p>
<p>Rotating the factors would simply inverse the signs of the loading from <span class="math inline">\lambda_i</span> to <span class="math inline">-\lambda_i</span>.</p>
</div>
</div>
</div>
<p><br></p>
</section>
<section id="communality-and-reliability" class="level3">
<h3 class="anchored" data-anchor-id="communality-and-reliability">Communality and Reliability</h3>
<p>When we set our model such that <span class="math inline">\xi \sim \mathcal N(0, 1)</span>, the model implies that the variances of the observed items is:</p>
<p><span class="math display">
Var(x_i) = \lambda_i^2 + \theta_{ii}
</span></p>
<p><span class="math inline">\lambda_i^2</span> is the part of the variance of <span class="math inline">x_i</span> explained by the common factor <span class="math inline">\xi</span>, known as the <strong>communality</strong> of <span class="math inline">x_i</span>. <span class="math inline">\theta_{ii}</span> is the residual variance, also called the specific variance.</p>
<p>The proportion <span class="math inline">\lambda_i^2/ (\lambda_i^2 + \theta_{ii})</span> is called the <strong>reliability</strong> of <span class="math inline">x_i</span>. It is the <span class="math inline">R^2</span> of the measurement model for <span class="math inline">x_i</span> on <span class="math inline">\xi</span>.</p>
<p>When all <span class="math inline">x_i</span> are standardised to have a variance <span class="math inline">Var(x_i) = 1</span>, then the communality <span class="math inline">\lambda_i^2</span> is equal to the reliability: <span class="math inline">\lambda_i^2 = 1 - \theta_{ii}</span>.</p>
<p>The mean of all the communalities of each item <span class="math inline">x_1, \dots, x_p</span> is the proportion of total variance of all the items explained by the common factor <span class="math inline">\xi</span>.</p>
<p><br></p>
</section>
<section id="factor-scores" class="level3">
<h3 class="anchored" data-anchor-id="factor-scores">Factor Scores</h3>
<p>Once we have estimated the factor analysis model, we can then use <span class="math inline">x_1, \dots, x_k</span> values for a individual, and predict their latent variable values <span class="math inline">\xi</span>, called <strong>factor scores</strong>. These are calculated as a linear combination of the observed items:</p>
<p><span class="math display">
\tilde\xi = w_0 + w_1x_1 + w_2x+2 + \dots + w_px_p
</span></p>
<p>The coefficients <span class="math inline">w_1, \dots w_p</span> depend on the model parameters. Coefficients <span class="math inline">w_i</span> are highest for items <span class="math inline">x_i</span> which are the strongest measures of <span class="math inline">\xi</span> according to the model.</p>
<p><span class="math inline">w_0</span> is the intercept. <span class="math inline">w_0 = 0</span> if both <span class="math inline">\xi</span> has a mean of 0, and all <span class="math inline">x_i</span> are standardised (to a standard normal distribution <span class="math inline">\mathcal N(0, 1)</span>) to have a mean of 0.</p>
<p><br></p>
<p><br></p>
<hr>
</section>
</section>
<section id="multiple-factor-efa" class="level1">
<h1><strong>Multiple Factor EFA</strong></h1>
<section id="model-specification-1" class="level3">
<h3 class="anchored" data-anchor-id="model-specification-1">Model Specification</h3>
<p>We can have a model with <span class="math inline">q</span> number of latent factors <span class="math inline">\boldsymbol\xi = (\xi_1, \dots, \xi_q)</span>. The model for the distribution of vector <span class="math inline">\boldsymbol\xi</span> is:</p>
<p><span class="math display">
\boldsymbol\xi \sim \mathcal N(\boldsymbol k, \boldsymbol\Phi)
</span></p>
<p>Where <span class="math inline">\boldsymbol k = (E(\xi_1), \dots, E(\xi_q))</span>, and <span class="math inline">\boldsymbol\Phi</span> is a matrix with diagonal elements being variances <span class="math inline">Var(\xi_j) = \phi_{jj}</span>, and other elements being covariances <span class="math inline">Cov(\xi_j, \xi_k) = \phi_{jk}</span>.</p>
<p>Now, the measurement model of how <span class="math inline">x_i</span> is related to each factor <span class="math inline">\xi_j</span> is as follows:</p>
<p><span class="math display">
x_i = \tau_i + \lambda_{i1} \xi_1 + \lambda_{i2} \xi_2 + \dots + \lambda_{iq} \xi_q + \delta_i
</span></p>
<p>The assumptions remain the same from the first model:</p>
<ol type="1">
<li>Error term <span class="math inline">\delta_i</span> is normally distributed with a mean of 0: <span class="math inline">\delta_i \sim \mathcal N(0, \theta_{ii})</span>. The variance <span class="math inline">\theta_{ii}</span> depends on which factor <span class="math inline">x_i</span> we are using.</li>
<li>Error terms <span class="math inline">\delta_{1j}, \dots, \delta_{pj}</span> are uncorrelated with each other. This implies that correlations between the items, are entirely explained by the factor. In other words, all <span class="math inline">x_i</span> are <em>conditionally independent</em> given <span class="math inline">\xi_j</span>.</li>
<li>All factors <span class="math inline">\xi_j</span> is uncorrelated with the error terms <span class="math inline">\delta_i</span>.</li>
</ol>
<p><br></p>
</section>
<section id="model-identification" class="level3">
<h3 class="anchored" data-anchor-id="model-identification">Model Identification</h3>
<p>For a given number of items <span class="math inline">p</span>, you must have a sufficiently small number of factors <span class="math inline">q</span>. Generally, the maximum amount of factors <span class="math inline">q</span> is given by:</p>
<p><span class="math display">
df = \frac{(p-q)^2 - (p+q)}{2} ≥ 0
</span></p>
<p>As in the 1-factor model, we need to specify the scales of the factors. The most conventional way is to set all means of all factors <span class="math inline">\xi_j</span> to 0, <span class="math inline">k_j = 0</span>, and set all variances of all factors <span class="math inline">\xi_j</span> to 1, <span class="math inline">\phi_{jj} = 1</span>.</p>
<p>None of these fixes the covariances <span class="math inline">Cov(\xi_j, \xi_k) = \phi_{jk}</span>, so these covariances are parameters that we need to estimate.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-6-contents" aria-controls="callout-6" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The Heywood Case
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-6" class="callout-6-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Even when the model is formally identified, the number of factors <span class="math inline">q</span> can be “too large”.</p>
<p>The Heywood Case is the name of an estimated variance of <span class="math inline">x_i</span>, <span class="math inline">\theta_{ii}</span>, which is 0 or even negative for some observed variable <span class="math inline">x_i</span>.</p>
<p>It is possible that this means that <span class="math inline">x_i</span> is a perfect measure of the factors <span class="math inline">\xi_j</span>. However, it is far more likely that this indicates that the model has too many factors .</p>
<p>The best way to deal with this is to fit the model with one fewer factor. You can also use a confirmatory factor analysis model which sets some loadings to 0.</p>
</div>
</div>
</div>
<p><br></p>
</section>
<section id="factor-rotation" class="level3">
<h3 class="anchored" data-anchor-id="factor-rotation">Factor Rotation</h3>
<p>Choosing the scale of the latent factors does not fully resolve their identification. This is because there are actually infinitely many rotations of our latent factors, that all produce the same fit.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-7-contents" aria-controls="callout-7" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Details on the Rotation Identification Issue
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-7" class="callout-7-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Suppose we start with two factors, <span class="math inline">\xi_1</span> and <span class="math inline">\xi_2</span>. Let us transform them to 2 new factors with some linear combinations with coefficients <span class="math inline">a</span>:</p>
<p><span class="math display">
\begin{split}
&amp; \xi_1^* = a_{11}\xi_1 + a_{12}\xi_2 \\
&amp; \xi_2^* = a_{21} \xi_1 + a_{22} \xi_2
\end{split}
</span></p>
<p>This transformation can be interpreted as a rotation (change in coordinate axes) of the space of these factors. Both pairs <span class="math inline">(\xi_1, \xi_2)</span> and <span class="math inline">(\xi_1^*, \xi_2^*)</span> both produce the exactly same fit for the observed items. Thus, this causes a unique identification issue.</p>
<p>In fact, any choice of coefficients <span class="math inline">a</span> (there are infinitely many of them) will produce the same model fit.</p>
</div>
</div>
</div>
<p>Generally, we choose the rotation based on the interpretability of the resulting factors. Interpretation is easiest when each factor has high loadings for some variables, and small (near 0) loadings for all the rest. This allows us to clearly identify what each factor is representing.</p>
<p><strong>Orthogonal</strong> factors (perpendicular to each other in vector space) imply that the factors are uncorrelated. However, some rotations can be <strong>oblique</strong>rotations, which allow the factors to be correlated.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-8-contents" aria-controls="callout-8" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Visualisation of Orthogonal and Oblique Rotations
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-8" class="callout-8-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>The below illustrates orthogonal and oblique rotations of factors:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-249696322.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:70.0%"></p>
</figure>
</div>
<p>We can see that the obliquely rotated axes are not exactly perpendicular to each other.</p>
</div>
</div>
</div>
<p>If the main goal of analysis is interpretation, we generally want to use an oblique rotation, as they are easier to interpret. This also shows if there are correlations between the factors.</p>
<p>For data reduction purposes, the orthogonal rotation can be useful, as it avoids multicollinearity.</p>
<p><br></p>
</section>
<section id="factor-interpretation" class="level3">
<h3 class="anchored" data-anchor-id="factor-interpretation">Factor Interpretation</h3>
<p>Interpretation is very similar to the one-factor models.</p>
<p>Interpretation of a factor <span class="math inline">\xi</span> is based on the items <span class="math inline">x_i</span> that have large (positive or negative) loadings <span class="math inline">\widehat{\lambda_{ij}}</span> on the factor <span class="math inline">\xi</span>.</p>
<p>When there are two or more factors, these interpretations of <span class="math inline">\widehat{\lambda_{ij}}</span> (which were the covariance between <span class="math inline">x_i</span> and <span class="math inline">\xi_j</span>) only hold if the multiple factors are uncorrelated.</p>
<p>For correlated factors, the covariances and correlations between the factors are still dependent on <span class="math inline">\widehat{\lambda_i}</span>, but they are not exactly the value of <span class="math inline">\widehat{\lambda_i}</span>.</p>
<p>We can still calculate our factor scores as before.</p>
<p><span class="math display">
\tilde\xi_j = w_{0j} + w_{1j}x_1 + w_{2j}x+2 + \dots + w_{pj}x_p
</span></p>
<p><br></p>
<p><br></p>
<hr>
</section>
</section>
<section id="implementation-in-r" class="level1">
<h1><strong>Implementation in R</strong></h1>
<p>For exploratory factor analysis, you will need the package <em>psych</em> and <em>GPArotation</em>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(psych)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(GPArotation)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Before starting factor analysis, you want a dataset with only complete observations (no NA’s) for the variables you are items for factor analysis:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>no_na <span class="ot">&lt;-</span> <span class="fu">apply</span>(mydata, <span class="dv">1</span>, <span class="at">FUN=</span><span class="cf">function</span>(x){<span class="fu">all</span>(<span class="sc">!</span><span class="fu">is.na</span>(x))})</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>mydata <span class="ot">&lt;-</span> mydata[no_na,]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Also subset the data so that only the items you want to use are in the dataframe.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-9-contents" aria-controls="callout-9" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
EFA with One Factor
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-9" class="callout-9-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>We can use the <em>fa()</em> command to conduct factor analysis:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>fa_object <span class="ot">&lt;-</span> <span class="fu">fa</span>(mydata, <span class="at">nfactors=</span><span class="dv">1</span>, <span class="at">fm=</span><span class="st">"ml"</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(fa_object)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The output provides</p>
</div>
</div>
</div>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-10-contents" aria-controls="callout-10" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
EFA with Two Factors
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-10" class="callout-10-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>We can use the <em>fa()</em> command to conduct factor anlaysis.</p>
<p>For a non-rotated (orthogonal) rotation, the code is as follows:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>fa_object <span class="ot">&lt;-</span> <span class="fu">fa</span>(mydata, <span class="at">nfactors=</span><span class="dv">1</span>, <span class="at">fm=</span><span class="st">"ml"</span>, <span class="at">rotate =</span> <span class="st">"none"</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(fa_object)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>For a oblique rotation, the code is as follows:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>fa_object <span class="ot">&lt;-</span> <span class="fu">fa</span>(mydata, <span class="at">nfactors=</span><span class="dv">1</span>, <span class="at">fm=</span><span class="st">"ml"</span>, <span class="at">rotate =</span> <span class="st">"oblimin"</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(fa_object)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The output provides a table of the loadings <span class="math inline">\lambda_i</span> for each item. ML1 represents the first factor <span class="math inline">\xi_1</span>, and ML2 represents the second factor <span class="math inline">\xi_2</span>, and so on…</p>
<p>For the oblique rotation, there is also a table of correlations between all the factors <span class="math inline">\xi_j</span>.</p>
</div>
</div>
</div>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-11-contents" aria-controls="callout-11" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Factor Scores
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-11" class="callout-11-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>To calculate factor scores, we can extract them from the <em>fa_object</em> in which we stored our factor analysis.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>fa_object<span class="sc">$</span>scores</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This will give you a table, with the rows being different units in the data, and the columns being different factor scores for each factor.</p>
<p>If you are wanting to just view the scores, it is recommended to subset the data if you have too many observations:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>fa_object<span class="sc">$</span>scores[<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>,] <span class="co">#first 10 units</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>You can also subset the number of factors (although if you don’t need extra factors, you would just specify less when estimating):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>pca_object<span class="sc">$</span>scores[,<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>] <span class="co">#first 2 factors</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>