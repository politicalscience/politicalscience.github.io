<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Do Parties Converge on Policy for Elections?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="1_files/libs/clipboard/clipboard.min.js"></script>
<script src="1_files/libs/quarto-html/quarto.js"></script>
<script src="1_files/libs/quarto-html/popper.min.js"></script>
<script src="1_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="1_files/libs/quarto-html/anchor.min.js"></script>
<link href="1_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="1_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="1_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="1_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="1_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: true
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Do Parties Converge on Policy for Elections?</h1>
            <p class="subtitle lead">Electoral Politics</p>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="99">
    <h2 id="toc-title">Table of Contents</h2>
   
  <ul>
  <li><a href="#median-voter-theory" id="toc-median-voter-theory" class="nav-link active" data-scroll-target="#median-voter-theory"><strong>Median Voter Theory</strong></a>
  <ul class="collapse">
  <li><a href="#the-downsian-model" id="toc-the-downsian-model" class="nav-link" data-scroll-target="#the-downsian-model">The Downsian Model</a></li>
  <li><a href="#equilibrium-outcome" id="toc-equilibrium-outcome" class="nav-link" data-scroll-target="#equilibrium-outcome">Equilibrium Outcome</a></li>
  <li><a href="#empirical-evidence" id="toc-empirical-evidence" class="nav-link" data-scroll-target="#empirical-evidence">Empirical Evidence</a></li>
  </ul></li>
  <li><a href="#potential-explanations-for-divergence" id="toc-potential-explanations-for-divergence" class="nav-link" data-scroll-target="#potential-explanations-for-divergence"><strong>Potential Explanations for Divergence</strong></a>
  <ul class="collapse">
  <li><a href="#assumptions-of-the-downsian-model" id="toc-assumptions-of-the-downsian-model" class="nav-link" data-scroll-target="#assumptions-of-the-downsian-model">Assumptions of the Downsian Model</a></li>
  <li><a href="#policy-seeking-candidates" id="toc-policy-seeking-candidates" class="nav-link" data-scroll-target="#policy-seeking-candidates">Policy-Seeking Candidates</a></li>
  <li><a href="#voters-are-non-uniformly-distributed" id="toc-voters-are-non-uniformly-distributed" class="nav-link" data-scroll-target="#voters-are-non-uniformly-distributed">Voters are Non-Uniformly Distributed</a></li>
  <li><a href="#more-than-2-parties" id="toc-more-than-2-parties" class="nav-link" data-scroll-target="#more-than-2-parties">More than 2 Parties</a></li>
  <li><a href="#multidimensional-policy-space" id="toc-multidimensional-policy-space" class="nav-link" data-scroll-target="#multidimensional-policy-space">Multidimensional Policy Space</a></li>
  </ul></li>
  <li><a href="#competence-in-elections" id="toc-competence-in-elections" class="nav-link" data-scroll-target="#competence-in-elections"><strong>Competence in Elections</strong></a>
  <ul class="collapse">
  <li><a href="#electoral-model-with-competence" id="toc-electoral-model-with-competence" class="nav-link" data-scroll-target="#electoral-model-with-competence">Electoral Model with Competence</a></li>
  <li><a href="#equilibrium-outcome-1" id="toc-equilibrium-outcome-1" class="nav-link" data-scroll-target="#equilibrium-outcome-1">Equilibrium Outcome</a></li>
  <li><a href="#interpretation-of-the-model" id="toc-interpretation-of-the-model" class="nav-link" data-scroll-target="#interpretation-of-the-model">Interpretation of the Model</a></li>
  </ul></li>
  <li><a href="#probabilistic-voting" id="toc-probabilistic-voting" class="nav-link" data-scroll-target="#probabilistic-voting"><strong>Probabilistic Voting</strong></a></li>
  <li><a href="#public-finance-model" id="toc-public-finance-model" class="nav-link" data-scroll-target="#public-finance-model"><strong>Public Finance Model</strong></a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>Summary</p>
<hr>
<section id="median-voter-theory" class="level1">
<h1><strong>Median Voter Theory</strong></h1>
<section id="the-downsian-model" class="level3">
<h3 class="anchored" data-anchor-id="the-downsian-model">The Downsian Model</h3>
<p>Two candidates <span class="math inline">j \in \{A, B\}</span> are competing in an election for political office. Both candidates only have one goal - to win the election. Their utility functions are as follows:</p>
<p><span class="math display">
u_j = \begin{cases}
R \quad \text{if win election} \\
0 \quad \text{if lose election}
\end{cases}
</span></p>
<p>For the election, each candidate <span class="math inline">j \in \{A, B \}</span> can choose a platform <span class="math inline">p_j \in [-1, 1]</span>.</p>
<p>The citizens, who will vote in the election, each have a preferred policy <span class="math inline">q^i \in [-1, 1]</span>. Citizens’ preferred policies <span class="math inline">q^i</span> are uniformly distributed within this continuum.</p>
<p>Citizens have single peaked symmetric preferences around their <span class="math inline">q^i</span>. Citizens will vote for the candidate who’s policy <span class="math inline">p_j</span> is closest to <span class="math inline">q_i</span>.</p>
<p>The timing of the game is as follows:</p>
<ol type="1">
<li>Each politician <span class="math inline">j \in \{A, B\}</span> will select platform <span class="math inline">p_j \in [-1, 1]</span>.</li>
<li>Voters observe <span class="math inline">p_A, p_B</span>, and vote <span class="math inline">e_i \in \{A, B \}</span>.</li>
<li>The politician with most votes wins, and payoffs are realised.</li>
</ol>
<p>Assume that if there is a tie, there is a coin toss to determine the election.</p>
<p><br></p>
</section>
<section id="equilibrium-outcome" class="level3">
<h3 class="anchored" data-anchor-id="equilibrium-outcome">Equilibrium Outcome</h3>
<p>Since each player only cares about winning the election, and gets 0 payoff if they lose, we only need to focus on the probability of each candidate winning. Both candidates want to maximise their chances of winning.</p>
<p><span class="math display">
\max\limits_{p_j \in [0, 1]} \underbrace{Pr(e=j|p_j,p_{-j})}_{\text{Pr } j \text{ wins given chosen policies}}
</span></p>
<p>Since there are two candidates, this implies that to win the election, a candidate must win 50% of the votes.</p>
<p>Since voter’s preferences are single peaked, this means that for either candidate to win, the 50% of votes they win must be in a continuum: i.e.&nbsp;they cannot win the voter at <span class="math inline">q^i = -1</span> and <span class="math inline">q_i = 1</span> if they do not win the voters in between.</p>
<p>Under these assumptions, the median voter - whose position is exactly the 50th percentile of voters, becomes pivotal. It is not possible to win a continuum of voters more than 50% without winning the median voter.</p>
<p>Thus, the median voter is the pivotal vote that you need to win.</p>
<p>How can candidates <span class="math inline">j \in \{A, B\}</span> win the pivotal voter? Candidates win a voter’s vote if they are the closes to the voter’s preferred policy.</p>
<p>Thus, both parties must be closer than the other to the median voter’s policy. Each party will move closer, until they both converge on the median voter.</p>
<p>Let us denote <span class="math inline">q^m</span> as the median voter’s policy. Thus, the <strong>median voter theory</strong> predicts both party’s chosen positions will converge at <span class="math inline">q^m</span>:</p>
<p><span class="math display">
p_A^* = p_B^* = q^m
</span></p>
<p>At this equilibrium, there is a tie - both candidates win 50% of the vote, and thus, both have 50% probability of winning the election.</p>
<p>If either player moves away from this position, they will lose the median voter, and lose the election. Thus, there exists no profitable deviation from this equilibrium.</p>
<p><br></p>
</section>
<section id="empirical-evidence" class="level3">
<h3 class="anchored" data-anchor-id="empirical-evidence">Empirical Evidence</h3>
<p>The median voter theory thus argues that both parties should converge at the median voter’s preferences.</p>
<p>But is this actually the case? Do parties really converge at the same platform?</p>
<p>The Manifesto Project by the New York Times looked at US elections between 2000 and 2016. As shown by the figure below, clearly, both parties did not converge (and in fact, diverged 2012-onwards).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-386823128.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>Ansolabehere, Snyder, and Stewart (2001) surveyed some candidates from 1996. The area between the two lines is the “median” area. Clearly, a significant amount of candidates do not converge.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-437192753.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:70.0%"></p>
</figure>
</div>
<p>Further studies, including Bonica (2014) and Lee et al (2004), run other designs, such as regression discontinuities. All find divergence in party positions, not convergence.</p>
<p>Thus, there lacks empirical proof of consistent convergence. Of course, sometimes it occurs, but it is clearly not a given.</p>
<p><br></p>
<p><br></p>
<hr>
</section>
</section>
<section id="potential-explanations-for-divergence" class="level1">
<h1><strong>Potential Explanations for Divergence</strong></h1>
<section id="assumptions-of-the-downsian-model" class="level3">
<h3 class="anchored" data-anchor-id="assumptions-of-the-downsian-model">Assumptions of the Downsian Model</h3>
<p>Why is there no convergence of parties to the median voter, as was predicted by the Downsian Model? One obvious place to look is at the assumptions in the Downsian Model. Every formal model makes assumptions. Perhaps, the assumptions of the Downsian Model do not make sense.</p>
<p>Some assumptions of the Downsian Model are as follows:</p>
<ol type="1">
<li>Candidates only want to win elections, and do not care about what policies they choose, as long as they win elections.</li>
<li>Citizens’ preferred policies are distributed uniformly in <span class="math inline">q^i \in [-1, 1]</span>.</li>
<li>There are only two parties.</li>
<li>The policy space is one-dimensional, rather than multidimensional.</li>
</ol>
<p>Let us test each assumption one by one, and see if this causes our equilibrium outcome to change.</p>
<p><br></p>
</section>
<section id="policy-seeking-candidates" class="level3">
<h3 class="anchored" data-anchor-id="policy-seeking-candidates">Policy-Seeking Candidates</h3>
<p>We assumed in the Downsian Model, that all candidates care about is winning the election (Rent-seeking).</p>
<p>However, if we think about the real world, this isn’t really the case. It is hard to imagine that in order to win an election, Bernie Sanders would forgo everything he has fought for. Politicians like Bernie clearly have some utility derived from sticking with their beliefs and principles (Policy-seeking).</p>
<p>Let us take the Downsian model, but adjust the utility of the candidates <span class="math inline">j \in \{A, B\}</span> to reflect this policy-seeking nature.</p>
<p>Let us say party <span class="math inline">A</span> wants a policy as close as possible to <span class="math inline">-1</span>. The more they move away from <span class="math inline">-1</span>, the more they lose utility. For party <span class="math inline">B</span>, let us say their preferred policy is <span class="math inline">1</span>, and the more they move away from this, the more sad they become.</p>
<p>The final implemented policy of the winning party <span class="math inline">p</span>, is determined by who wins the election. If you lose the election, you have to deal with the winner’s preferred policy. Let us define <span class="math inline">\pi(p_A, p_B)</span> as the probability of candidate <span class="math inline">A</span> winning the election given the chosen <span class="math inline">p_A</span> and <span class="math inline">p_B</span>:</p>
<p><span class="math display">
u_A(p_A) = \underbrace{\pi(p_A, p_B)}_{\text{Pr A wins}}\underbrace{(-(p_A + 1)^2)}_{\text{A's utility for }p_A} + \underbrace{(1-\pi(p_A, p_B))}_{\text{Pr A loses}}\underbrace{(-(p_B + 1)^2)}_{\text{A's utility for }p_B}
</span></p>
<p><span class="math display">
u_B(p_B) =  \underbrace{(1-\pi(p_A, p_B))}_{\text{Pr B wins}}\underbrace{(-(p_B - 1)^2)}_{\text{B's utility for }p_B} + \underbrace{\pi(p_A, p_B)}_{\text{Pr B loses}}\underbrace{(-(p_A - 1)^2)}_{\text{B's utility for }p_A}
</span></p>
<p>What is the equilibrium of this game? <u>Surprisingly, it is still the median voter’s position <span class="math inline">q^m</span>.</u></p>
<p>Why? The key is that if a party loses an election, they have to deal with their opponents policy <span class="math inline">p</span>. Thus, you are willing to win the election at all costs, because you do not want your opponent to implement their policy.</p>
<p>For example, if it was a far-left candidate versus a far-right candidate, the far left candidate would be incentivised to move closer to the median voter’s position <span class="math inline">q^m</span>, thus winning the election, and preventing the far-left policies they hate.</p>
<p>Thus, even with policy-seeking candidates, the equilibrium still suggests that both parties converge at <span class="math inline">q^m</span>. So, policy seeking is not the reason we see divergence in the real world.</p>
<p><br></p>
</section>
<section id="voters-are-non-uniformly-distributed" class="level3">
<h3 class="anchored" data-anchor-id="voters-are-non-uniformly-distributed">Voters are Non-Uniformly Distributed</h3>
<p>One of the assumptions of the Downsian model is that citizen’s preferred policies are distributed uniformly in <span class="math inline">[-1, 1]</span>.</p>
<p>What if citizens were instead distributed normally, or heavily skewed, or heavily polarised with no one in the centre?</p>
<p>Well, it actually does not matter how citizens are distributed at all. <u>The median voter still remains the equilibrium outcome</u>:</p>
<p><span class="math display">
p_A^* = p_B^* = q^m
</span></p>
<p>Why? Well be definition, the median voter is the 50th percentile. And to win the election, you need 50% or more of the vote. Thus, the median voter is always pivotal.</p>
<p>The median voter’s position might change. If the data is very skewed right in <span class="math inline">[-1, 1]</span>, <span class="math inline">q^m</span> could be something like 0.5. But, the median voter is still the voter who decides the election, so both parties will still converge there.</p>
<p>Thus, no matter the distribution of the voters, both parties still converge at the median voter’s position <span class="math inline">q^m</span>.</p>
<p><br></p>
</section>
<section id="more-than-2-parties" class="level3">
<h3 class="anchored" data-anchor-id="more-than-2-parties">More than 2 Parties</h3>
<p>The Downsian model assumes that there are only 2 parties, <span class="math inline">j \in \{A, B\}</span>. However, this seems unrealistic - many countries have more than 2 parties in elections. Even the United States has the libertarians and the greens.</p>
<p>Let us adjust the downsian model to have candidates <span class="math inline">j \in \{A, B, C\}</span>. Is the equilibrium still at the median voter <span class="math inline">q^m</span>?</p>
<p>The answer is no! <u>We no longer have convergence when there are more than 2 parties.</u></p>
<p>To prove this, we have to think in terms of profitable deviations. If all three parties locate themselves at <span class="math inline">q^m</span>, they will all have a <span class="math inline">\frac{1}{3}</span> chance of winning the election.</p>
<p>However, if one party <span class="math inline">j</span> deviates by a small amount <span class="math inline">\epsilon</span> to a position <span class="math inline">q^m + \epsilon</span>, the game changes dramatically. If party <span class="math inline">j</span> deviates to the right by 1%, they are now closer to all players on the right of them, which consist of 49% of the votes. The other two candidates will share the 51% between them, so each gets 25.5%. Thus, party <span class="math inline">j</span> gets the largest share of the vote.</p>
<p>Thus, by deviating slightly from the median to <span class="math inline">q^m + \epsilon</span>, the deviating party <span class="math inline">j</span> will win the election. Thus, a profitable deviation exists, and convergence will not occur.</p>
<p><br></p>
</section>
<section id="multidimensional-policy-space" class="level3">
<h3 class="anchored" data-anchor-id="multidimensional-policy-space">Multidimensional Policy Space</h3>
<p>In the Downsian model, we assumed that voters and candidates choose between policies <span class="math inline">[-1, 1]</span>, which is a single dimension <span class="math inline">\mathbb R^1</span>.</p>
<p>But this is not realistic - every election has many different policy dimensions that parties compete on. You can take different positions on the economy, on social issues, on immigration, on free trade, and much more. Thus, a one-dimensional policy space is likely not realistic.</p>
<p>What if we adapt the Downsian model to <span class="math inline">\mathbb R^n</span> where <span class="math inline">n&gt;1</span>? Is there still convergence at the median voter <span class="math inline">q^m</span>?</p>
<p>The answer is no! <u>There is no longer convergence at the median voter’s preference <span class="math inline">q^m</span>.</u> To illustrate why, let us consider a divide-the-budget game.</p>
<p>3 legislators <span class="math inline">i = 1, 2, 3</span> have to divide a budget between there three constituencies, with each constituency receiving <span class="math inline">q_i</span> amount of funds. There is only a limited amount of money available, so <span class="math inline">q_1 + q_2 + q_3 = 1</span>.</p>
<p>To approve a budget distribution, a majority of legislators (so 2) must agree on the budget. What is the Nash Equilibrium of this game?</p>
<p>The answer is that <u>there is no Nash Equilibrium</u>. This is because for any proposed budget, there is always another budget which at least 2 players will prefer.</p>
<p>For example, let us say we have the budget:</p>
<p><span class="math display">
(q_1 = a, \ q_2 = b, \ q_3 = c)
</span></p>
<p>Since only two players have to agree, they can completely cut the share out of one legislator, and divide it between them two:</p>
<p><span class="math display">
(q_1 = 0, \ q_2 = b + \frac{a}{2}, \ q_3 = c + \frac{a}{2})
</span></p>
<p>And once again, 2 players can take the third player’s share, and divide it between them two:</p>
<p><span class="math display">
(q_1 = c, \ q_2 = b + a, \ q_c = 0)
</span></p>
<p>For every possible budget proposal, there is always one way to cut out one player, and get the other two on board. Thus, there is no equilibrium.</p>
<p>We can model a multidimensional Downsian Model in the same way. Each “dimension” of policy, like environmental, defense, social, etc., is a different budget allocation. Each party will always be able to “outflank” the other party by diverting budget away from one issue and giving it to another, making some citizens happier. Thus, there is no Nash Equilibria is the Downsian Model has multiple policy dimensions.</p>
<p><br></p>
<p><br></p>
<hr>
</section>
</section>
<section id="competence-in-elections" class="level1">
<h1><strong>Competence in Elections</strong></h1>
<section id="electoral-model-with-competence" class="level3">
<h3 class="anchored" data-anchor-id="electoral-model-with-competence">Electoral Model with Competence</h3>
<p>So far, we have focused on voters voting exclusively on policy. What about voters voting on competence?</p>
<p>Let us assume that there are only 3 policy positions in our policy space: <span class="math inline">p_i \in \{-1, 0, 1\}</span> (we can think of this as left, centrist, and right). Voters preferred policy <span class="math inline">q^i \in \{-1, 0, 1\}</span> as well, however, we will not define the distribution of voters (it could be uniform, skewed, or any distribution).</p>
<p>There are two parties <span class="math inline">j \in \{A, B\}</span> who want to win the election. However, party <span class="math inline">A</span> is widely considered by voters as the “more competent” voter, and thus, if party <span class="math inline">A</span> wins, all voters will get an extra payoff of <span class="math inline">\delta \in (0, 1)</span>. We can define voter utility as:</p>
<p><span class="math display">
u_i(p) = \underbrace{-|p - q^i|}_{\text{utility from } p} + \underbrace{I(p_A,p_B)\delta}_{\text{valence if A wins}}
</span></p>
<p>Where <span class="math inline">p</span> is the winning party’s policy position, <span class="math inline">q^i</span> is the voter’s preferred policy position, and <span class="math inline">I(p_A, p_B)</span> is an indicator function where if party <span class="math inline">A</span> wins, <span class="math inline">I(p_A, p_B) = 1</span>, and win party <span class="math inline">B</span> wins, <span class="math inline">I(p_A, p_B) = 0</span>.</p>
<p>Importantly, no parties know the exact location of the median voter. They only know that the median is at -1 with probability <span class="math inline">\alpha</span>, located at 1 with probability <span class="math inline">\alpha</span>, and located at 0 with probability <span class="math inline">1- 2\alpha</span>. Essentially, <span class="math inline">\alpha \in (0, \frac{1}{2})</span> captures the polarisation of the electorate.</p>
<p>The model basically says that competence does not supsrsede policy, but when voters are indifferent between two parties’ policies, they will always prefer the more competent candidate.</p>
<p><br></p>
</section>
<section id="equilibrium-outcome-1" class="level3">
<h3 class="anchored" data-anchor-id="equilibrium-outcome-1">Equilibrium Outcome</h3>
<p>We can write out the game in a matrix for easier understanding:</p>
<p><span class="math display">
\begin{bmatrix}
&amp; p_B = -1 &amp; p_B = 0 &amp; p_B = 1 \\
p_A = -1 &amp; (1,0) &amp; (\alpha, 1 - \alpha) &amp; (1- \alpha, \alpha) \\
p_A = 0 &amp; (1 - \alpha, \alpha) &amp; (1, 0) &amp; (1- \alpha, \alpha) \\
p_A = 1 &amp; (1- \alpha, \alpha) &amp; (\alpha, 1- \alpha)&amp; (1, 0)
\end{bmatrix}
</span></p>
<p>There is no pure strategy Nash Equilibrium. However, there is a mixed strategy Nash Equilibrium.</p>
<p>Let us look at party <span class="math inline">A</span>’s best responses while player <span class="math inline">B</span> mixes. Let us define <span class="math inline">Pr(p_B = 0) = q</span>, and <span class="math inline">Pr(p_B = -1) = Pr(p_B = 1) = \frac{1-q}{2}</span>.</p>
<p><span class="math display">
\begin{split}
u_A(-1) &amp; = 1 \cdot Pr(p_B = -1) +  \alpha \cdot Pr(p_B = 0) + (1-\alpha) \cdot Pr(p_B = 1) \\
&amp; = 1 \left( \frac{1-q}{2}\right) + \alpha q + (1- \alpha)\frac{1-q}{2} \\
&amp; =  \underbrace{\frac{1-q}{2}}_{\text{same as}} + \alpha q +  \underbrace{\frac{1-q}{2}}_{\text{same as}} - \frac{\alpha(1-q)}{2} \\
&amp; = \underbrace{1-q}_{\text{summed}} + \alpha q - \frac{\alpha}{2} + \frac{\alpha q}{2} \\
&amp; = 1-q + \frac{3 \alpha q}{2}-\frac{\alpha}{2} \\
\end{split}
</span></p>
<p><br></p>
<p><span class="math display">
\begin{split}
u_A(0) &amp; = (1-\alpha) \cdot Pr(p_B = -1) + 1 \cdot Pr(p_B = 0) + (1-\alpha) \cdot Pr(p_B = 1) \\
&amp; = \underbrace{(1-\alpha)\frac{1-q}{2}}_{\text{same as}} + 1q + \underbrace{(1-\alpha)\frac{1-q}{2}}_{\text{same as}} \\
&amp; = (1-q)(1- \alpha) + q \\
&amp; = \underbrace{1 - \alpha - q + q\alpha}_{\text{expanded out}} + q \\
&amp; = 1 - \alpha + q\alpha
\end{split}
</span></p>
<p>For candidate <span class="math inline">A</span> to have a mixed strategy, they must be indifferent between the two. Thus:</p>
<p><span class="math display">
\begin{split}
&amp; u_A(p_A = -1) = u_A(p_A = 0) \\
&amp; 1 - q - \frac{3 \alpha q}{2} - \frac{\alpha}{2} = 1 - \alpha - q \alpha \\
&amp; 2 - 2q + 3 q \alpha - \alpha = 2 - 2\alpha + 2 q \alpha \\
&amp; -2 + q \alpha = - \alpha \\
&amp; -q(2 - \alpha)  = - \alpha \\
&amp; q = \frac{\alpha}{2 - \alpha}
\end{split}
</span></p>
<p>Let us look at party <span class="math inline">B</span>’s best responses while player <span class="math inline">B</span> mixes. Let us define <span class="math inline">Pr(p_A = 0) = p</span>, and <span class="math inline">Pr(p_A = -1) = Pr(p_A = 1) = \frac{1-p}{2}</span>.</p>
<p><span class="math display">
\begin{split}
u_B(-1) &amp; = \underbrace{0 \cdot Pr(p_A = -1)}_{= \ 0} + \alpha \cdot Pr(p_A = 0) + \alpha \cdot Pr(p_A = 1) \\
&amp; = \alpha p + \alpha \left(\frac{1-p}{2}\right) \\
&amp; = \alpha p + \frac{\alpha}{2} - \frac{\alpha p}{2} \\
&amp; = \frac{\alpha p}{2} + \frac{\alpha}{2}
\end{split}
</span></p>
<p><br></p>
<p><span class="math display">
\begin{split}
u_B(0) &amp; = (1-\alpha) \cdot Pr(p_A = -1) + \underbrace{0 \cdot Pr(p_A = 0)}_{= \ 0} + (1-\alpha) \cdot Pr(p_A = 1) \\
&amp; = (1- \alpha)\left( \frac{1-p}{2} \right) + (1- \alpha)\left( \frac{1-p}{2} \right) \\
&amp; = (1- \alpha) (1-p) \\
&amp; = 1 - \alpha -p + p \alpha
\end{split}
</span></p>
<p>For candidate <span class="math inline">B</span> to have a mixed strategy, they must be indifferent between the two. Thus:</p>
<p><span class="math display">
\begin{split}
&amp; u_B(p_B = -1) = u_B(p_B = 0) \\
&amp; \frac{\alpha p}{2} + \frac{\alpha}{2} = 1 - \alpha -p + p \alpha \\
&amp; \alpha p + \alpha = 2 - 2\alpha - 2p + 2p \alpha \\
&amp; - \alpha p + 2p = 2 -3 \alpha \\
&amp; p(2 - \alpha) = 2 - 3 \alpha \\
&amp; p = \frac{2-3 \alpha}{2 - \alpha}
\end{split}
</span></p>
<p>Thus, we have found the probabilities that sustain a mixed strategy Nash Equilibrium.</p>
<p>Candidate <span class="math inline">A</span> will play <span class="math inline">p_A = 0</span> at probability <span class="math inline">\frac{2 - 3 \alpha}{2 - \alpha}</span>, and split the remainder between <span class="math inline">p_A = -1</span> and <span class="math inline">p_A = 1</span>.</p>
<p>Candidate <span class="math inline">B</span> will play <span class="math inline">p_B = 0</span> at probability <span class="math inline">\frac{\alpha}{2 - \alpha}</span>, and split the remainder between <span class="math inline">p_B = -1</span> and <span class="math inline">p_B = 1</span>.</p>
<p><br></p>
</section>
<section id="interpretation-of-the-model" class="level3">
<h3 class="anchored" data-anchor-id="interpretation-of-the-model">Interpretation of the Model</h3>
<p>We can graph the probability of each player playing the centrist policy 0, given different values of <span class="math inline">\alpha</span> (which is polarisation of the elite). Note in this graph, candidate <span class="math inline">L</span> refers to candidate <span class="math inline">A</span>, and candidate <span class="math inline">R</span> refers to candidate <span class="math inline">B</span>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-2676628971.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:50.0%"></p>
</figure>
</div>
<p>We can see the disadvantaged candidate <span class="math inline">B</span> is far less likely to propose playing the centrist policy 0. Why is this?</p>
<p>Well, if both candidates go to the centrist policy 0, who wins? In the Downsian model, the probability is 50% of winning for both candidates. However, because voters prefer the more competent candidate <span class="math inline">A</span>, if both converge to the same policy, the voters will vote for candidate <span class="math inline">A</span>. That means if both candidates converge to the centre, <span class="math inline">A</span> wins 100% of the time, and <span class="math inline">B</span> cannot win.</p>
<p>Thus, disadvantaged candidate <span class="math inline">B</span> has an incentive to become more extreme. Only by differentiating themselves, can they have a chance of winning. They have to hope that the median is indeed at -1 or 1.</p>
<p>Candidate <span class="math inline">A</span> thus has the incentive of copying candidate <span class="math inline">B</span>’s platform. This is because if they both have the same platform, the more competent <span class="math inline">A</span> will win with 100% probability.</p>
<p>What implications does this have? If we look at many elections, we will see the generally more perceived “incompetent” candidate will try to adopt more extreme positions.</p>
<p>For example, during the 2024 UK general election, the unpopular and widely regarded as less-competent Rishi Sunak began to adopt pretty wild policies, such as a National Service plan. Unfortunately for Sunak, the median voter was not at this more extreme end.</p>
<p>Another example could be Donald Trump, who is generally not seen as “competent” or “experienced” as many of his adversaries. He gambled by differentiating himself with populist outside policies. Luckily for Trump, the US median voter was indeed much more right-wing and populist than many had thought, and this propelled Trump into the White House twice.</p>
<p><br></p>
<p><br></p>
<hr>
</section>
</section>
<section id="probabilistic-voting" class="level1">
<h1><strong>Probabilistic Voting</strong></h1>
<p><br></p>
<p><br></p>
<hr>
</section>
<section id="public-finance-model" class="level1">
<h1><strong>Public Finance Model</strong></h1>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>