<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Unconstrained Optimisation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="3-2_files/libs/clipboard/clipboard.min.js"></script>
<script src="3-2_files/libs/quarto-html/quarto.js"></script>
<script src="3-2_files/libs/quarto-html/popper.min.js"></script>
<script src="3-2_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="3-2_files/libs/quarto-html/anchor.min.js"></script>
<link href="3-2_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="3-2_files/libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="3-2_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="3-2_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="3-2_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Unconstrained Optimisation</h1>
<p class="subtitle lead">Lesson 3.2, Maths for Political Science</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><a href="https://politicalscience.github.io/math">Course Hompage</a></p>
<section id="contents" class="level2">
<h2 class="anchored" data-anchor-id="contents">Table of Contents</h2>
<ol type="1">
<li><a href="#decision">Optimisation in Decision Theory</a></li>
<li><a href="#stats">Optimisation in Linear Models</a></li>
</ol>
<hr>
<p><a href="#contents">Table of Contents</a> | <a href="https://politicalscience.github.io/math">Course Hompage</a></p>
</section>
<section id="decision" class="level1">
<h1>Optimisation in Decision Theory</h1>
<section id="unconstrained-optimisation" class="level4">
<h4 class="anchored" data-anchor-id="unconstrained-optimisation">Unconstrained Optimisation</h4>
<p>Unconstrained optimisation is to find the minima/maxima of a function in order to optimise it. This can take the form of minimising errors, or maxmimising utility, and many other forms.</p>
<p>An optimisation problem is unconstrained if there are no constraints on the inputs. We will discusss constrained optimisation in the following lectures.</p>
<p><br></p>
</section>
<section id="decision-theory" class="level4">
<h4 class="anchored" data-anchor-id="decision-theory">Decision Theory</h4>
<p>The point of decision theory is to maximise your payoff/utility - essentially, make the decision that gets you the most benefit.</p>
<p>To do this, we need to maximise utility, or in other words, find the maximum of the <span class="math inline">\(U(x)\)</span> utility function.</p>
<p><br></p>
<p>Let us imagine this hypothetical situation:</p>
<ul>
<li><p>You want to contribute to some political campaign, because you might get some benefit (whether it be feeling good because you expressed yourself, or you expect the campaign will give you something in return).</p></li>
<li><p>Let us assume you get twice the utility/payoff <span class="math inline">\(U\)</span> of the contribution you put int <span class="math inline">\(x\)</span>: <span class="math inline">\(U(x)=2x\)</span></p></li>
<li><p>But, you also have other uses for your money. You could instead spend you money on some other stuff.</p></li>
<li><p>Let us say the cost of using the money on the campaign is <span class="math inline">\(-\frac{1}{2}x^2\)</span> , so we have to subtract this from our utility.</p></li>
</ul>
<p>Thus, our utility function for the scenario is:</p>
<p><span class="math display">\[
U(x) = 2x - \frac{1}{2}x^2
\]</span></p>
<p><br></p>
<p>We have already discussed finding <a href="https://politicalscience.github.io/math/3-1.html">maxima and minima</a> in the previous lecture. Let us apply what we previously learned here and find the maximum.</p>
<p><br></p>
<p>First, let us find the 1st derivative of <span class="math inline">\(U(x)\)</span>:</p>
<p><span class="math display">\[
U(x) = 2x - \frac{1}{2}x^2
\]</span></p>
<p><span class="math display">\[
U'(x) = \frac{d}{dx} [2x] + \frac{d}{dx} \left[ - \frac{1}{2} x^2 \right]
\]</span></p>
<p><span class="math display">\[
U'(x) = 2 - x
\]</span></p>
<p><br></p>
<p>Now, let us find the critical points of <span class="math inline">\(U(x)\)</span> by setting <span class="math inline">\(U'(x) = 0\)</span>:</p>
<p><span class="math display">\[
0 = 2-x
\]</span></p>
<p><span class="math display">\[
x=2
\]</span></p>
<p>We have a critical point <span class="math inline">\(x^*\)</span> at <span class="math inline">\(x=2\)</span></p>
<p><br></p>
<p>Now, let us find the second derivative of <span class="math inline">\(U(x)\)</span></p>
<p><span class="math display">\[
U''(x) = \frac{d}{dx} [2] + \frac{d}{dx} [-x]
\]</span></p>
<p><span class="math display">\[
U''(x) = -1
\]</span></p>
<p><br></p>
<p>Remember, that a Local Maximum exists at <span class="math inline">\(x_0\)</span> if <span class="math inline">\(f'(x_0) = 0\)</span> and <span class="math inline">\(f''(x_0) &lt; 0\)</span></p>
<ul>
<li>Both these conditions are met.</li>
</ul>
<p>So we know we have a local maximum at <span class="math inline">\(x=2\)</span></p>
<p><br></p>
<p>Because <span class="math inline">\(U''(x)\)</span> is a negative constant, we know it is globally concave. Thus, our only critical point at <span class="math inline">\(x=2\)</span>, is also a global maximum.</p>
<p><br></p>
<hr>
<p><a href="#contents">Table of Contents</a> | <a href="https://politicalscience.github.io/math">Course Hompage</a></p>
</section>
</section>
<section id="stats" class="level1">
<h1>Optimisation in Linear Models</h1>
<p>Optimisation is also frequently used in statistics.</p>
<p>Let us imagine a linear relationship between education ( <span class="math inline">\(x\)</span> ) and voter turnout ( <span class="math inline">\(y\)</span> ), where a one unit increase of education <span class="math inline">\(x\)</span> led to a <span class="math inline">\(\beta\)</span> increase of voter turnout <span class="math inline">\(y\)</span>:</p>
<p><span class="math display">\[
y = \beta x
\]</span></p>
<p><br></p>
<p>However, this isnâ€™t a deterministic model - it is a prediction model. No prediction model is perfectly accurate (especially not a linear model, as almost nothing is perfectly linear). Thus, we need to add an error term <span class="math inline">\(\epsilon\)</span> to our model:</p>
<p><span class="math display">\[
y = \beta x + \epsilon
\]</span></p>
<p>The error <span class="math inline">\(\epsilon\)</span> is basically everything else that explains turnout <span class="math inline">\(y\)</span>, that is not accounted for by a change in education <span class="math inline">\(x\)</span>.</p>
<ul>
<li><p>This could be another variable that is missing from the model</p></li>
<li><p>Or, this could simply just be randomness - there is always an element of randomness, even if we include every single possible predictor variable.</p></li>
</ul>
<p><br></p>
<p>What do we want out of this model? Well, we want to find the <span class="math inline">\(\beta\)</span> that best predicts <span class="math inline">\(y\)</span> from an input <span class="math inline">\(x\)</span>.</p>
<p>How do we do this? We find the <span class="math inline">\(\beta\)</span> that minimizes the squared error <span class="math inline">\(\epsilon^2\)</span>. Minimisation is a form of optimisation, turning this into an optimisation problem.</p>
<ul>
<li>Why squared error <span class="math inline">\(\epsilon^2\)</span>? We will cover this more in depth in the Regression Analysis course, but essentially, squaring the error removes the different between negative and positive errors, as we are concerned with the magnitude of error, not direction.</li>
</ul>
<p><br></p>
<p>How do we minimise squared error <span class="math inline">\(\epsilon^2\)</span>?</p>
<p>We could first start by solving our linear model for <span class="math inline">\(\epsilon^2\)</span></p>
<p><span class="math display">\[
y = \beta x + \epsilon
\]</span></p>
<p><span class="math display">\[
\epsilon = y - \beta x
\]</span></p>
<p><span class="math display">\[
\epsilon^2 = (y - \beta x)^2
\]</span></p>
<p><br></p>
<p>Let us call the above, a function of <span class="math inline">\(\beta\)</span>:</p>
<p><span class="math display">\[
f(\beta) = (y-\beta x)^2
\]</span></p>
<p><br></p>
<p>How do we minimise this function? We do the same as we did in the Decision Theory section, and the previous lecture on Minima and Maxima.</p>
<p>Let us find the first derivative <span class="math inline">\(f'(\beta)\)</span>. We will need the chain rule: <span class="math inline">\([(f \circ g)(x)]'=f'[g(x)]*g'(x)\)</span>.</p>
<p><span class="math display">\[
f(\beta) = (y - \beta x)^2
\]</span></p>
<p><br></p>
<p>Let us make <span class="math inline">\(f(\beta) = \beta^2\)</span>, and <span class="math inline">\(g(\beta) = y - \beta x\)</span>. Then we can find <span class="math inline">\(f'(x)\)</span> and <span class="math inline">\(g'(x)\)</span> in respect to <span class="math inline">\(\beta\)</span>:</p>
<p><span class="math display">\[
f'(\beta) = 2\beta, \space g'(\beta) = -x
\]</span></p>
<p><br></p>
<p>Now, plug back into chain rule <span class="math inline">\([(f \circ g)(x)]'=f'[g(x)]*g'(x)\)</span></p>
<p><span class="math display">\[
f'(\beta) = 2(y-\beta x)*-x
\]</span></p>
<p><span class="math display">\[
f'(\beta) = -2x(y-\beta x)
\]</span></p>
<p><br></p>
<p>Now, let us set <span class="math inline">\(f'(\beta) = 0\)</span> to find at what value of <span class="math inline">\(\beta\)</span> the critical points are:</p>
<p><span class="math display">\[
0 = -2x(y-\beta x)
\]</span></p>
<p><span class="math display">\[
0 = -2xy + 2x^2 \beta
\]</span></p>
<p><span class="math display">\[
2x^2 \beta = 2xy
\]</span></p>
<p><span class="math display">\[
\beta = \frac{2xy}{2x^2}
\]</span></p>
<p><span class="math display">\[
\beta = \frac{xy}{x^2}
\]</span></p>
<p>So, we have a critical point at <span class="math inline">\(\beta = \frac{xy}{x^2}\)</span></p>
<p><br></p>
<p>Now, let us do the second derivative test:</p>
<p><span class="math display">\[
f''(\beta) = \frac{d}{d \beta} [-2x(y-\beta x)
\]</span></p>
<p><span class="math display">\[
f''(\beta) = \frac{d}{d \beta}[-2xy + 2x^2 \beta]
\]</span></p>
<p><span class="math display">\[
f''(\beta) = 0 + 2x^2
\]</span></p>
<p><span class="math display">\[
f''(\beta) = 2x^2
\]</span></p>
<p><br></p>
<p><span class="math inline">\(f''(\beta) = 2x^2\)</span> is always positive, so we know the function is convex. Thus, we know we have a local minimum at <span class="math inline">\(\beta = \frac{xy}{x^2}\)</span>, and that is also a global minimum.</p>
<p><br></p>
<p>Note: In a real linear regression, you will be working with a set of different <span class="math inline">\(X\)</span> inputs, and a set of different <span class="math inline">\(Y\)</span> outputs.</p>
<ul>
<li><span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> take the form of vectors, which we will cover later in the course.</li>
</ul>
<p>However, this minimisation actually is quite close to the actual minimised value of <span class="math inline">\(\beta\)</span> as the one you would get with vectors.</p>
<p><br></p>
<hr>
<p><a href="#contents">Table of Contents</a> | <a href="https://politicalscience.github.io/math">Course Hompage</a></p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>