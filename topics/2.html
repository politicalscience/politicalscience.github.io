<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>The Uses of Elections</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="2_files/libs/clipboard/clipboard.min.js"></script>
<script src="2_files/libs/quarto-html/quarto.js"></script>
<script src="2_files/libs/quarto-html/popper.min.js"></script>
<script src="2_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="2_files/libs/quarto-html/anchor.min.js"></script>
<link href="2_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="2_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="2_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="2_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="2_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: true
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">The Uses of Elections</h1>
            <p class="subtitle lead">Topics in Political Science</p>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="99">
    <h2 id="toc-title">Table of Contents</h2>
   
  <ul>
  <li><a href="#elections-as-selection-devices" id="toc-elections-as-selection-devices" class="nav-link active" data-scroll-target="#elections-as-selection-devices"><strong>Elections as Selection Devices</strong></a>
  <ul class="collapse">
  <li><a href="#a-model-of-political-agency" id="toc-a-model-of-political-agency" class="nav-link" data-scroll-target="#a-model-of-political-agency">A Model of Political Agency</a></li>
  <li><a href="#voters-incentives" id="toc-voters-incentives" class="nav-link" data-scroll-target="#voters-incentives">Voter’s Incentives</a></li>
  <li><a href="#incumbents-decision" id="toc-incumbents-decision" class="nav-link" data-scroll-target="#incumbents-decision">Incumbent’s Decision</a></li>
  <li><a href="#voters-electoral-decision" id="toc-voters-electoral-decision" class="nav-link" data-scroll-target="#voters-electoral-decision">Voter’s Electoral Decision</a></li>
  <li><a href="#interpretation-of-the-outcome" id="toc-interpretation-of-the-outcome" class="nav-link" data-scroll-target="#interpretation-of-the-outcome">Interpretation of the Outcome</a></li>
  </ul></li>
  <li><a href="#elections-taxes-and-public-goods" id="toc-elections-taxes-and-public-goods" class="nav-link" data-scroll-target="#elections-taxes-and-public-goods"><strong>Elections, Taxes and Public Goods</strong></a>
  <ul class="collapse">
  <li><a href="#a-model-of-public-finance" id="toc-a-model-of-public-finance" class="nav-link" data-scroll-target="#a-model-of-public-finance">A Model of Public Finance</a></li>
  </ul></li>
  <li><a href="#elections-as-information-aggregators" id="toc-elections-as-information-aggregators" class="nav-link" data-scroll-target="#elections-as-information-aggregators"><strong>Elections as Information Aggregators</strong></a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>This chapter introduces how elections can be useful tools in democracies for governance. We first look at a model of how elections can help voters select good candidates to govern. Then, we look at how elections can help decide tax policy and public goods. Finally, we look at how elections can be tools to aggregate information across all voters to achieve better outcomes.</p>
<hr>
<section id="elections-as-selection-devices" class="level1">
<h1><strong>Elections as Selection Devices</strong></h1>
<section id="a-model-of-political-agency" class="level3">
<h3 class="anchored" data-anchor-id="a-model-of-political-agency">A Model of Political Agency</h3>
<p>We have 3 players: a voter, and 2 politicians (an incumbent <span class="math inline">I</span> and a challenger <span class="math inline">C</span> ). Our model will take place over two time periods, <span class="math inline">t \in \{1, 2\}</span>.</p>
<p>Each time period <span class="math inline">t</span> will have a bad policy outcome, or a good policy outcome: <span class="math inline">w_t \in \{0, 1\}</span>. The probability of a good outcome depends both on the <strong>effort</strong> and <strong>competence</strong> of the elected politician in office during that time period.</p>
<p><br></p>
<p>Politicians <span class="math inline">j \in (I, C)</span> each can have high competence, or low competence: <span class="math inline">\theta \in \{ \theta_H, \theta_L \}</span>. The prior probability of any politician being competent is <span class="math inline">p \in (0, 1)</span>. Only the politician themselves know their own competence.</p>
<p>Politicians, if in office, can exert effort into making better policies. The sitting politician in period <span class="math inline">t</span> can exert no effort, or a lot of effort: <span class="math inline">e_t \in \{0, 1 \}</span>.</p>
<p>However, politicians in choosing to exert effort, will have some costs. The costs <span class="math inline">c</span> are some function of effort <span class="math inline">e_t</span> and type <span class="math inline">\theta</span>: <span class="math inline">c(e_t, \theta)</span>.</p>
<p><span class="math display">
\begin{split}
&amp; \underbrace{(0, \theta_H) = c(0, \theta_L) = 0}_{\text{cost of no effort is always }0} \\
&amp; \underbrace{c(1, \theta_H) = 1}_{\text{cost of effort for } \theta_H} \ &lt; \ \underbrace{c(1, \theta_L) = 2}_{\text{cost of effort for } \theta_L}
\end{split}
</span></p>
<p>This is because more competent politicians will need less energy to achieve the same effort as low competence politicians, because of their competence.</p>
<p>The payoffs of politicians are given as a function of both <span class="math inline">R</span>, the utility they gain from being in office (given they win the election), and subtracting the costs of putting in effort <span class="math inline">c(e_t, \theta)</span>:</p>
<p><span class="math display">
u_j(e_1, e_2, \theta) = \gamma_{1j} (R - c(e_1, \theta)) + \gamma_{2j} (R - c(e_2, \theta))
</span></p>
<p>Where <span class="math inline">\gamma_{tj}</span> indicates if in time period <span class="math inline">t</span>, the politician <span class="math inline">j \in \{I, C \}</span> (either incumbent or challenger) is in office. When <span class="math inline">\gamma_{tj} = 1</span>, the politician is in office, and when <span class="math inline">\gamma_{tj} = 0</span>, the politician is not in office.</p>
<p><br></p>
<p>However, voters do not observe <strong>effort</strong> and <strong>competence</strong>. They only observe the outcome <span class="math inline">w_t</span> is good or bad. The probability <span class="math inline">\pi</span> of a good outcome <span class="math inline">w_t = 1</span> is:</p>
<p><span class="math display">
\pi = Pr(w_t = 1) = \begin{bmatrix}
&amp; e_t = 0 &amp; e_t = 1 \\
\theta_L &amp; 0 &amp; 0.5 \\
\theta_H &amp; 0.5 &amp; 1
\end{bmatrix}
</span></p>
<p>Or in other words, if a low-competence politician puts no effort, there is 0% chance of a good outcome. If a low-competence politician puts in effort, there is a 50% chance of a good outcome. If a high-competence politician puts in no effort, there is a 50% chance of a good outcome. If a high-competence politician puts in effort, there is a 100% chance of a good outcome.</p>
<p>Outcome is not a perfect indication of the politician’s actions or type, but a good outcome is indicative of either higher effort or high competence.</p>
<p>Voter’s utility is dependent on the policy outcomes - they want the best policy outcomes for themselves:</p>
<p><span class="math display">
u_i = w_1 + w_2
</span></p>
<p><br></p>
<p>The timing of the game is as follows:</p>
<ol type="1">
<li>Nature draws the type of the incumbent politician and the challenger politician <span class="math inline">\theta = \theta_H, \theta_L</span>, at probability <span class="math inline">Pr(\theta = \theta_H) = p</span> for each politician.</li>
<li>Incumbent politician (already in office during <span class="math inline">t=1</span>) decides how much effort to exert in period 1 <span class="math inline">e_1 \in \{0, 1\}</span>.</li>
<li>Period 1 outcome <span class="math inline">w_1</span> is realised.</li>
<li>Voter either re-elects the incumbent, or elects the challenger based off of <span class="math inline">w_1</span>.</li>
<li>The elected politician (either incumbent if re-elected, or challenger) then decides how much effort to exert in period 2 <span class="math inline">e_2 \in \{0, 1\}</span>.</li>
<li>Period 2 outcome <span class="math inline">w_2</span> is realised.</li>
</ol>
<p><br></p>
</section>
<section id="voters-incentives" class="level3">
<h3 class="anchored" data-anchor-id="voters-incentives">Voter’s Incentives</h3>
<p>Since this is a dynamic game, we should start from the end of the game, time period <span class="math inline">t=2</span>. Based on the model, there is no election after period 2 (the world essentially ends).</p>
<p>We know that politicians exert some cost <span class="math inline">c(e_t, \theta)</span> when exerting effort. However, when there is no election after <span class="math inline">t=2</span>, there is no incentive to exert any cost. Thus, the only rational strategy for any politician <span class="math inline">j</span> is to exert effort <span class="math inline">e_2</span> = 0.</p>
<p>What happens when effort <span class="math inline">e_2 = 0</span> is realised? If the politician in the 2nd round is type <span class="math inline">\theta_H</span>, then there is a 50% chance of a good outcome, which gives the voter an expected utility of <span class="math inline">w_2 = \frac{1}{2} (1)</span>. When the politician in the 2nd round is type <span class="math inline">\theta_H</span>, then there is a 50% chance of a bad outcome, which gives the voter an expected utility of <span class="math inline">w_2 = 0</span>.</p>
<p>From this, we can see that the voter gets a higher expected utility in <span class="math inline">t=2</span> if the politician who occupies office in <span class="math inline">t=2</span> is type <span class="math inline">\theta_H</span>. Thus, the goal of the voter now becomes to elect a <span class="math inline">\theta_H</span> politician in the election before <span class="math inline">t=2</span>.</p>
<p>Voters thus have 4 possible strategies to pursue:</p>
<ol type="1">
<li>Re-elect only when outcome in period 1 is good: <span class="math inline">w_1 = 1</span>.</li>
<li>Re-elect only when outcome in period 1 is bad: <span class="math inline">w_0 = 0</span>.</li>
<li>Never re-elect no matter the outcome in period 1.</li>
<li>Always re-elect no matter the outcome in period 1.</li>
</ol>
<p>Strategies 3 and 4 is never rational, and I will not provide the full proof here. The simple reason is that if you always re-elect or never re-elect regardless of outcome, then neither candidate has any incentive to put any effort, since they know they will 100% be re-elected or not-elected.</p>
<p>Strategy 2 can be rational in certain circumstances (which is counterintuitive), but again, this is not particularly useful for the purposes of this model.</p>
<p>For the rest of the time, we will focus on strategy 1: voter only re-elects the incumbent if they see a good outcome <span class="math inline">w_1 = 1</span> in <span class="math inline">t=1</span>.</p>
<p><br></p>
</section>
<section id="incumbents-decision" class="level3">
<h3 class="anchored" data-anchor-id="incumbents-decision">Incumbent’s Decision</h3>
<p>We are assuming that the voter only re-elects the incumbent if they see a good outcome <span class="math inline">w_1 = 1</span> in <span class="math inline">t=1</span>. This implies that the probability of re-election for the incumbent <span class="math inline">I</span> is equal to the probability of a good outcome <span class="math inline">w_1 = 1</span> in the first period <span class="math inline">t = 1</span>.</p>
<p>We know that a politician’s utility is given by the following utility function:</p>
<p><span class="math display">
u_j(e_1, e_2, \theta) = \gamma_{1j} (R - c(e_1, \theta)) + \gamma_{2j} (R - c(e_2, \theta))
</span></p>
<p>Let us look at the incumbent’s <span class="math inline">j = C</span> decisions in <span class="math inline">t=1</span>. Should the exert effort or not? Let us test all four combinations of competence type <span class="math inline">\theta</span> and effort level <span class="math inline">e_1</span>.</p>
<p>If the incumbent is <span class="math inline">\theta_L</span>, and he exerts no effort <span class="math inline">e_1=0</span>, what happens? The incumbent will not have any cost <span class="math inline">c( 0, \theta_L) =0</span>, since they are exerting no effort. But they will have 0% probability of producing a good outcome <span class="math inline">w_1 = 0</span>, so they will never be re-elected. Thus, we know that <span class="math inline">\gamma_{2j} = 0</span>, since they will never be in office in the second period. Thus, their utility is:</p>
<p><span class="math display">
u_I(0,0, \theta_L) = 1 (R - 0) + 0 (R - c(e_2, \theta)) = R
</span></p>
<p>If the incumbent is type <span class="math inline">\theta_L</span>, but he exerts effort, he has a cost <span class="math inline">c(1, \theta_L) = 1</span>, but also has a 50% chance of being re-elected to the second round (where no politician puts any effort, as seen above). Thus, his utility is:</p>
<p><span class="math display">
u_I(1,0, \theta_L) = 1(R - 2) + \frac{1}{2}(R - 0) = R - 2 + \frac{1}{2}R
</span></p>
<p>So, when should incumbent type <span class="math inline">\theta_L</span> use effort <span class="math inline">e_1 = 1</span>? Only when the payoff of <span class="math inline">e_1 = 1</span> is higher. Thus, we have the following inequality, and we can find the condition of <span class="math inline">R</span> that makes it so type <span class="math inline">\theta_L</span> wants to exert effort in <span class="math inline">t=1</span>:</p>
<p><span class="math display">
\begin{split}
&amp; u_I(1, 0, \theta_L) &gt; u_I(0, 0, \theta_L) \\
&amp; R - 2 + \frac{1}{2}R &gt; R \\
&amp; R &gt; 4
\end{split}
</span></p>
<p>Thus, incumbent with type <span class="math inline">\theta_L</span> only wants to put in effort <span class="math inline">e_1 = 1</span> in <span class="math inline">t=1</span> if <span class="math inline">R&gt;4</span>.</p>
<p><br></p>
<p>Now let us do the same for <span class="math inline">\theta_H</span>. If he puts in no effort <span class="math inline">e_1 = 0</span>, he has a 50% chance of getting a good outcome <span class="math inline">w_1 = 1</span>, and thus, a 50% of winning reelection. The utility is thus:</p>
<p><span class="math display">
u_I(0, 0, \theta_H) = 1(R-0) + \frac{1}{2}(R-0) = \frac{3}{2}R
</span></p>
<p>If type <span class="math inline">\theta_H</span> puts in effort <span class="math inline">e_1 = 1</span>, he has a 100% chance of getting a good outcome <span class="math inline">w_1 = 1</span>, and a 100% chance of winning reelection. Thus, the utility is:</p>
<p><span class="math display">
u_I(1, 0, \theta_H) = 1(R - 1) + 1(R-0) = 2R - 1
</span></p>
<p>So, when should incumbent type <span class="math inline">\theta_H</span> use effort <span class="math inline">e_1 = 1</span>? Only when the payoff of <span class="math inline">e_1 = 1</span> is higher. Thus, we have the following inequality, and we can find the condition of <span class="math inline">R</span> that makes it so type <span class="math inline">\theta_H</span> wants to exert effort in <span class="math inline">t=1</span>:</p>
<p><span class="math display">
\begin{split}
&amp; u_I(1, 0, \theta_H) ≥ u_I(0, 0, \theta_H) \\
&amp; 2R - 1 &gt; \frac{3}{2}R \\
&amp; R &gt;2
\end{split}
</span></p>
<p>Thus, incumbent with type <span class="math inline">\theta_H</span> only wants to put in effort <span class="math inline">e_1 = 1</span> in <span class="math inline">t=1</span> if <span class="math inline">R&gt;2</span>.</p>
<p>We can create a graph of when the incumbents want to exert effort <span class="math inline">e_1 = 1</span> given the value of <span class="math inline">R</span>:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-756073885.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%"></p>
</figure>
</div>
<p>We can see there are three different scenarios:</p>
<ol type="1">
<li>When <span class="math inline">R&lt;2</span>, both types have no incentive to put any effort.</li>
<li>When <span class="math inline">R \in (2, 4)</span>, only competent type <span class="math inline">\theta_H</span> have an incentive to put in effort.</li>
<li>When <span class="math inline">R &gt; 4</span>, both types have incentives to put in effort.</li>
</ol>
<p><br></p>
</section>
<section id="voters-electoral-decision" class="level3">
<h3 class="anchored" data-anchor-id="voters-electoral-decision">Voter’s Electoral Decision</h3>
<p><br></p>
</section>
<section id="interpretation-of-the-outcome" class="level3">
<h3 class="anchored" data-anchor-id="interpretation-of-the-outcome">Interpretation of the Outcome</h3>
<p><br></p>
<p><br></p>
<hr>
</section>
</section>
<section id="elections-taxes-and-public-goods" class="level1">
<h1><strong>Elections, Taxes and Public Goods</strong></h1>
<section id="a-model-of-public-finance" class="level3">
<h3 class="anchored" data-anchor-id="a-model-of-public-finance">A Model of Public Finance</h3>
<p><br></p>
<p><br></p>
<hr>
</section>
</section>
<section id="elections-as-information-aggregators" class="level1">
<h1><strong>Elections as Information Aggregators</strong></h1>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>