<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Kevin’s Guide to Political Science</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="2_files/libs/clipboard/clipboard.min.js"></script>
<script src="2_files/libs/quarto-html/quarto.js"></script>
<script src="2_files/libs/quarto-html/popper.min.js"></script>
<script src="2_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="2_files/libs/quarto-html/anchor.min.js"></script>
<link href="2_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="2_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="2_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="2_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="2_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: true
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Kevin’s Guide to Political Science</h1>
            <p class="subtitle lead">Lesson 1.2: Dominant Strategies and Equilibrium</p>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="99">
    <h2 id="toc-title">Lesson 1.2: Dominant Strategies and Equilibrium</h2>
   
  <ul class="collapse">
  <li><a href="#dominant-strategies-and-the-prisoners-dilemma" id="toc-dominant-strategies-and-the-prisoners-dilemma" class="nav-link active" data-scroll-target="#dominant-strategies-and-the-prisoners-dilemma">1.2.1: Dominant Strategies and the Prisoner’s Dilemma</a></li>
  <li><a href="#solutions-and-equilibrium-concepts" id="toc-solutions-and-equilibrium-concepts" class="nav-link" data-scroll-target="#solutions-and-equilibrium-concepts">1.2.2: Solutions and Equilibrium Concepts</a></li>
  <li><a href="#dominant-strategy-equilibrium" id="toc-dominant-strategy-equilibrium" class="nav-link" data-scroll-target="#dominant-strategy-equilibrium">1.2.3: Dominant Strategy Equilibrium</a></li>
  <li><a href="#dominated-strategies-and-iterated-dominance" id="toc-dominated-strategies-and-iterated-dominance" class="nav-link" data-scroll-target="#dominated-strategies-and-iterated-dominance">1.2.4: Dominated Strategies and Iterated Dominance</a></li>
  <li><a href="#example" id="toc-example" class="nav-link" data-scroll-target="#example">1.2.5: Example</a></li>
  <li><a href="#weak-dominance" id="toc-weak-dominance" class="nav-link" data-scroll-target="#weak-dominance">1.2.6: Weak Dominance</a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">





<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Lesson Overview
</div>
</div>
<div class="callout-body-container callout-body">
<p>In this lesson, we introduce the idea of strictly and weakly dominated strategies, and introduce our first equilibrium solution concept: dominant strategy equilibrium.</p>
<p>This lesson covers the following topics:</p>
<ul>
<li>Definitions of dominant strategies and the famous prisoner’s dilemma game.</li>
<li>Equilibrium concepts and dominant strategy equilibrium.</li>
<li>Using elimination to find equilibrium.</li>
</ul>
</div>
</div>
<p><br></p>
<hr>
<p><a href="https://politicalscience.github.io">Homepage</a></p>
<section id="dominant-strategies-and-the-prisoners-dilemma" class="level1">
<h1>1.2.1: Dominant Strategies and the Prisoner’s Dilemma</h1>
<p>In lesson 1.1, we discussed how game theory is the study of how one player’s actions affects another player’s outcomes/gains/payoffs. Thus, players have to anticipate what their opponents will do, and adjust their decisions/actions accordingly.</p>
<p>However, in some games, one action/strategy is always better than the other strategies, no matter what an opponent plays. That strategy which is always better than the other strategies, is called a <strong>dominant strategy</strong>.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition: Strictly Dominant Strategy
</div>
</div>
<div class="callout-body-container callout-body">
<p>A <strong>strictly dominant strategy</strong>, notated <span class="math inline">s_i^D</span>, is indeed a dominant strategy, if no matter what the opponent does, the payoff/utility for player <span class="math inline">i</span> is highest when they play <span class="math inline">s_i^D</span>. Mathematically:</p>
<p><span class="math display">
u_i(s_i^D, s_{-i})&gt;u_i(s_i', s_{-i})
</span></p>
<p>Or more intuitively, the utility of player <span class="math inline">i</span> choosing their dominant strategy <span class="math inline">s_i^D</span>, is always greater than the utility of player <span class="math inline">i</span> choosing another strategy <span class="math inline">s_i'</span>, no matter the strategies chosen by the opponents <span class="math inline">s_{-i}</span>.</p>
</div>
</div>
<p>If player <span class="math inline">i</span> has a dominant strategy <span class="math inline">s_i^D</span>, then the other strategies <span class="math inline">s_i'</span> of player <span class="math inline">i</span> are considered to be <strong>strictly dominated</strong>.</p>
<p><br></p>
<p>A good example to introduce the idea of strictly dominant strategies is the <strong>Prisoner’s Dilemma Game</strong>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Game: Prisoner’s Dilemma
</div>
</div>
<div class="callout-body-container callout-body">
<p>Two suspects are arrested. If they both remain quiet (cooperate with each other), then both will be convicted for minor offences and sentenced to 1 month in jail. If both rat each other out (defect), then both will be sentenced to jail for 8 months. Finally, if one defects but the other does not, then the confessor is immediately released and the other is sentenced to 10 months.</p>
</div>
</div>
<p>We can represent this game in matrix form, where player 1 chooses between the <em>row</em> strategies, and player 2 chooses between the <em>column</em> strategies. The numbers below represent the payoffs, in the form (player 1’s payoff, player 2’s payoff):</p>
<p><span class="math display">
\begin{matrix}
&amp; \text{Cooperate} (P2) &amp; \text{Defect} (P2) \\
\text{Cooperate} (P1) &amp; -1, -1 &amp; -10, 0 \\
\text{Defect} (P1) &amp; 0, -10 &amp; -8, -8
\end{matrix}
</span></p>
<p><br></p>
<p>Now, let us look only at player 1’s choice of strategy. To do this, let us <em>hold fixed</em> player 2’s strategy.</p>
<p>Holding player 2’s strategy as <em>Cooperate</em> (by only showing the cooperate P2 column), player 1 has the following choice:</p>
<p><span class="math display">
\begin{matrix}
&amp; \text{Cooperate} (P2) \\
\text{Cooperate} (P1) &amp; -1, -1 \\
\text{Defect} (P1) &amp; 0, -10
\end{matrix}
</span></p>
<p>Here, we can see if player 1 picks <em>cooperate</em>, they get a payoff of -1. When player 1 picks <em>defect</em>, they get 0, which is a higher payoff. Thus, player 1 prefers to <em>defect</em> given player 2 holds their strategy <em>cooperate</em> constant.</p>
<p><br></p>
<p>Now, let us hold player 2’s strategy as <em>Defect</em> (by only showing the defect P2 column). Player 1 has the following choice:</p>
<p><span class="math display">
\begin{matrix}
&amp; \text{Defect} (P2) \\
\text{Cooperate} (P1) &amp; -10, 0 \\
\text{Defect} (P1) &amp; -8, -8
\end{matrix}
</span></p>
<p>Here, we can see that if player 1 picks <em>cooperate</em>, they get a payoff of -10. When player 1 picks <em>defect</em>, they get a payoff of -8, which is a higher payoff. Thus, player 1 prefers to <em>defect</em> given player 2 holds their strategy <em>defect</em> constant.</p>
<p><br></p>
<p>Thus, we have come to the following conclusions when holding player 2’s strategy constant:</p>
<ol type="1">
<li>Player 1 prefers to <em>defect</em> given player 2 holds their strategy <em>cooperate</em> constant.</li>
<li>Player 1 prefers to <em>defect</em> given player 2 holds their strategy <em>defect</em> constant.</li>
</ol>
<p>Notice how player 1 always prefers the strategy <em>defect</em>, no matter if player 2 decides to play <em>cooperate</em> or <em>defect</em>. Thus, player 1 prefers <em>defect</em> no matter the strategy of player 2, and thus, <em>defect</em> is a <strong>strictly dominant strategy</strong>.</p>
<p>Because the prisoner’s dilemma is symmetrical, this is also the same for player 2 - <em>defect</em> is a strictly dominant strategy for both players.</p>
<p><br></p>
<p><br></p>
<hr>
<p><a href="https://politicalscience.github.io">Homepage</a></p>
</section>
<section id="solutions-and-equilibrium-concepts" class="level1">
<h1>1.2.2: Solutions and Equilibrium Concepts</h1>
<p>So far, we have focused on strategies and the actions of players. However, we are often more interested in the actual outcomes of the games.</p>
<p>When we create games/models, we are often interested in its likely outcome. This is because we often model economic and political situations, and we want to know the likely outcomes of these situations to inform our understanding of the world, and implement new policies.</p>
<p>Thus, we need to find some <em>solution</em> to the games/models that we create. An <strong>equilibrium</strong> is a potential solution to the games, that restricts the set of all possible strategies to the most <em>reasonable</em> ones.</p>
<p><br></p>
<p>However, what is a <em>reasonable</em> strategy and outcome? To define <em>reasonable</em> strategies to find a equilibrium, we must make assumptions about reasonableness:</p>
<ol type="1">
<li>Players are <strong>rational</strong> - they aim to maximise their utility/payoffs. In other words, a utility of <span class="math inline">a</span> is preferred to <span class="math inline">b</span> if <span class="math inline">a &gt; b</span>.</li>
<li>Any equilibrium (and set of reasonable strategies) must be <strong>self-enforcing</strong> - i.e.&nbsp;players will reach the supposed solution/equilibrium without external forces telling them to do so, as they rationally want to enter the equilibrium.</li>
</ol>
<p><br></p>
<p>As we will explore in this course, there are many different equilibrium concepts - different ways to define equilibrium. Each equilibrium concept has its advantages and disadvantages. We typically evaluate equilibrium concepts with a few key concepts:</p>
<ol type="1">
<li><strong>Existence</strong>: how often does the equilibrium actually exist in a game? If an equilibrium defined by a equilibrium concept does not exist in most games, then it is not very useful, since it does not tell us the solution for most games.</li>
<li><strong>Uniqueness</strong>: How many equilibrium of this equilibrium concept exist in a game? If a equilibrium concept has too many equilibria for a given game, then that is not very useful for prediction, since we do not know which equilibria is more likely. We would prefer unique equilibria/solutions to our games.</li>
<li><strong>Robustness</strong>: How sensitive is the equilibrium of this equilibrium concept to small changes? After all, in the real world, people are not perfectly rational. Our models also simplify the complexity of the world. We want to be sure that slightly changing our model, or introducing slight imperfection in player behaviour, does not completely throw away our equilibrium predictions.</li>
</ol>
<p><br></p>
<p>Throughout this course, we will explore many different types of equilibrium concepts, their advantages and disadvantages, and what games they can be applied to.</p>
<p><br></p>
<p><br></p>
<hr>
<p><a href="https://politicalscience.github.io">Homepage</a></p>
</section>
<section id="dominant-strategy-equilibrium" class="level1">
<h1>1.2.3: Dominant Strategy Equilibrium</h1>
<p>The first solution concept we will introduce is the <strong>Dominant Strategy Equilibrium</strong>. A dominant strategy equilibrium occurs when all players play dominant strategies.</p>
<ul>
<li>After all, if everyone has a strictly dominant strategy (i.e.&nbsp;a preferred strategy regardless of the opponents strategy), then if everyone plays that preferred dominant strategy, that is probably a likely outcome of the game.</li>
</ul>
<p>We can define dominant strategy equilibrium more formally:</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition: Dominant Strategy Equilibrium
</div>
</div>
<div class="callout-body-container callout-body">
<p>A strategy profile for all players <span class="math inline">S^D = (S_1^D, S_2^D, \dots, S_N^D)</span> is a <strong>dominant strategy equilibrium</strong>, if for all players <span class="math inline">i</span>, <span class="math inline">u_i (S_i^D, s_{-i})&gt;u_i(s_i', s_{-i})</span>.</p>
<p>Or more intuitively, a strategy profile is a dominant strategy equilibrium, given every player <span class="math inline">1, \dots, N</span> is playing a dominant strategy.</p>
</div>
</div>
<p><br></p>
<p>For example, let us return to the Prisoner’s Dilemma Game:</p>
<p><span class="math display">
\begin{matrix}
&amp; \text{Cooperate} (P2) &amp; \text{Defect} (P2) \\
\text{Cooperate} (P1) &amp; -1, -1 &amp; -10, 0 \\
\text{Defect} (P1) &amp; 0, -10 &amp; -8, -8
\end{matrix}
</span></p>
<p>We already established that for both player 1 and player 2, <em>defect</em> is a dominant strategy.</p>
<p>We know that a dominant strategy equilibrium is when both players both play a dominant strategy. Thus, the dominant strategy equilibrium is when both players play <em>defect</em>, which results in an outcome of (-8, -8). We can notate this equilibrium as (Defect, Defect).</p>
<p><br></p>
<p>One important note is that a <u>equilibrium is a strategy profile</u>, not a payoff. So, in the Prisoner’s dilemma, the equilibrium IS <strong>NOT</strong> (-8, -8), as -8 is not a strategy profile. Instead, the equilibrium is (Defect, Defect).</p>
<ul>
<li>(-8, -8), or any other payoffs of an equilibrium, are considered the <strong>equilibrium outcome</strong>, not the equilibrium.</li>
</ul>
<p><br></p>
<p>Is a dominant strategy equilibrium a good solution concept? Let us evaluate its existence, uniqueness, and robustness:</p>
<ol type="1">
<li>Existence: Dominant strategy equilibrium is not good by this metric. This is because dominant strategies often do not exist (as we will see in the next lesson). Thus, dominant strategy equilibrium can only be used to find the solution in a small set of games.</li>
<li>Uniqueness: When a dominant strategy equilibrium does exist, it is guaranteed to be unique. This is because by definition, each player can only have one dominant strategy in a game (since that dominant strategy must always have a higher payoff than the other strategies). Thus, it is very unique, which is useful for prediction.</li>
<li>Robustness: Dominant strategies are relatively robust.</li>
</ol>
<p><br></p>
<p><br></p>
<hr>
<p><a href="https://politicalscience.github.io">Homepage</a></p>
</section>
<section id="dominated-strategies-and-iterated-dominance" class="level1">
<h1>1.2.4: Dominated Strategies and Iterated Dominance</h1>
<p>So far, we have focused on strictly <strong>dominant strategies</strong>, which are always better than other strategies, no matter the opponents strategy.</p>
<p>However, we can also consider the opposite: <strong>strictly dominated strategies</strong>. These are strategies that always give a worse payoff than another strategy, no matter the opponents strategy.</p>
<p>If a strategy is strictly dominated, that means it always gives a worse payoff than another strategy. That implies that if a player has a strictly dominated strategy, they will never choose that strategy, since another strategy is always better.</p>
<p>Thus, we can also find equilibrium through eliminating strictly dominated strategies, since we know they will never be chosen.</p>
<p>Once we eliminate strictly dominated strategies, we will often notice that other strategies also become strictly dominated for other players. By continuing the cycle, we can sometimes reach a single outcome - an equilibrium. This method is called <strong>iterated dominance</strong>.</p>
<p><br></p>
<p>For example, suppose we have the following game. Player 1 has two strategies: up or down. Player 2 has three strategies: Left, Middle, and Right:</p>
<p><span class="math display">
\begin{matrix}
&amp; \text{Left} &amp; \text{Middle} &amp; \text{Right} \\
\text{Up} &amp; 1,0 &amp; 1,2 &amp; 0,1 \\
\text{Down} &amp; 0,3 &amp; 0,1 &amp; 2,0
\end{matrix}
</span></p>
<p>Are there any strictly dominated strategies? Yes - for player 2 - strategy <em>right</em> is strictly dominated by strategy <em>middle</em>.</p>
<ul>
<li>Why? We can see if we hold player 1’s strategy fixed as <em>up</em>, player 2 playing <em>right</em> gets a payoff of 1, and player 2 playing <em>middle</em> gets a payoff of 2 which is better. If we hold player 1’s strategy fixed as <em>down</em>, once again, <em>middle</em> is better than <em>right</em>. Thus, <em>right</em> always gives a worse payoff than <em>middle</em>, no matter the opponents strategy.</li>
</ul>
<p><br></p>
<p>That means we can eliminate <em>right</em> (by deleting the column). Now, we have this game after our first elimination:</p>
<p><span class="math display">
\begin{matrix}
&amp; \text{Left} &amp; \text{Middle} \\
\text{Up} &amp; 1,0 &amp; 1,2 \\
\text{Down} &amp; 0,3 &amp; 0,1
\end{matrix}
</span></p>
<p>Is there another strictly dominated strategy? Yes - for player 1, strategy <em>down</em> is now strictly dominated by strategy <em>up</em>.</p>
<ul>
<li>We can see that if holding player 2’s strategy fixed as <em>left</em>, player 1 playing <em>up</em> results in a better payoff (1 &gt; 0). When holding player 2’s strategy fixed as <em>middle</em>, player 1 playing <em>up</em> results in a better payoff (1 &gt; 0). Thus, <em>down</em> always results in a worse payoff than <em>up</em>, no matter the opponents strategy.</li>
</ul>
<p><br></p>
<p>That means, we can eliminate <em>down</em> (by deleting the row). Now, we have this game after our second elimination:</p>
<p><span class="math display">
\begin{matrix}
&amp; \text{Left} &amp; \text{Middle} \\
\text{Up} &amp; 1,0 &amp; 1,2
\end{matrix}
</span></p>
<p>Now, is there another strictly dominated strategy? Yes - for player 2, <em>left</em> is strictly dominated. This is because when holding player 1’s strategy constant (well of course, there is only one strategy left for player 1), <em>left</em> has a higher payoff for player 2 than <em>middle</em>. Thus, <em>middle</em> always results in a worse payoff that <em>left</em>, so it is strictly dominated.</p>
<p><br></p>
<p>Thus, after eliminating middle, we are left with (Up, Left), which is our equilibrium. We obtained this equilibrium simply by eliminating implausible strategies.</p>
<p><br></p>
<p><br></p>
<hr>
<p><a href="https://politicalscience.github.io">Homepage</a></p>
</section>
<section id="example" class="level1">
<h1>1.2.5: Example</h1>
<p><br></p>
<hr>
<p><a href="https://politicalscience.github.io">Homepage</a></p>
</section>
<section id="weak-dominance" class="level1">
<h1>1.2.6: Weak Dominance</h1>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>