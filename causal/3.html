<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Selection On Observables</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="3_files/libs/clipboard/clipboard.min.js"></script>
<script src="3_files/libs/quarto-html/quarto.js"></script>
<script src="3_files/libs/quarto-html/popper.min.js"></script>
<script src="3_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="3_files/libs/quarto-html/anchor.min.js"></script>
<link href="3_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="3_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="3_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="3_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="3_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: true
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Selection On Observables</h1>
            <p class="subtitle lead">Quantitative Methods (Causal Inference)</p>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="99">
    <h2 id="toc-title">Table of Contents</h2>
   
  <ul>
  <li><a href="#identification" id="toc-identification" class="nav-link active" data-scroll-target="#identification"><strong>Identification</strong></a>
  <ul class="collapse">
  <li><a href="#graphical-identification" id="toc-graphical-identification" class="nav-link" data-scroll-target="#graphical-identification">Graphical Identification</a></li>
  <li><a href="#identification-assumptions" id="toc-identification-assumptions" class="nav-link" data-scroll-target="#identification-assumptions">Identification Assumptions</a></li>
  <li><a href="#proof-of-identification" id="toc-proof-of-identification" class="nav-link" data-scroll-target="#proof-of-identification">Proof of Identification</a></li>
  </ul></li>
  <li><a href="#estimators" id="toc-estimators" class="nav-link" data-scroll-target="#estimators"><strong>Estimators</strong></a>
  <ul class="collapse">
  <li><a href="#subclassification-estimator" id="toc-subclassification-estimator" class="nav-link" data-scroll-target="#subclassification-estimator">Subclassification Estimator</a></li>
  <li><a href="#matching-estimator" id="toc-matching-estimator" class="nav-link" data-scroll-target="#matching-estimator">Matching Estimator</a></li>
  <li><a href="#matching-with-multiple-covariates" id="toc-matching-with-multiple-covariates" class="nav-link" data-scroll-target="#matching-with-multiple-covariates">Matching with Multiple Covariates</a></li>
  <li><a href="#propensity-scores-matching" id="toc-propensity-scores-matching" class="nav-link" data-scroll-target="#propensity-scores-matching">Propensity Scores Matching</a></li>
  <li><a href="#inverse-probability-weighting-estimator" id="toc-inverse-probability-weighting-estimator" class="nav-link" data-scroll-target="#inverse-probability-weighting-estimator">Inverse Probability Weighting Estimator</a></li>
  <li><a href="#ordinary-least-squares-estimator" id="toc-ordinary-least-squares-estimator" class="nav-link" data-scroll-target="#ordinary-least-squares-estimator">Ordinary Least Squares Estimator</a></li>
  <li><a href="#fully-interacted-estimator" id="toc-fully-interacted-estimator" class="nav-link" data-scroll-target="#fully-interacted-estimator">Fully Interacted Estimator</a></li>
  </ul></li>
  <li><a href="#partial-identification" id="toc-partial-identification" class="nav-link" data-scroll-target="#partial-identification"><strong>Partial Identification</strong></a></li>
  <li><a href="#implementation-in-r" id="toc-implementation-in-r" class="nav-link" data-scroll-target="#implementation-in-r"><strong>Implementation in R</strong></a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>This chapter introduces the selection on observables framework, which allows us to identify causal effects by controlling for observable pre-treatment covariates. We discuss the main estimators, including subclassification, regression, and matching, as well as more advanced topics in sensitivity analysis and partial identification.</p>
<hr>
<section id="identification" class="level1">
<h1><strong>Identification</strong></h1>
<section id="graphical-identification" class="level3">
<h3 class="anchored" data-anchor-id="graphical-identification">Graphical Identification</h3>
<p>Without randomisation, we need some other way to account for pre-treatment covariates that may be confounding and causing selection bias. Controlling for a set of nodes/confounders <span class="math inline">X</span> can identify the causal effect of <span class="math inline">D \rightarrow Y</span>, if:</p>
<ol type="1">
<li>No node within set <span class="math inline">X</span> is a descendant of <span class="math inline">D</span> (no element within <span class="math inline">X</span> results from <span class="math inline">D</span>).</li>
<li>The nodes within set <span class="math inline">X</span> <a href="https://politicalscience.github.io/causal/1.html#blocked-paths">block all back-door paths</a> from <span class="math inline">D \rightarrow Y</span>.</li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-378311705.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:50.0%"></p>
</figure>
</div>
<p>In the figure above, to identify the causal path <span class="math inline">D \rightarrow Y</span>, we need to eliminate all back-door paths that are not <span class="math inline">D \rightarrow Y</span>, but link <span class="math inline">D</span> to <span class="math inline">Y</span>. The backdoor paths, and how they can be blocked, are:</p>
<ol type="1">
<li>Backdoor path <span class="math inline">D \rightarrow X \rightarrow Y</span>. To block this path, we must control for <span class="math inline">X</span>.</li>
<li>Backdoor path <span class="math inline">D \rightarrow V \rightarrow Y</span>. We do not need to control for <span class="math inline">V</span>, since it is post-treatment (a descendant of <span class="math inline">D</span>). In fact, <span class="math inline">V</span> is a <strong>bad control</strong> (see below).</li>
</ol>
<p>Thus, to identify <span class="math inline">D \rightarrow Y</span> here, we only need to control for <span class="math inline">X</span>, and no other variable.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Good and Bad Controls
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Good controls block backdoor paths, which facilitate identification of the causal effect.</p>
<p>Bad controls are when we control for post-treatment variables. For example, <span class="math inline">P</span> below is a bad control, since it is caused by <span class="math inline">D</span>, so it is post-treatment.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-1369053188.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:40.0%"></p>
</figure>
</div>
<p>You also never want to control variables that only predict <span class="math inline">D</span>. These are bad because controlling for these removes variation in <span class="math inline">D</span> that could be useful.</p>
<p>Neutral controls are ones that don’t identify the causal effect, but improve efficiency. For example, <span class="math inline">Q</span> below affects <span class="math inline">Y</span>, but there is no backdoor path. Controlling <span class="math inline">Q</span> will not help identification, but can control noise in <span class="math inline">Y</span> which may increase efficiency.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-1555756596.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:40.0%"></p>
</figure>
</div>
</div>
</div>
</div>
<p><br></p>
</section>
<section id="identification-assumptions" class="level3">
<h3 class="anchored" data-anchor-id="identification-assumptions">Identification Assumptions</h3>
<p>Once we have determined the set of confounders <span class="math inline">X</span> that we need to control for to isolate the causal effect of interest, the assumptions needed for identification of causal effects are:</p>
<ol type="1">
<li><strong>Conditional Ignorability</strong> (also known as exogeneity or independence): Among units with identical confounder values <span class="math inline">X_i</span>, treatment <span class="math inline">D_i</span> is as-if randomly assigned. Or in other words, potential outcomes are independent from treatment within each specific confounder value <span class="math inline">X_i = x</span>.</li>
</ol>
<p><span class="math display">
(Y_{0i}, Y_{1i}) \perp D_i  \ | \ X_i = x, \quad \forall \ x \in \mathcal X
</span></p>
<p>This implies that for any given value of all confounders <span class="math inline">X_i = x</span>, we know that potential outcomes <span class="math inline">Y_{di}</span> are equivalent between treatment and control:</p>
<p><span class="math display">
\begin{split}
E(Y_{1i}|X_i = x) = E(Y_{1i}|D_i = 1, X_i = x) = E(Y_{1i}|D_i = 0, X_i = x) \\
E(Y_{0i}|X_i = x) = E(Y_{0i}|D_i = 1, X_i = x) = E(Y_{0i}|D_i = 0, X_i = x)
\end{split}
</span></p>
<ol start="2" type="1">
<li><strong>Common Support</strong>: for any unit <span class="math inline">i</span> with value of <span class="math inline">X_i</span>, there is a non-zero probability that they could be assigned to both control <span class="math inline">D_i = 0</span> or treatment <span class="math inline">D_i = 1</span>.</li>
</ol>
<p><span class="math display">
0 &lt; Pr(D_i = 1 \ | X_i = x) &lt; 1 \quad \forall \ x \in \mathcal X
</span></p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Example of Identification Assumptions
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Imagine we have a theory that being abducted <span class="math inline">D</span> causes turning out to vote.</p>
<p>Blattman (2009) finds that age is the primary way violent groups chose to abduct individuals: abduction parties released young children and older adults, but kept all adolescent and young males.</p>
<p>That means our theory is that age <span class="math inline">X</span> affects selection into treatment <span class="math inline">D</span>. Young children and older adults are less likely to get abducted <span class="math inline">D</span>, while adolescent and young males are more likely <span class="math inline">D</span>.</p>
</div>
</div>
</div>
<p><br></p>
</section>
<section id="proof-of-identification" class="level3">
<h3 class="anchored" data-anchor-id="proof-of-identification">Proof of Identification</h3>
<p>With our assumptions above, we can identify the ATE. We start with the <a href="https://politicalscience.github.io/causal/1.html#conditional-average-treatment-effect-cate">conditional average treatment effect</a>, conditional on some value of confounders <span class="math inline">X_i = x</span>:</p>
<p><span class="math display">
\begin{split}
\tau_{CATE}(x) &amp; = E(Y_{1i} - Y_{0i} \ | \ X_i = x) \\
&amp; = E(Y_{1i}|X_i = x) - E(Y_{0i}|X_i = x) \\
&amp; = \underbrace{E(Y_{1i}|D_i = 1, X_i = x)}_{\because \text{ conditional ignorability} \\ } - \underbrace{E(Y_{0i}|D_i = 0X_i = x)}_{\because \text{ conditional ignorability}} \\
&amp; = \underbrace{E(Y_i|D_i = 1, X_i = x)}_{\because \text{ observable outcome}} - \underbrace{E(Y_i|D_i = 0, X_i = x)}_{\because \text{ observable outcome}}
\end{split}
</span></p>
<p>Now, let us discuss the ATE, and plug in the CATE to identify it:</p>
<p><span class="math display">
\begin{split}
\tau_{ATE} &amp; = E(Y_{1i} - Y_{0i}) \\
&amp; = \underbrace{\int \overbrace{E(Y_{1i} - Y_{0i} \ | \ X_i = x)}^{\text{CATE at }X_i = x} d \ \overbrace{Pr(X_i = x)}^{\text{prob of }X_i = x}}_{\text{weighted average, with weight being } Pr(X_i = x)} \\
&amp; = \int(\underbrace{E(Y_i|D_i = 1, X_i) - E(Y_i|D_i = 0, X_i)}_{\because \text{ CATE proof above}})d \ Pr(X_i = x)
\end{split}
</span></p>
<p>This means the ATE is identified as the weighted average of all the conditional average treatment effects. The conditional average treatment effect is the difference-in-means of the observed <span class="math inline">Y_i</span> at every possible value of <span class="math inline">X_i = x</span>.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Identification of the ATT
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>We can weaken our initial assumptions, and still calculate the ATT.</p>
<ol type="1">
<li>Weakened conditional ignorability: Only <span class="math inline">Y_{0i}</span> needs to be independent of <span class="math inline">D_i</span> for units with the same covariates <span class="math inline">X_i</span>. Or in other words, <span class="math inline">(Y_{0i}) \perp D_i | X_i = x</span>. This implies:</li>
</ol>
<p><span class="math display">
E(Y_{0i}|X_i = x) = E(Y_{0i}|D_i = 0, X_i = x) = E(Y_{0i}|D_i = 1, X_i = x)
</span></p>
<ol start="2" type="1">
<li>Weakened common support: <span class="math inline">Pr(D_i = 1 |X_i = x) &lt; 1</span>.</li>
</ol>
<p>Let us start with the conditional ATT:</p>
<p><span class="math display">
\begin{split}
\tau_{CATT}(x) &amp; = E(Y_{1i}-Y_{0i}|D_i = 1, X_i = x) \\
&amp; = E(Y_{1i}|D_i = 1, X_i = x) - E(Y_{0i}|D_i = 1, X_i = x) \\
&amp; = E(Y_{1i}|D_i = 1, X_i = x) - \underbrace{E(Y_{0i}|D_i = 0, X_i = x)}_{\because \text{ weakened cond. ignorability}} \\
&amp; = \underbrace{E(Y_i|D_i=1, X_i = x)}_{\because \text{ observable outcome}} - \underbrace{E(Y_1|D_i = 0, X_i x)}_{\because \text{ observable outcome}}
\end{split}
</span></p>
<p>Now, look at the ATT, and plug in CATT to identify it.</p>
<p><span class="math display">
\begin{split}
\tau_{ATT} &amp; = E(Y_{1i} - Y_{0i}|D_i = 1) \\
&amp; = \underbrace{\int \overbrace{E(Y_{1i} - Y_{0i}|D_i = 1, X_i = x)}^{\text{CATT at }X_i = x}d \ \overbrace{Pr(X_i = x|D_i = 1)}^{Pr(X_i = x) \text{ within treatment}}}_{\text{weighted average, with weight being } Pr(X_i = x)} \\
&amp; = \int (E(Y_i|D_i = 1, X_i = x) - E(Y_i|D_i = 0, X_i = x))d \ Pr(X_i = x|D_i = 1)
\end{split}
</span></p>
<p>Even when all assumptions are met for identification of the ATE, the <span class="math inline">\tau_{ATE}</span> can be different than the <span class="math inline">\tau_{ATT}</span>. This is because the weights <span class="math inline">Pr(X_i = x|D_i = 1)</span> for the ATT are different than the ATE <span class="math inline">Pr(X_i = x)</span>.</p>
</div>
</div>
</div>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Discrete X Identification
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Above, we assumed that the pre-treatment covariate <span class="math inline">X</span> is continuous. This is why we need an integral.</p>
<p>However, we can simplify this if <span class="math inline">X</span> is discrete:</p>
<p><span class="math display">
\begin{split}
&amp; \tau_{ATE} = \sum\limits_{x \in \mathcal X} ( E(Y_i|D_i = 1, X_i = x) - E(Y_i|D_i = 0, X_i = x)) Pr(X_i = x) \\
&amp; \tau_{ATT} = \sum\limits_{x \in \mathcal X} ( E(Y_i|D_i = 1, X_i = x) - E(Y_i|D_i = 0, X_i = x)) Pr(X_i = x | D_i = 1)
\end{split}
</span></p>
</div>
</div>
</div>
<p><br></p>
<p><br></p>
<hr>
</section>
</section>
<section id="estimators" class="level1">
<h1><strong>Estimators</strong></h1>
<section id="subclassification-estimator" class="level3">
<h3 class="anchored" data-anchor-id="subclassification-estimator">Subclassification Estimator</h3>
<p>When pre-treatment covariate <span class="math inline">X</span> is discrete, we know the identification result of the ATE is:</p>
<p><span class="math display">
\tau_{ATE} = \sum\limits_{x \in \mathcal X} \underbrace{( E(Y_i|D_i = 1, X_i = x) - E(Y_i|D_i = 0, X_i = x))}_{\text{CATE at }X_i = x} \underbrace{Pr(X_i = x)}_{\text{weight}}
</span></p>
<p>We can calculate this within our give sample to get the <strong>subclassificaiton</strong> estimator:</p>
<p><span class="math display">
\hat\tau_{ATE} = \sum\limits_{j=1}^M \underbrace{(\bar Y_{1j} - \bar Y_{0j})}_{\text{CATE at} X_i = x} \underbrace{\frac{n_j}{n}}_{\text{weight}}
</span></p>
<ul>
<li>Where <span class="math inline">M</span> is the number of strata (levels/categories of <span class="math inline">X</span>), and <span class="math inline">j</span> is one specific level/category of <span class="math inline">X</span>.</li>
<li>Where <span class="math inline">n_j</span> is the number of units in a level/category <span class="math inline">j</span> of <span class="math inline">X</span>.</li>
<li>Where <span class="math inline">\bar Y_{dj}</span> is the mean outcome for units with <span class="math inline">D_i = d</span> in level/category <span class="math inline">j</span> of <span class="math inline">X</span>.</li>
</ul>
<p>For subclassificaion to be possible, within each level <span class="math inline">j</span> of covariate <span class="math inline">X</span>, there must be at least one unit in control <span class="math inline">D=0</span> and treatment <span class="math inline">D=1</span>.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Intuitive Procedure of Subclassification
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>More intuitively, the procedure is as follows:</p>
<ol type="1">
<li>Choose one specific value for all covaraites <span class="math inline">X</span>. Find the average treatment effect within this specific value of <span class="math inline">X</span>.</li>
<li>Multiply that average treatment effect by the number of observations that meet this specific value of <span class="math inline">X</span> divided by the total number of units.</li>
<li>Do this for every possible values of all covaraites <span class="math inline">X</span>, then sum up all the weighted average treatment effects to get the overall ATE.</li>
</ol>
</div>
</div>
</div>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-6-contents" aria-controls="callout-6" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Subclassification with Multiple Confounders
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-6" class="callout-6-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Let us say we have 2 confounders, <span class="math inline">X_1</span> and <span class="math inline">X_2</span>. Both confounders are categorical with 3 categories.</p>
<p>We would need to create <span class="math inline">M=9</span> levels of strata, for every possible combination of values of <span class="math inline">X_1</span> and <span class="math inline">X_2</span>. Then, we would estimate the within-strata average treatment effect, and weight them.</p>
<p>This illustrates how with large amounts of confounders, you will need a huge number of stratum. This makes subclassification infeasible in many cases.</p>
</div>
</div>
</div>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-7-contents" aria-controls="callout-7" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Subclassification for the ATT
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-7" class="callout-7-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>When pre-treatment covariate <span class="math inline">X</span> is discrete, the identification result of the ATT is:</p>
<p><span class="math display">
\tau_{ATT} = \sum\limits_{x \in \mathcal X} ( E(Y_i|D_i = 1, X_i = x) - E(Y_i|D_i = 0, X_i = x)) Pr(X_i = x | D_i = 1)
</span></p>
<p>We can calculate this within our give sample to get the subclassificaiton estimator:</p>
<p><span class="math display">
\hat\tau_{ATT} = \sum\limits_{j=1}^M(\bar Y_{1j} - \bar Y_{0j}) \frac{n_{1j}}{n_1}
</span></p>
<ul>
<li>Where <span class="math inline">M</span> is the number of strata (levels/categories of <span class="math inline">X</span>).</li>
<li>Where <span class="math inline">n_j</span> is the number of units in a level/category <span class="math inline">j</span> of <span class="math inline">X</span>.</li>
<li>Where <span class="math inline">n_{1j}</span> is the number of treated cells <span class="math inline">D = 1</span> in a level/category <span class="math inline">j</span> of <span class="math inline">X</span>.</li>
<li>Where <span class="math inline">\bar Y_{dj}</span> is the mean outcome for units with <span class="math inline">D_i = d</span> in level/category <span class="math inline">j</span> of <span class="math inline">X</span>.</li>
</ul>
</div>
</div>
</div>
<p><br></p>
</section>
<section id="matching-estimator" class="level3">
<h3 class="anchored" data-anchor-id="matching-estimator">Matching Estimator</h3>
<p>We have a <a href="https://politicalscience.github.io/causal/1.html#observed-outcomes-and-missing-data">missing data problem</a> in causal inference: we do not know all the potential outcomes. Matching “estimates” missing potential outcomes of a unit.</p>
<p>For each observation in the treated group, matching finds an observation in the untreated group that have the most similar values of a set of pre-treatment covariates <span class="math inline">X</span>. Thus, we have pairs of treatment-control observations that act as counterfactuals. We can estimate the ATT as the average difference in observed outcomes within the pairs:</p>
<p><span class="math display">
\hat\tau_{ATT} = \frac{1}{n_1} \sum\limits_{i:D_i = 1}(Y_i - \widetilde{Y_i})
</span></p>
<ul>
<li>Where <span class="math inline">n_1</span> is the number of units in the treatment group.</li>
<li>Where <span class="math inline">Y_i</span> is the unit’s observed <span class="math inline">Y</span> in the treatment group.</li>
<li>Where <span class="math inline">\tilde Y_i</span> is unit <span class="math inline">i</span>’s closest neighbour in the untreated group.</li>
</ul>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-8-contents" aria-controls="callout-8" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Choices during Matching
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-8" class="callout-8-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>We have to make several choices when conducting matching.</p>
<ol type="1">
<li><strong>What covariates</strong> to match on. We generally want to select a set of pre-treatment covariates <span class="math inline">X</span> such that these covariates ensure the conditional ignorability assumption is met.</li>
<li>Match <strong>with or without replacement</strong>. Matching with replacement means that once you have used one control unit to match to a treatment unit, you can still use that same control unit to match to another treatment unit. This has advantages since you can ensure better and closer matches. However, matching without replacement is also possible.</li>
<li><strong>How many to match</strong>. You can decide to match multiple control units to one treatment unit, and use the average of the treatment units to approximate a true control unit. This may result in more accurate matches for treatment units that may not have a good single control unit to match to.</li>
</ol>
<p>We can also choose to use more advanced matching methods, such as Mahalanobis Distance matching or Propensity Score matching, which are shown below. These are good for matching on more <span class="math inline">X</span>.</p>
</div>
</div>
</div>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-9-contents" aria-controls="callout-9" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Matching on Multiple Neighbours
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-9" class="callout-9-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Sometimes, a treatment unit may not have one close control unit to match to. Instead, we could use a combination of control units to match to the treatment unit, and use the average <span class="math inline">Y</span> of those combination of control units to approximate a more accurate match.</p>
<p>Suppose we use <span class="math inline">M_i</span> number of close control units to match to a treatment unit <span class="math inline">i</span>. Then, the matching estimator would be defined as follows:</p>
<p><span class="math display">
\hat\tau_{ATT} = \frac{1}{n_1} \sum\limits_{i:D_i = 1}(Y_i - \left(\frac{1}{M_i} \sum\limits_{m=1}^{M_i} \widetilde{Y_{i_m}}\right))
</span></p>
<p>Where <span class="math inline">\widetilde{Y_{i_m}}</span> is the obsered outcome for the <span class="math inline">m</span>th match of unit <span class="math inline">i</span>.</p>
</div>
</div>
</div>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-10-contents" aria-controls="callout-10" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Weaknesses of Matching
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-10" class="callout-10-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Matching does not always create “perfect” matches. This means that the pairs matched together may not be identical to each other in terms of covariates <span class="math inline">X</span> or potential outcomes.</p>
<p>The inability to find exact matches can cause bias, especially for the more covariates we match on (see below).</p>
</div>
</div>
</div>
<p>Note: Matching is not a design - it is an estimator. You need a research design, such as selection on observables.</p>
<p><br></p>
</section>
<section id="matching-with-multiple-covariates" class="level3">
<h3 class="anchored" data-anchor-id="matching-with-multiple-covariates">Matching with Multiple Covariates</h3>
<p>Consider that we <span class="math inline">k&gt;1</span> number of confounders <span class="math inline">X</span>. Now, we have to match observations in <span class="math inline">k</span> variables, which implies we are in a multidimensional <span class="math inline">\mathbb R^k</span> space.</p>
<p>The most commonly used distance metric is <strong>Mahalanobis</strong> Distance - which measures the distance in <span class="math inline">X_i</span> between units <span class="math inline">i</span> and <span class="math inline">j</span>:</p>
<p><span class="math display">
D_M (\mathbf X_i, \mathbf X_j) = \sqrt{(\mathbf X_i - \mathbf X_j)^T \boldsymbol\Sigma_X^{-1} (\mathbf X_i - \mathbf X_j)}
</span></p>
<ul>
<li>Where <span class="math inline">\boldsymbol \Sigma_X</span> is the sample variance-covariance matrix of <span class="math inline">\mathbf X_i</span>.</li>
</ul>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-11-contents" aria-controls="callout-11" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Euclidean Distance
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-11" class="callout-11-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Euclidean distance is another common distance metric:</p>
<p><span class="math display">
D_E ( \mathbf X_i, \mathbf X_j) = \sqrt{(x_{1i} - x_{1j})^2 + (x_{2i}-x_{2j})^2 + \dots + (x_{ki}-x_{kj})^2}
</span></p>
<p>Euclidean distance, while very simple, is not recommended. This is because Euclidean distance with non-normalised variables can get you very bizarre results that depend on the scale of the variables.</p>
<p>There are other distance metrics, but these are exceedingly rare in selection on observables.</p>
</div>
</div>
</div>
<p>There is one issue with matching in multi-dimensional spaces. It becomes very difficult to match every unit <span class="math inline">i</span> on every covariate <span class="math inline">X</span>, even if we have a large number of observations.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-12-contents" aria-controls="callout-12" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Curse of Dimensionality
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-12" class="callout-12-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>When we try to match on more than one <span class="math inline">X</span> variable, we go from matching on a number line <span class="math inline">\mathbb R^1</span> to a <span class="math inline">n</span>-dimensional space, <span class="math inline">\mathbb R^n</span>.</p>
<p>The search space increases exponentially as you increase the number of dimensions.</p>
<p><img src="images/clipboard-2668193698.png" class="img-fluid" style="width:100.0%"></p>
<p>Take a look at the figure on the left. If we only match on a one dimensional plane (lets say the horizontal line between 0 and 1), we can see our red line covers approximately 30% of the horizontal line. But in 3 dimensions, our red box covers a significantly less proportion of the entire cube.</p>
<p>The figure on the right illustrates this. <span class="math inline">d</span> represents the dimensions. We can see as the dimensions increase, the fraction of volume increases significantly slower relative to distance.</p>
<p>Thus, with a bigger space, the distance between two units increases, so you get worse matches.</p>
</div>
</div>
</div>
<p>This curse of dimensionality creates a <a href="https://politicalscience.github.io/causal/0.html#unbiased-estimators">bias</a> problem - since we get non-exact matches. The more dimensions you add, the worse it becomes.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-13-contents" aria-controls="callout-13" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
More on Bias
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-13" class="callout-13-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>The poor matches caused by increased dimensionality inject error into our estimates of missing potential outcomes.</p>
<p>The bias term as you increase the number of dimensions <span class="math inline">k</span>, changes by <span class="math inline">N^{(-1/k)}</span>. This implies no <span class="math inline">\sqrt{n}</span> consistency for <span class="math inline">k&gt;2</span>.</p>
<p>If <span class="math inline">N_0</span> (number of untreated units) is much larger than <span class="math inline">N_1</span> (number of treated units), bias will typically be smaller.</p>
<p>There are ways to correct this bias, including Abadie and Imbens (2011) Bias Correction method.</p>
<p>There is a new method: <strong>Bias-corrected matching</strong>, which estimates bias ineherent to mathching estimators via regression, then subtracts it from the matching estimate to correct for it.</p>
</div>
</div>
</div>
<p><br></p>
</section>
<section id="propensity-scores-matching" class="level3">
<h3 class="anchored" data-anchor-id="propensity-scores-matching">Propensity Scores Matching</h3>
<p>Propensity Score matching is an alternative way to match over many dimensions. The <strong>propensity score</strong> is an unobserved property, defined as the probability of a unit <span class="math inline">i</span> of receiving treatment:</p>
<p><span class="math display">
\pi(X_i) \equiv Pr(D_i = 1|X_i)
</span></p>
<p>When supposing the <a href="https://politicalscience.github.io/causal/3.html#identification-assumptions">conditional ignorability and common support assumptions</a>, the propensity score <span class="math inline">\pi(X_i)</span> has the balancing property: <span class="math inline">D_i \perp X_i \ | \ \pi(X_i)</span>. This implies that conditional ignorability holds on the propensity scores alone:</p>
<p><span class="math display">
(Y_{1i}, Y_{0i}) \perp D_i \ | \ \pi(X_i)
</span></p>
<p>Thus, instead of conditioning on <span class="math inline">X_i</span> as we did in selection on observables, we can instead condition on <span class="math inline">\pi (X_i)</span>, and still identify the causal estimand.</p>
<p>However, we do not actually observe <span class="math inline">\pi (X_i)</span>. We estimate <span class="math inline">\pi (X_i)</span> with a binary response model, with outcome variable <span class="math inline">D_i</span>, and explanatory variables <span class="math inline">X_i</span>. This will get us a fitted probability <span class="math inline">Pr(D_i = 1) = \hat\pi(X_i)</span>.</p>
<p>Then, once we have the propensity score estimates <span class="math inline">\hat\pi(X_i)</span>, we can do nearest neighbour matching with the propensity scores (in 1-dimensional space). This will allow us to identify the <span class="math inline">\tau_{ATT}</span>.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-14-contents" aria-controls="callout-14" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Balance Checks
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-14" class="callout-14-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>The accurate estimation of <span class="math inline">\tau_{ATT}</span> implies an accurate prediction of the propensity scores <span class="math inline">\pi(X_i)</span>. We can test our matched treatment and control groups to see if the balancing property holds for covariates <span class="math inline">X_i</span>.</p>
</div>
</div>
</div>
<p><br></p>
</section>
<section id="inverse-probability-weighting-estimator" class="level3">
<h3 class="anchored" data-anchor-id="inverse-probability-weighting-estimator">Inverse Probability Weighting Estimator</h3>
<p>An alternative use of the propensity score is weighting. Under both conditional ignorability and common support assumptions, we can identify the ATE as:</p>
<p><span class="math display">
\tau_{ATE} = E\left[ Y_i \times \underbrace{\frac{D_i - \pi(X_i)}{\pi(X_i) (1 - \pi(X_i))}}_{\text{weight}}\right]
</span></p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-15-contents" aria-controls="callout-15" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Proof of Weighting Identification
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-15" class="callout-15-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>We know that the ATE can be written as a weighted average (when <span class="math inline">X</span> is discrete, we will assume this for simplicity):</p>
<p><span class="math display">
\tau_{ATE} = \sum\limits_{x \in \mathcal X} \underbrace{( E(Y_i|D_i = 1, X_i = x) - E(Y_i|D_i = 0, X_i = x))}_{\text{CATE at }X_i = x} \underbrace{Pr(X_i = x)}_{\text{weight}}
</span></p>
<p>We can rewrite the <span class="math inline">\tau_{ATE}</span> as follows using observed potential outcomes outcomes and conditional ignorability:</p>
<p><span class="math display">
\begin{split}
&amp; = \sum\limits_{x \in \mathcal X} \underbrace{(E(Y_{1i}|D_i = 1, X_i = x)}_{\because \text{ observed potential outcome}} - \underbrace{E(Y_{0i}|D_i = 0, X_i = x)}_{\because \text{ observed potential outcome}})Pr(X_i = x) \\
&amp; = \sum\limits_{x \in \mathcal X}  (\underbrace{E(Y_{1i}|X_i = x)}_{\because \text{ condit. ignorabil.}} - \underbrace{E(Y_{0i}|X_i = x)}_{\because \text{ condit. ignorabil.}})Pr(X_i = x)
\end{split}
</span></p>
<p>Like mentioned above, the summation and <span class="math inline">Pr(X_i = x)</span> indicate a weighted average. We can also express weighted average simply with an expectation:</p>
<p><span class="math display">
= E[E(Y_{1i}|X_i = x) - E(Y_{0i}|X_i = x)]
</span></p>
<p>Let us do an algebra trick - multiply both terms within the CATE by 1, albeit written a little strangely:</p>
<p><span class="math display">
\begin{split}
&amp; = E \left [E(Y_{1i}|X_i=x) \underbrace{\frac{\pi(X_i)}{\pi(X_i)}}_{=1} - (E(Y_{0i}|X_i=x) \underbrace{\frac{1-\pi(X_i)}{1-\pi(X_i)}}_{=1}\right] \\
&amp; = E \left[ \frac{E(Y_{1i}|X_i = x) \pi(X_i)}{\pi(X_i)} -  \frac{E(Y_{0i}|X_i = x) (1-\pi(X_i))}{1-\pi(X_i)} \right]
\end{split}
</span></p>
<p>We know that propensity score <span class="math inline">\pi(X_i) := E(D_i|X_i = x)</span>. Thus, we can convert the above to:</p>
<p><span class="math display">
\begin{split}
&amp; = E \left[ \frac{E(Y_{1i}|X_i = x)E(D_i|X_i = x)}{\pi(X_i)} - \frac{E(Y_{0i}|X_i = x)(1-E(D_i|X_i = x))}{1-\pi(X_i)}\right] \\
&amp; = E \left[ \frac{E(Y_{1i}|X_i = x)E(D_i|X_i = x)}{\pi(X_i)} - \frac{E(Y_{0i}|X_i = x)\overbrace{E(1-D_i|X_i = x)}^{\because \text{ property of expectation}}}{1-\pi(X_i)}\right]
\end{split}
</span></p>
<p>We know that conditional ignorability says <span class="math inline">(Y_{0i}, Y_{1i}) \perp D_i  \ | \ X_i = x</span>. That allows us to combine <span class="math inline">E(Y_{1i}|X_i =x)</span> and <span class="math inline">E(D_i|X_i = x)</span> into a single expectation:</p>
<p><span class="math display">
\begin{split}
&amp; = E \left[ \frac{E(Y_{1i}D_i|X_i = x)}{\pi(X_i)} - \frac{E(Y_{0i}(1-D_i)|X_i = x)}{1 - \pi(X_i)}\right] \\
&amp; = E \left[ \underbrace{E \left( \frac{Y_{1i}D_i}{\pi(X_i)} |X_i = x\right)}_{\because \text{ exp. of constant}} - \underbrace{E \left( \frac{Y_{0i}(1-D_i)}{1-\pi(X_i)} | X_i = x \right)}_{\because \text{ expect. of constant}} \right] \\
&amp; = E\left[ E\left( \frac{Y_{1i}D_i}{\pi(X_i)} - \frac{Y_{0i}(1-D_i)}{1-\pi(X_i)} |X_i = x \right) \right]
\end{split}
</span></p>
<p>We can use the law of iterated expectations <span class="math inline">E(X) = E[E(X|Y)]</span> to simplify to:</p>
<p><span class="math display">
\tau_{ATE} = E\left( \frac{Y_{1i}D_i}{\pi(X_i)} - \frac{Y_{0i}(1-D_i)}{1-\pi(X_i)}\right)
</span></p>
<p>We can see two terms in here: <span class="math inline">Y_{1i}D_i</span> and <span class="math inline">Y_{0i}(1-D_i)</span>. We know if <span class="math inline">D_i = 1</span>, then we will observe <span class="math inline">Y_{1i}</span> only, and if <span class="math inline">D_i = 0</span>, we will observe <span class="math inline">Y_{0i}</span>. Thus, we do not need the treatment indicator in <span class="math inline">Y_{di}</span>:</p>
<p><span class="math display">
\tau_{ATE} = E\left( \frac{Y_{i}D_i}{\pi(X_i)} - \frac{Y_{i}(1-D_i)}{1-\pi(X_i)}\right)
</span></p>
<p>Now, we can combine into one fraction to obtain the original identification result.</p>
<p><span class="math display">
\begin{split}
\tau_{ATE} &amp; = E\left( \frac{Y_{i}D_i}{\pi(X_i)} - \frac{Y_{i}(1-D_i)}{1-\pi(X_i)}\right) \\
&amp; = E\left( \frac{Y_{i}D_i}{\pi(X_i)} \times \underbrace{\frac{1-\pi(X_i)}{1-\pi(X_i)}}_{=1} - \frac{Y_{i}(1-D_i)}{1-\pi(X_i)} \times \underbrace{\frac{\pi(X_i)}{\pi(X_i)}}_{=1}\right) \\
&amp; = E \left( \frac{Y_iD_i(1-\pi(X_i))}{\pi(X_i)(1-\pi(X_i))} - \frac{Y_i(1-D_i)\pi(X_i)}{\pi(X_i)(1-\pi(X_i))}\right) \\
&amp; = E \left( \frac{\color{red}{Y_i} \color{black}D_i(1-\pi(X_i))-\color{red}{Y_i}\color{black}(1-D_i)\pi(X_i)}{\pi(X_i)(1-\pi(X_i))}\right) \\
&amp; = E\left( Y_i \frac{D_i(1-\pi(X_i))-(1-D_i)\pi(X_i)}{\pi(X_i)(1-\pi(X_i))}\right) \\
&amp; = E\left( Y_i \frac{D_i - D_i\pi(X_i)-(\pi(X_i) -D_i\pi(X_i))}{\pi(X_i)(1-\pi(X_i))}\right) \\
&amp;  = E\left( Y_i \frac{D_i \color{red}{- D_i\pi(X_i)} \color{black}-\pi(X_i) \color{red}{+ D_i\pi(X_i)}}{\pi(X_i)(1-\pi(X_i))}\right) \\
&amp; = E\left( Y_i \frac{D_i -\pi(X_i) }{\pi(X_i)(1-\pi(X_i))}\right) \\
\end{split}
</span></p>
<p>And thus, we have identified the ATE.</p>
</div>
</div>
</div>
<p>The <strong>inverse probability weighting (IPW) estimator</strong> would be the same calculation but in the sample:</p>
<p><span class="math display">
\begin{split}
\hat\tau_{ATE} &amp; = \frac{1}{N} \sum\limits_{i=1}^N \left(Y_i \frac{D_i - \hat\pi(X_i)}{\hat\pi(X_i) (1 - \hat\pi(X_i))} \right) \\
&amp; = \frac{1}{N} \sum\limits_{i=1}^N \left(\frac{D_i Y_i}{\hat\pi(X_i)} - \frac{(1-D_i) Y_i}{1 - \hat\pi(X_i)} \right)
\end{split}
</span></p>
<ul>
<li>The second equation is equivalent to the first - see the proof above for derivation.</li>
</ul>
<p>Essentially, those who are unlikely to be treated but do get treated get weighted more, and individuals who are likely to be treated but do not get treated get weighted more.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-16-contents" aria-controls="callout-16" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Weighting Estimator for ATT
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-16" class="callout-16-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>The identification of the ATT under both conditional ignorability and common support are:</p>
<p><span class="math display">
\tau_{ATT} = \frac{1}{Pr(D = 1)} \times E\left[ Y_i \times \underbrace{\frac{D_i - \pi(X_i)}{(1 - \pi(X_i))}}_{\text{weight}}\right]
</span></p>
<p>The sample IPW estimator would be:</p>
<p><span class="math display">
\begin{split}
\hat\tau_{ATT} &amp; = \frac{1}{N_1}\sum\limits_{i=1}^N \left( Y_i \frac{D_i - \hat\pi(X_i)}{1 - \hat\pi(X_i)} \right) \\
&amp; = \frac{1}{N_1} \sum\limits_{i=1}^N \left( D_iY_i - (1-D_i)Y_i \frac{\hat\pi(X_i)}{1 - \hat\pi(X_i)} \right)
\end{split}
</span></p>
</div>
</div>
</div>
<p>The IPW estimator is <a href="https://politicalscience.github.io/causal/0.html#asymptotically-consistent-estimators">asymptotically consistent</a>, but has very poor small sample properties. They are highly sensitive to extreme values of <span class="math inline">\hat\pi(X_i)</span>. This generates high variance (inefficiency), and can produce significant bias under model mispecification. Thus, you typically do not want to use it in small-sample situations.</p>
<p><br></p>
</section>
<section id="ordinary-least-squares-estimator" class="level3">
<h3 class="anchored" data-anchor-id="ordinary-least-squares-estimator">Ordinary Least Squares Estimator</h3>
<p>When we think about controlling for covariates <span class="math inline">X</span>, we often think about regression. OLS is a natural approach, since <span class="math inline">\hat\beta_{OLS}</span> estimates <a href="https://politicalscience.github.io/causal/0.html#regression-anatomy-theorem">partial out the effects of covariates</a>. <span class="math inline">\hat\beta_{OLS}</span> a good estimator of <span class="math inline">\tau_{ATE}</span> in selection of observables under 2 conditions:</p>
<ol type="1">
<li><strong>Constant treatment effect</strong>: <span class="math inline">\tau_i = Y_{1i} - Y_{0i}</span> for all units <span class="math inline">i</span>.</li>
<li><strong>Linearity</strong>: Potential outcomes are linear, and can be written as:</li>
</ol>
<p><span class="math display">
Y_i(d) = \beta_0 + d\beta_1 + \mathbf X_i \gamma + \epsilon_i \quad \text{for} \quad d = 0, 1
</span></p>
<p>Why is this the case? Suppose we have the above linear potential outcomes. We can show:</p>
<p><span class="math display">
\begin{split}
\tau_i &amp; = Y_{1i} - Y_{0i} \\
&amp; = (\beta_0 + (1)\beta_1 + \mathbf X_i \gamma + \epsilon_i) - (\beta_0 + (0)\beta_1 + \mathbf X_i \gamma + \epsilon_i) \\
&amp; = (\beta_0 + \beta_1 + \mathbf X_i \gamma + \epsilon_i) - (\beta_0 + \mathbf X_i \gamma + \epsilon_i) \\
&amp; = \beta_1
\end{split}
</span></p>
<p>Thus, <span class="math inline">\beta_1</span> properly identifies the <span class="math inline">\tau_i</span> given the two above assumptions.</p>
<p>We also know that conditional ignorability implies <a href="https://politicalscience.github.io/causal/0.html#conditions-for-unbiasedness">zero-conditional mean</a>. Thus <span class="math inline">\beta_1</span> is an unbiased and asymptotically consistent estimator of the ATE.</p>
<p>You should be cautious using OLS when assumption 2, <strong>linearity</strong>, is violated. OLS is the best linear estimator, but how far your data is from linearity will determine if the estimator is useful.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-17-contents" aria-controls="callout-17" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Non-Linearity
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-17" class="callout-17-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>What if potential outcomes <span class="math inline">Y_i(d)</span> is an unknown and non-linear function of <span class="math inline">d</span> and <span class="math inline">X_i</span>.</p>
<p>We know the OLS is the <a href="https://politicalscience.github.io/causal/0.html#ols-as-a-conditional-expectation-function">best linear predictor of the conditional expectation function</a> in terms of mean squared error. Thus, <span class="math inline">\beta_1</span> will provide the best linear approximation to the population regression function.</p>
<p>This does not mean it is good - just the best linear approximation.</p>
</div>
</div>
</div>
<p>You <strong>should not use</strong> OLS if you believe assumption 1, heterogeneity, is violated. The reasoning is explained below.</p>
<p><br></p>
</section>
<section id="fully-interacted-estimator" class="level3">
<h3 class="anchored" data-anchor-id="fully-interacted-estimator">Fully Interacted Estimator</h3>
<p>What if there are <strong>heterogenous</strong> treatment effects (where <span class="math inline">\tau_i</span> is different between units)? Standard OLS in this case is <u><strong>no longer</strong> an unbiased estimator</u> of the ATE.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-18-contents" aria-controls="callout-18" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Proof of OLS Biasedness under Heterogeneity
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-18" class="callout-18-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Recall the subclassification estimator of the ATE is a weighted average of CATEs:</p>
<p><span class="math display">
\hat\tau_{ATE} = \sum\limits_{x \in \mathcal X} ( \hat\tau_{CATE}(x)) \underbrace{Pr(X_i = x)}_{\text{weight}} \\
</span></p>
<p>OLS, when there are non constant treatment effects, can also be rewritten as a weighted average of CATEs:</p>
<p><span class="math display">
\hat\beta_{OLS} = \sum\limits_{x \in \mathcal X} ( \hat\tau_{CATE}(x)) \underbrace{ \frac{Var(D_i|X_i = X)Pr(X_i = x)}{\sum Var(D_i | X_i = x')Pr(X_i = x')} }_{\text{weight}} \\
</span></p>
<p>Notice how the weights are different. The weights in the OLS are the conditional variances of <span class="math inline">D_i</span>. This means that OLS is <strong>not</strong> an unbiased estimator of the ATE or ATT, but rather, a weighted average of the ATT and ATU.</p>
</div>
</div>
</div>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-19-contents" aria-controls="callout-19" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Conditional Variance Weighted Average Treatment Effect (CVW-ATE)
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-19" class="callout-19-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>OLS actually provides an unbiased estimator of the <strong>conditional variance weighted average treatment effect</strong>. This is not the same as the ATE or the ATT.</p>
<p>This estimand can also be described as a weighted average of the ATT (average treatment effect on the treated) and the ATU (average treatment effect on the untreated):</p>
<p><span class="math display">
\tau_{OLS} = w_1 \cdot \tau_{ATT} + w_0 \cdot \tau_{ATU}
</span></p>
<p>Where:</p>
<p><span class="math display">
\begin{split}
w_1 &amp; = \frac{(1 - Pr(D=1)) Var(\pi(X)|D = 0)}{Pr(D=1)Var(\pi(X)|D=1) + (1-Pr(D=1)Var(\pi(X)|D=0)} \\
w_0 &amp; = 1 - w_1
\end{split}
</span></p>
<p>The reason for this is because regression is prone to extrapolation beyond common support - i.e.&nbsp;it can “estimate” potential outcomes for units that are not observed. This can lead to bias.</p>
<p>This is in contrast to the subclassification estimator, which cannot be computed if there are missing observable outcomes for a substratum/category of <span class="math inline">X</span>.</p>
<p>The weights of <span class="math inline">D_i(X_i = x)</span> can also be seen as propensity scores of <span class="math inline">\pi(x)(1 - \pi(x)</span>. Therefore:</p>
<ol type="1">
<li>Weights are higher for groups with propensity scores close to 0.5.</li>
<li>Weights are low for groups with propensity scores close to 0 or 1.</li>
<li>OLS minimises estimation uncertainty by downweighting groups of <span class="math inline">X_i</span> where group-specific ATEs are less precisely estimated.</li>
</ol>
</div>
</div>
</div>
<p>The <strong>Fully-Interacted Estimator</strong>, a newly developed large-sample regression estimator (Lin 2013), solves the heterogeneity bias in the OLS estimator. The fully-interacted estimator takes the form:</p>
<p><span class="math display">
\widehat{Y_i} = \hat\alpha + D_i \widehat{\tau}_{int} + (\mathbf X_i - \mathbf {\bar X}) \hat\beta +D_i (\mathbf X_i - \mathbf{\bar X}) \hat\gamma
</span></p>
<ul>
<li>Where <span class="math inline">X_i</span> are covariate values sufficient to satisfy conditional independence.</li>
<li>Where <span class="math inline">\bar X</span> contains the sample means of all <span class="math inline">X_i</span> covariates.</li>
</ul>
<p>This estimator <span class="math inline">\hat\tau_{int}</span> is technically biased when estimating <span class="math inline">\tau_{ATE}</span>. However, the bias is arbitrarily small in large samples under conditional ignorability.</p>
<p>This estimator thus allows us to accurately estimate the ATE even under heterogenous treatment effects, assuming our sample size is sufficiently large.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-20-contents" aria-controls="callout-20" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Other Solutions to the OLS Bias under Heterogeneity
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-20" class="callout-20-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>There are a few other solutions to this issue of OLS bias under heterogeneity:</p>
<ol type="1">
<li><strong>Doubly-robust estimation</strong> uses a weighted average of regression and IPW estimators, which will be asymptotically consistent as long as the regression model is correctly specified.</li>
<li><strong>Matching as pre-processing</strong> uses matching to make treatment and control groups similar, then runs regression models to estimate causal effects.</li>
</ol>
</div>
</div>
</div>
<p><br></p>
<p><br></p>
<hr>
</section>
</section>
<section id="partial-identification" class="level1">
<h1><strong>Partial Identification</strong></h1>
<p><br></p>
<p><br></p>
<hr>
</section>
<section id="implementation-in-r" class="level1">
<h1><strong>Implementation in R</strong></h1>
<p>For all methods, you will need the <em>tidyverse</em> package:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>See how to perform each estimator in R:</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-21-contents" aria-controls="callout-21" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Distance Matching
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-21" class="callout-21-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>For matching, you will need the <em>MatchIt</em> package:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(MatchIt)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>First, let us conduct nearest neighbour matching with Mahalanobis distance by using the <em>matchit()</em> function.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>match_object <span class="ot">=</span> MatchIt<span class="sc">::</span><span class="fu">matchit</span>(D <span class="sc">~</span> X1 <span class="sc">+</span> X2 <span class="sc">+</span> X3,</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>                                <span class="at">data =</span> my_data,</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>                                <span class="at">method =</span> <span class="st">"nearest"</span>, <span class="co">#distance matching</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>                                <span class="at">distance =</span> <span class="st">"mahalanobis"</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># for output summary</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(match_object)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Second, let us save the matched data with the <em>match.data()</em> function.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>match_data <span class="ot">&lt;-</span> MatchIt<span class="sc">::</span><span class="fu">match.data</span>(match_object,</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">weights =</span> <span class="st">'nn_weights'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Third, we can test if matching worked by using a balance table and a love plot:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># balance table</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>cobalt<span class="sc">::</span><span class="fu">bal.tab</span>(D <span class="sc">~</span> X1 <span class="sc">+</span> X2 <span class="sc">+</span> X3, </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>                <span class="at">data =</span> match_data, <span class="co"># from the 2nd step</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>                <span class="at">weights =</span> <span class="st">"nn_weights"</span>,</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>                <span class="at">disp =</span> <span class="fu">c</span>(<span class="st">"means"</span>, <span class="st">"sds"</span>))</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">#love plot</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>cobalt<span class="sc">::</span><span class="fu">love.plot</span>(match_object,</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>                  <span class="at">data =</span> my_data, <span class="co">#original dataset</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>                  <span class="at">stars =</span> <span class="st">'raw'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finally, we can estimate the treatment effect. There are two options - either using a weighted regression, or using the matching algorithm:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># using weighted regression</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>estimate <span class="ot">&lt;-</span> <span class="fu">lm_robust</span>(Y <span class="sc">~</span> D,</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>                      <span class="at">data =</span> match_data, <span class="co">#data from step 2</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>                      <span class="at">weights =</span> nn_weights)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(estimate)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="do">## using the Matching package:</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>estimate <span class="ot">=</span> Matching<span class="sc">::</span><span class="fu">Match</span>(<span class="at">Y =</span> my_data<span class="sc">$</span>Y, <span class="co">#outcome</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>                           <span class="at">Tr =</span> my_data<span class="sc">$</span>D, <span class="co">#treatment</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>                           <span class="at">X =</span> my_data[,<span class="fu">c</span>(<span class="st">"X1"</span>, <span class="st">"X2"</span>, <span class="st">"X3"</span>)], <span class="co">#covariates</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>                           <span class="at">M=</span><span class="dv">1</span>, <span class="co">#number of neighbours</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>                           <span class="at">BiasAdjust =</span> <span class="cn">TRUE</span>, <span class="co">#for biased adjustment</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>                           <span class="at">Weight =</span> <span class="dv">2</span>)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(estimate)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>You will have the estimates that you can use.</p>
</div>
</div>
</div>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-22-contents" aria-controls="callout-22" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Propensity Score Matching
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-22" class="callout-22-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>First, we want to estimate propoensity scores with a logistic regression (or a random forest):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">#logistic model</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>pscore_model <span class="ot">=</span> <span class="fu">glm</span>(D <span class="sc">~</span> X1 <span class="sc">+</span> X2,</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>                   <span class="at">data =</span> my_data,</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>                   <span class="at">family =</span> <span class="st">"binomial"</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co"># estimate propensity scores</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>my_data<span class="sc">$</span>pscore_estimate <span class="ot">=</span> <span class="fu">predict</span>(pscore_model,</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">type =</span> <span class="st">"response"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, let us match with propensity scores:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># match</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>match_object <span class="ot">=</span> MatchIt<span class="sc">::</span><span class="fu">matchit</span>(D <span class="sc">~</span> pscore_estimate,</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>                                <span class="at">data =</span> my_data,</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>                                <span class="at">method =</span> <span class="st">"nearest"</span>,</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>                                <span class="at">distance =</span> <span class="st">"Mahalanobis"</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co"># save matched data</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>match_data <span class="ot">&lt;-</span> MatchIt<span class="sc">::</span><span class="fu">match.data</span>(match_object,</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">weights =</span> <span class="st">'pscore_weights'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Third, we can test if matching worked with a balance table and a love plot:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">#balance table</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>cobalt<span class="sc">::</span><span class="fu">bal.tab</span>(D <span class="sc">~</span> X1 <span class="sc">+</span> X2 <span class="sc">+</span> X3,</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                <span class="at">data =</span> match_data, <span class="co">#matched data from step 2</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>                <span class="at">weights =</span> <span class="st">"pscore_weights"</span>,</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>                <span class="at">disp =</span> <span class="fu">c</span>(<span class="st">"means"</span>, <span class="st">"sds"</span>))</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co">#love plot</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>cobalt<span class="sc">::</span><span class="fu">love.plot</span>(match_object,</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>                  <span class="at">data =</span> my_data, <span class="co">#original dataset</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>                  <span class="at">addl =</span> <span class="sc">~</span> X1 <span class="sc">+</span> X2 <span class="sc">+</span> X3,</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>                  <span class="at">stars =</span> <span class="st">'raw'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finally, let us do the estimation:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>estimate <span class="ot">&lt;-</span> <span class="fu">lm_robust</span>(Y <span class="sc">~</span> D,</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>                      <span class="at">data =</span> match_data, <span class="co">#from step 2</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>                      <span class="at">weights =</span> pscore_weights)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(estimate)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</div>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-23-contents" aria-controls="callout-23" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Inverse Probability Weighting
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-23" class="callout-23-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>First, we want to estimate propoensity scores with a logistic regression (or a random forest):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">#logistic model</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>pscore_model <span class="ot">=</span> <span class="fu">glm</span>(D <span class="sc">~</span> X1 <span class="sc">+</span> X2,</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>                   <span class="at">data =</span> my_data,</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>                   <span class="at">family =</span> <span class="st">"binomial"</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co"># estimate propensity scores</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>my_data<span class="sc">$</span>pscore_estimate <span class="ot">=</span> <span class="fu">predict</span>(pscore_model,</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">type =</span> <span class="st">"response"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Second, we calculate the inverse probability weights based on the formula from earlier:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>my_data<span class="sc">$</span>ipweight <span class="ot">=</span> <span class="fu">ifelse</span>(my_data<span class="sc">$</span>D <span class="sc">==</span> <span class="dv">1</span>, <span class="co"># condition</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>                       <span class="dv">1</span><span class="sc">/</span>my_data<span class="sc">$</span>pscore_estimate,</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>                       <span class="dv">1</span><span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>my_data<span class="sc">$</span>pscore_estimate))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finally, we can estimate the ATE, or ATT, or use a weighted regression for the ATE:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ATE estimator</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>((my_data<span class="sc">$</span>D <span class="sc">*</span> my_data<span class="sc">$</span>Y) <span class="sc">*</span> my_data<span class="sc">$</span>ipweight <span class="sc">-</span> ((<span class="dv">1</span> <span class="sc">-</span> my_data<span class="sc">$</span>D) <span class="sc">*</span> my_data<span class="sc">$</span>Y) <span class="sc">*</span> my_data<span class="sc">$</span>ipweight)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co"># ATT estimator</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span>(my_data<span class="sc">$</span>D <span class="sc">*</span> my_data<span class="sc">$</span>Y <span class="sc">-</span> (<span class="dv">1</span> <span class="sc">-</span> my_data<span class="sc">$</span>D) <span class="sc">*</span> my_data<span class="sc">$</span>Y <span class="sc">*</span> (my_data<span class="sc">$</span>pscore_estimate<span class="sc">/</span>(<span class="dv">1</span> <span class="sc">-</span> my_data<span class="sc">$</span>pscore_estimate)))<span class="sc">/</span><span class="fu">sum</span>(my_data<span class="sc">$</span>D)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co"># ATE with weighted regression</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>estimate <span class="ot">&lt;-</span> <span class="fu">lm_robust</span>(Y <span class="sc">~</span> D, </span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>                      <span class="at">data =</span> my_data,</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>                      <span class="at">weights =</span> ipweight)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(estimate)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</div>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-24-contents" aria-controls="callout-24" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
OLS Estimator
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-24" class="callout-24-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>For the OLS estimator, we can use the <em>lm_robust()</em> function:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>estimate <span class="ot">&lt;-</span> <span class="fu">lm_robust</span>(Y <span class="sc">~</span> D <span class="sc">+</span> X1 <span class="sc">+</span> X2 <span class="sc">+</span> X3,</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>                      <span class="at">data =</span> my_data)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(estimate)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can also use the <em>fixest</em> package and the <em>feols()</em> function:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(fixest)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>estimate <span class="ot">&lt;-</span> <span class="fu">feols</span>(Y <span class="sc">~</span> D <span class="sc">+</span> X1 <span class="sc">+</span> X2 <span class="sc">+</span> X3,</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>                  <span class="at">data =</span> my_data,</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>                  <span class="at">se =</span> <span class="st">"hetero"</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(estimate)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</div>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-25-contents" aria-controls="callout-25" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Fully Interacted Estimator
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-25" class="callout-25-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>For the fully interacted estimator, we can use the <em>lm_lin()</em> function.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>estimate <span class="ot">&lt;-</span> <span class="fu">lm_lin</span>(Y <span class="sc">~</span> D,</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>                   <span class="at">covariates =</span> <span class="sc">~</span> X1 <span class="sc">+</span> X2 <span class="sc">+</span> X3,</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>                   <span class="at">data =</span> my_data)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(estimate)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>