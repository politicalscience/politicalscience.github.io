<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Randomised Experiments</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="3_files/libs/clipboard/clipboard.min.js"></script>
<script src="3_files/libs/quarto-html/quarto.js"></script>
<script src="3_files/libs/quarto-html/popper.min.js"></script>
<script src="3_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="3_files/libs/quarto-html/anchor.min.js"></script>
<link href="3_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="3_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="3_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="3_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="3_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: true
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Randomised Experiments</h1>
            <p class="subtitle lead">Methods for Causal Inference</p>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="99">
    <h2 id="toc-title">Table of Contents</h2>
   
  <ul>
  <li><a href="#randomisation" id="toc-randomisation" class="nav-link active" data-scroll-target="#randomisation"><strong>Randomisation</strong></a>
  <ul class="collapse">
  <li><a href="#randomised-experiments" id="toc-randomised-experiments" class="nav-link" data-scroll-target="#randomised-experiments">Randomised Experiments</a></li>
  <li><a href="#independence-and-unconfoundness" id="toc-independence-and-unconfoundness" class="nav-link" data-scroll-target="#independence-and-unconfoundness">Independence and Unconfoundness</a></li>
  <li><a href="#randomisation-and-selection-bias" id="toc-randomisation-and-selection-bias" class="nav-link" data-scroll-target="#randomisation-and-selection-bias">Randomisation and Selection Bias</a></li>
  <li><a href="#equivalence-of-estimands" id="toc-equivalence-of-estimands" class="nav-link" data-scroll-target="#equivalence-of-estimands">Equivalence of Estimands</a></li>
  <li><a href="#graphical-representation" id="toc-graphical-representation" class="nav-link" data-scroll-target="#graphical-representation">Graphical Representation</a></li>
  <li><a href="#the-balancing-property" id="toc-the-balancing-property" class="nav-link" data-scroll-target="#the-balancing-property">The Balancing Property</a></li>
  <li><a href="#complications-and-limitations" id="toc-complications-and-limitations" class="nav-link" data-scroll-target="#complications-and-limitations">Complications and Limitations</a></li>
  </ul></li>
  <li><a href="#causal-estimation" id="toc-causal-estimation" class="nav-link" data-scroll-target="#causal-estimation"><strong>Causal Estimation</strong></a>
  <ul class="collapse">
  <li><a href="#difference-in-means-estimator" id="toc-difference-in-means-estimator" class="nav-link" data-scroll-target="#difference-in-means-estimator">Difference in Means Estimator</a></li>
  <li><a href="#ordinary-least-squares-estimator" id="toc-ordinary-least-squares-estimator" class="nav-link" data-scroll-target="#ordinary-least-squares-estimator">Ordinary Least Squares Estimator</a></li>
  </ul></li>
  <li><a href="#statistical-inference" id="toc-statistical-inference" class="nav-link" data-scroll-target="#statistical-inference"><strong>Statistical Inference</strong></a>
  <ul class="collapse">
  <li><a href="#inference-with-t-test" id="toc-inference-with-t-test" class="nav-link" data-scroll-target="#inference-with-t-test">Inference with T-Test</a></li>
  <li><a href="#sharp-null-hypothesis" id="toc-sharp-null-hypothesis" class="nav-link" data-scroll-target="#sharp-null-hypothesis">Sharp Null Hypothesis</a></li>
  <li><a href="#randomisation-inference" id="toc-randomisation-inference" class="nav-link" data-scroll-target="#randomisation-inference">Randomisation Inference</a></li>
  <li><a href="#nonparametric-bootstrap" id="toc-nonparametric-bootstrap" class="nav-link" data-scroll-target="#nonparametric-bootstrap">Nonparametric Bootstrap</a></li>
  </ul></li>
  <li><a href="#other-randomisation-procedures" id="toc-other-randomisation-procedures" class="nav-link" data-scroll-target="#other-randomisation-procedures"><strong>Other Randomisation Procedures</strong></a>
  <ul class="collapse">
  <li><a href="#stratified-randomisation" id="toc-stratified-randomisation" class="nav-link" data-scroll-target="#stratified-randomisation">Stratified Randomisation</a></li>
  <li><a href="#cluster-randomisation" id="toc-cluster-randomisation" class="nav-link" data-scroll-target="#cluster-randomisation">Cluster Randomisation</a></li>
  </ul></li>
  <li><a href="#extension-survey-experiments" id="toc-extension-survey-experiments" class="nav-link" data-scroll-target="#extension-survey-experiments"><strong>Extension: Survey Experiments</strong></a></li>
  <li><a href="#implementation-in-r" id="toc-implementation-in-r" class="nav-link" data-scroll-target="#implementation-in-r"><strong>Implementation in R</strong></a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>This chapter introduces the “gold standard” of causal inference: randomised controlled trials. This chapter also covers extensions, such as stratified experiments and survey experiments.</p>
<hr>
<section id="randomisation" class="level1">
<h1><strong>Randomisation</strong></h1>
<section id="randomised-experiments" class="level3">
<h3 class="anchored" data-anchor-id="randomised-experiments">Randomised Experiments</h3>
<p>Experiments are a research design where the assignment mechanism is controlled by the researcher.</p>
<p>Randomised Experiments use randomisation as the assignment mechanism. Treatment values are assigned to <span class="math inline">N</span> units at <strong>random</strong>, with both <strong>known</strong> and <strong>positive</strong> <strong>probabilities</strong> of being assigned to treatment and control groups.</p>
<p>Quick notation for randomised experiments:</p>
<ul>
<li>We have <span class="math inline">N</span> total number of units in our experiment.</li>
<li>A randomly subset of <span class="math inline">N_1</span> units are assigned to treatment <span class="math inline">D = 1</span>.</li>
<li>The remaining <span class="math inline">N_0 = N - N_1</span> are assigned to control.</li>
</ul>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
More on Randomisation
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><span class="math inline">N_1</span>, the number of individuals assigned to treatment, does not necessarily need to be 50% (although this is quite a common number).</p>
<p>Also note that when you fix the number of units to be treated at <span class="math inline">N_1</span>, technically, not all units have an independent probability of being selected. This is because once you have assigned <span class="math inline">N_1</span> individuals to treatment, we know the remaining individuals must be assigned to control. This usually is not a huge issue.</p>
<p>You can use bernoulli randomisation (simple randomisation) to avoid this issue. Bernoulli gives every individual a certain chance of being selected. This does mean that with different randomisation trials, we will get different numbers of treated individuals for each trial.</p>
</div>
</div>
</div>
<p><br></p>
</section>
<section id="independence-and-unconfoundness" class="level3">
<h3 class="anchored" data-anchor-id="independence-and-unconfoundness">Independence and Unconfoundness</h3>
<p>Randomisation implies that assignment probabilities, do not depend on the potential outcomes. The potential outcome values do not affect our chances of being selected for treatment.</p>
<p><span class="math display">
Pr(D=1|Y_0, Y_1) = Pr(D=1)
</span></p>
<p>Or in other words, treatment is <strong>independent</strong> of potential outcomes (or unconfounded):</p>
<p><span class="math display">
(Y_1, Y_0)  \perp D
</span></p>
<p>This implies that <span class="math inline">E(Y_{0i})</span> is the same between treatment and control groups, and <span class="math inline">E(Y_{1i})</span> is also the same between treatment and control:</p>
<p><span class="math display">
\begin{split}
&amp; E(Y_{0i} | D_i = 1) = E(Y_{0i} | D_i = 0) = E(Y_{0i})\\
&amp; E(Y_{1i} | D_i = 1) = E(Y_{1i} | D_i = 0) = E(Y_{1i})
\end{split}
</span></p>
<p><br></p>
</section>
<section id="randomisation-and-selection-bias" class="level3">
<h3 class="anchored" data-anchor-id="randomisation-and-selection-bias">Randomisation and Selection Bias</h3>
<p>Let us return to our <a href="https://politicalscience.github.io/causal/2.html#naive-estimator-and-selection-bias">naive estimator</a> comparing observed outcomes, and our problem of selection bias:</p>
<p><span class="math display">
\hat\tau_{\text{naive}} = \underbrace{E(Y_{1i}|D_i = 1)- E(Y_{0i}|D_i = 1)}_{\tau_{ATT}} + \underbrace{E(Y_{0i}|D_i = 1) - E(Y_{0i} | D_i = 0)}_{\text{Selection Bias}}
</span></p>
<p>But as discussed before, under randomisation, we know that:</p>
<p><span class="math display">
\begin{split}
&amp; E(Y_{0i} | D_i = 1) = E(Y_{0i} | D_i = 0) = E(Y_{0i})\\
&amp; E(Y_{1i} | D_i = 1) = E(Y_{1i} | D_i = 0) = E(Y_{1i})
\end{split}
</span></p>
<p>Using these properties, we can simplify:</p>
<p><span class="math display">
\begin{split}
\hat\tau_{\text{naive}} &amp; = \underbrace{E(Y_{1i}|D_i = 1)- E(Y_{0i}|D_i = 1)}_{\tau_{ATT}} + \underbrace{E(Y_{0i}|D_i = 1) - E(Y_{0i} | D_i = 0)}_{\text{Selection Bias}} \\
&amp; = \underbrace{E(Y_{1i})- E(Y_{0i}|D_i = 1)}_{\tau_{ATT}} + \underbrace{E(Y_{0i}) - E(Y_{0i})}_{\text{Selection Bias}} \\
&amp; = \underbrace{E(Y_{1i}|D_i = 1)- E(Y_{0i}|D_i = 1)}_{\tau_{ATT}} + 0
\end{split}
</span></p>
<p>Thus, under randomisation, selection bias is equal to 0, and thus our comparison of observed outcomes is now an unbiased estimator of the Average Treatment Effect on the Treated (ATT).</p>
<p><br></p>
</section>
<section id="equivalence-of-estimands" class="level3">
<h3 class="anchored" data-anchor-id="equivalence-of-estimands">Equivalence of Estimands</h3>
<p>Recall that randomisation (and independence from potential outcomes) says:</p>
<p><span class="math display">
\begin{split}
&amp; E(Y_{0i} | D_i = 1) = E(Y_{0i} | D_i = 0) = E(Y_{0i})\\
&amp; E(Y_{1i} | D_i = 1) = E(Y_{1i} | D_i = 0) = E(Y_{1i})
\end{split}
</span></p>
<p>Now look at the formula for the <a href="https://politicalscience.github.io/causal/2.html#average-treatment-effect-on-the-treated-att">ATT</a>. We can simplify as follows:</p>
<p><span class="math display">
\begin{split}
\tau_{ATT} &amp; = E(Y_{1i} -Y_{0i}|D_i = 1)\\
&amp; = E(Y_{1i} |D_i = 1) - E(Y_{0i} | D_i = 1) \\
&amp; = E(Y_{1i} ) - E(Y_{0i}) \\
&amp; = \underbrace{E(Y_{1i} - Y_{0i})}_{\tau_{ATE}}
\end{split}
</span></p>
<p>And now we see that <span class="math inline">\tau_{ATT}</span> and <span class="math inline">\tau_{ATE}</span> are equivalent under randomisation.</p>
<p><br></p>
</section>
<section id="graphical-representation" class="level3">
<h3 class="anchored" data-anchor-id="graphical-representation">Graphical Representation</h3>
<p>Let us look at a direct acyclic graph:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-1726123470.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:50.0%"></p>
</figure>
</div>
<p>Because we are randomly assigning treatment <span class="math inline">D</span>, we are exogenously determining <span class="math inline">D</span>. Thus, values of <span class="math inline">D</span> are not being caused by <span class="math inline">U</span>, they are being caused by randomisation.</p>
<p>Thus, we can eliminate the arrow between <span class="math inline">U \rightarrow D</span>. This allows us to estimate <span class="math inline">D \rightarrow Y</span> without any confounders.</p>
<p><br></p>
</section>
<section id="the-balancing-property" class="level3">
<h3 class="anchored" data-anchor-id="the-balancing-property">The Balancing Property</h3>
<p>Randomisation balances all observed and unobserved pre-treatment characteristics between units between the treatment and control.</p>
<p>This is because not only is <span class="math inline">(Y_1, Y_0) \perp D</span>, but also any covariate <span class="math inline">X</span> is also independent of treatment: <span class="math inline">X \perp D</span>.</p>
<p>This means that if randomisation is successful, we should expect minimal differences between control and treatment groups for all pre-treatment characteristics values.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Details on the Balancing Property
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>In any one sample, we actually are likely to have some imbalances in <span class="math inline">X</span> between control and treatment simply due to chance.</p>
<ul>
<li>You could control for imbalanced covariates, but you do not have to (we will discuss this later).</li>
</ul>
<p>You can adopt other randomisation procedures, such as stratified randomisation, to guarantee balance on <span class="math inline">X</span>.</p>
</div>
</div>
</div>
<p>We can text this assumption by finding the average <span class="math inline">X</span> values for both control and treatment groups, and see if there are any statistical significant differences in <span class="math inline">X</span> between control and treatment.</p>
<p><br></p>
</section>
<section id="complications-and-limitations" class="level3">
<h3 class="anchored" data-anchor-id="complications-and-limitations">Complications and Limitations</h3>
<p>Randomisation can be complicated by a few factors:</p>
<ol type="1">
<li>Missing data (often due to individuals dropping out). We are concerned that there is some covariate that is causing some people to drop out, which re-introduces selection bias.</li>
<li>Measurement Problems: Hawthorne Effect - subjects know what you are studying, and will change their behaviour as a result.</li>
<li>Non-Compliance: Some units assigned to treatment might not take the treatment, and some units assigned to control may take the treatment (this can often be dealt with by using an instrumental variable design).</li>
</ol>
<p>Randomisation does not help with external validity - the ability to extrapolate our results to external situations.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
More on External Validity
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>External validity asks if we can generalise our conclusions from our subjects, to other subjects outside our experiment. Can we extrapolate our estimates to to other populations?</p>
<p>For example, if we measured the effect of migration on tolerance for our subjects in India, can we say the same effect is true of someone in Japan, the US, or Europe?</p>
<p>This is important - if we cannot extrapolate, some results may be very niche.</p>
<p>To extrapolate to a greater population, our actual sample of observations in our experiment, should be representative of the greater population. This is often violated, as random sample for experiments is very very difficult.</p>
<p>This is called&nbsp;𝑋-Validity: we can study this with data - to see how representative our population is compared to the population.</p>
<p>Non-representative programme of treatment is another threat: Sometimes, treatments will differ between areas.</p>
<p>For example, if we are encouraging people to migrate to test how that changes their tolerance, how are the governmental/ngo/private agencies working with you affecting the process. Would less capable agencies create different effects?</p>
<p>This is called <span class="math inline">C</span>-validity, and we cannot measure this with data, unless you redo your experiment in another context.</p>
</div>
</div>
</div>
<p><br></p>
<p><br></p>
<hr>
</section>
</section>
<section id="causal-estimation" class="level1">
<h1><strong>Causal Estimation</strong></h1>
<section id="difference-in-means-estimator" class="level3">
<h3 class="anchored" data-anchor-id="difference-in-means-estimator">Difference in Means Estimator</h3>
<p>Our causal estimand is the Average Treatment Effect (ATE):</p>
<p><span class="math display">
\tau_{ATE} = E(Y_{1i}) - E(Y_{0i})
</span></p>
<p>We can estimate this using the difference-in-means estimator, by taking the sample mean <span class="math inline">Y</span> of the treatment group, minus the sample mean <span class="math inline">Y</span> of the control group:</p>
<p><span class="math display">
\hat\tau_{ATE} = \bar Y_1 - \bar Y_0
</span></p>
<p>This is an unbiased estimator because selection bias is eliminated with randomisation. This is also an asymptotically consistent estimator due to the <a href="https://politicalscience.github.io/causal/1.html#asymptotically-consistent-estimators">law of large numbers</a>.</p>
<p><br></p>
</section>
<section id="ordinary-least-squares-estimator" class="level3">
<h3 class="anchored" data-anchor-id="ordinary-least-squares-estimator">Ordinary Least Squares Estimator</h3>
<p>We can also estimate the <span class="math inline">\tau_{ATE}</span> with a bivariate regression:</p>
<p><span class="math display">
Y_i = \hat\gamma + \hat\tau D_i + \hat\epsilon_i
</span></p>
<p>Here, <span class="math inline">\hat\tau</span> is our estimator of the ATE. This gives the same estimate as the difference-in-means estimator.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Proof OLS is Equivalent to Difference-in-Means
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Remember that OLS is the best approximation of the conditional expectation function <span class="math inline">E(y|x)</span>.</p>
<p>Thus, we can write the regression as:</p>
<p><span class="math display">
E(Y_i|D_i) = \hat\gamma + \hat\tau D_i + \hat\epsilon_i
</span></p>
<p>Now, let us find the difference between treatment <span class="math inline">E(Y_i|D_i =1)</span> and control <span class="math inline">E(Y_i|D_i = 0)</span>:</p>
<p><span class="math display">
\begin{split}
&amp; E(Y_i|D_i = 1) - E(Y_i|D_i = 0) \\
= &amp; \ \hat\gamma + \hat\tau(1) + \hat\epsilon_i - (\hat\gamma + \hat\tau(0) + \hat\epsilon_i) \\
= &amp; \ \hat\gamma + \hat\tau + \hat\epsilon_i - \hat\gamma - \hat\epsilon \\
= &amp; \ \hat\tau
\end{split}
</span></p>
<p>Thus, the difference in means is equivalent to <span class="math inline">\hat\tau</span> regression coefficient.</p>
</div>
</div>
</div>
<p>Furthermore, <span class="math inline">\hat\gamma</span> is equivalent to the average <span class="math inline">Y</span> in the control group <span class="math inline">\bar Y_0</span>.</p>
<p>We do not need to include covariates. This is because randomisation allows us to meet the <a href="https://politicalscience.github.io/causal/1.html#conditions-for-asymptotic-consistency">asymptotic consistency</a> condition of both randomisation and exogeneity.</p>
<p>However, sometimes pre-treatment covariates are included. We should not include post-treatment covariates.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Including Pre-Treatment Covariates
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>There are several reasons one might want to include pre-treatment covariates:</p>
<ol type="1">
<li>Can increase precision (reduce standard error), by getting better predictions of <span class="math inline">Y</span>.</li>
<li>Can control for observable imbalance that was observed in the balance tables. Many researchers will compare a model without and with an imbalanced covariate, to show that the covariate does not matter significantly.</li>
<li>Can allow for estimation of heterogenous treatment effects by including interactions in the model.</li>
</ol>
<p>There is one risk: it may introduce small-sample bias. This will be discussed later in the discussion of the fully-interacted estimator.</p>
<p>We should not include post-treatment covariates. Anything that is measured post-treatment could be measuring a treatment effect (something that results from the treatment). This may “model away” your treatment effect.</p>
</div>
</div>
</div>
<p><br></p>
<p><br></p>
<hr>
</section>
</section>
<section id="statistical-inference" class="level1">
<h1><strong>Statistical Inference</strong></h1>
<section id="inference-with-t-test" class="level3">
<h3 class="anchored" data-anchor-id="inference-with-t-test">Inference with T-Test</h3>
<p>We can use a <strong>t</strong>-test for statistical inference.</p>
<ol type="1">
<li>Estimate the <span class="math inline">\hat\tau_{ATE}</span> and robust standard error <span class="math inline">\widehat{rse}(\hat\tau_{ATE})</span>.</li>
<li>State hypotheses, normally <span class="math inline">H_0 : \tau_{ATE} = 0</span> and <span class="math inline">H_1 \tau_{ATE} ≠ 0</span>.</li>
<li>Calculate the t-test statistic <span class="math inline">\hat\tau /\widehat{rse}(\hat\tau)</span>.</li>
<li>Refer to the relevant t-distribution, and calculate the p-value.</li>
</ol>
<p>Generally, we use a statistical significance level of <span class="math inline">\alpha = 0.05</span>, so we reject the null if <span class="math inline">|t|&gt;1.96</span>.</p>
<p>For more complex randomisation schemes, you will need different standard errors. For example, if you use a cluster randomisation scheme, you might need clustered standard errors.</p>
<p><br></p>
</section>
<section id="sharp-null-hypothesis" class="level3">
<h3 class="anchored" data-anchor-id="sharp-null-hypothesis">Sharp Null Hypothesis</h3>
<p>For our <span class="math inline">t</span>-tests, the null hypothesis was that the ATE was equal to 0. The issue is, the ATE is the expectation of treatment - a ATE of 0 could result from half of the population having <span class="math inline">\tau = -10</span> and half of the population having <span class="math inline">\tau = 10</span>.</p>
<p>Consider a new <strong>sharp null hypothesis</strong>, that all individual causal effects are zero:</p>
<p><span class="math display">
H_0^s : Y_1 = Y_0, \quad H_A^s : Y_1 ≠ Y_0
</span></p>
<p>Assuming <span class="math inline">H_0</span> is true, we can actually fully construct the potential outcomes <span class="math inline">Y_{0i}</span> and <span class="math inline">Y_{1i}</span>, since we know every unit has 0 individual treatment effect.</p>
<p>Thus, under the sharp null, we can actually observe both potential outcomes.</p>
<p><br></p>
</section>
<section id="randomisation-inference" class="level3">
<h3 class="anchored" data-anchor-id="randomisation-inference">Randomisation Inference</h3>
<p>Using the sharp null hypothesis, we can construct the full population <span class="math inline">Y_{0i}</span> and <span class="math inline">Y_{1i}</span> under the null hypothesis. Once constructed, we can imagine what different treatments we would observe under different randomization schemes (given <span class="math inline">H_0</span> is true).</p>
<ul>
<li>Thus, we can construct the sampling distribution, so we do not need to “imagine” a hypothetical sampling distribution.</li>
</ul>
<p>Procedure for conducting randomisation inference (also called permutation test or Fisher’s exact test) is as follows:</p>
<ol type="1">
<li>Calculate the total number of randomisations possible. This is calculated as a permutation of <span class="math inline">_NP_{N_1}</span> (<span class="math inline">N</span> choose <span class="math inline">N_1</span>).</li>
<li>Calculate and store the value of <span class="math inline">\widehat{\tau_j}</span> of each permuted dataset <span class="math inline">j</span>. Thus, we will have a distribution of <span class="math inline">\widehat{\tau_j}</span>.</li>
<li>Calculate <span class="math inline">p</span>-value as the proportion of <span class="math inline">\widehat{\tau_j}</span> that are as or more extreme than the actually observed <span class="math inline">\hat\tau</span>.</li>
</ol>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-6-contents" aria-controls="callout-6" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Details on Randomisation Inference
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-6" class="callout-6-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>If we have <span class="math inline">N</span> total units, and <span class="math inline">N_1</span> in the treatment group and <span class="math inline">N_0</span> in the control group, we can calculate all possible randomisation permutations as follows:</p>
<p><span class="math display">
\begin{pmatrix} N \\ N_1 \end{pmatrix} = \frac{N!}{N_1 ! N_0 !}
</span></p>
<p>This is the total number of assignments possible given <span class="math inline">N</span>, <span class="math inline">N_1</span>, and <span class="math inline">N_0</span>.</p>
<p>Then, we can calculate the <span class="math inline">\widehat{\tau_j}</span> of every possible randomisation assignment. The figure below shows this:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-717815317.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:70.0%"></p>
</figure>
</div>
<p>Now, plot all <span class="math inline">\widehat{\tau_j}</span> in a distribution:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-3711064458.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:60.0%"></p>
</figure>
</div>
<p>Let us say our sample <span class="math inline">\hat\tau = 6</span>. We would simply find the area under the curve that is above <span class="math inline">\hat\tau = 6</span>, and below <span class="math inline">-\hat\tau = -6</span>.</p>
</div>
</div>
</div>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-7-contents" aria-controls="callout-7" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Pros/Cons of Randomisation Inference
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-7" class="callout-7-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Randomisation Inference is assumption free - we do not need asymptotic properties or hypothetical sampling distributions.</p>
<p>Since we also do not need asymptotic property inferences, we can do inference with very small samples as well.</p>
<p>Downsides: the randomisation inference only tests if the sharp null hypothesis is true, but sometimes, that might not be something we want to test.</p>
</div>
</div>
</div>
<p><br></p>
</section>
<section id="nonparametric-bootstrap" class="level3">
<h3 class="anchored" data-anchor-id="nonparametric-bootstrap">Nonparametric Bootstrap</h3>
<p>The bootstrap is a method to simulate the sampling distribution. This is done by re-sampling from the sample with replacement. The procedure is as follows:</p>
<ol type="1">
<li>You take the sample you observe, and randomly sample from that sample with replacement (so allowing observations to repeat in our re-sample).</li>
<li>Continue to do this over and over again to get <span class="math inline">B</span> number of re-samples.</li>
<li>For each re-sample <span class="math inline">b</span>, you should calculate the <span class="math inline">\widehat{\tau_b}</span>. Plot all of the sample <span class="math inline">\widehat{\tau_b}</span> in a distribution.</li>
<li>Then calculate <span class="math inline">p</span>-value as the proportion of <span class="math inline">\widehat{\tau_b}</span> that are as or more extreme than the actually observed sample <span class="math inline">\hat\tau</span>.</li>
</ol>
<p>You can also estimate the standard error of <span class="math inline">\hat\tau</span> using the standard deviation of the distribution. However, do not use these standard errors for confidence intervals or tests unless you are confident the sampling distribution is approximately normal.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-8-contents" aria-controls="callout-8" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Pros/Cons of Bootstrap Inference
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-8" class="callout-8-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>The advantage of bootstrap is the following:</p>
<ol type="1">
<li>When the sampling variance of an estimator is too difficult to calculate or estimate.</li>
<li>When data is so skewed that inference based on asymptotic normality does not make sense.</li>
<li>When you have a small sample, so the asymptotic properties of the central limit theorem do not kick in.</li>
</ol>
<p>These advantages make bootstrap a very popular tool in modern inference.</p>
<p>The downside is that it can be computationally intensive. Also, it is not always a general solution for a small samples.</p>
</div>
</div>
</div>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-9-contents" aria-controls="callout-9" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Block Bootstrap
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-9" class="callout-9-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>For blocked experiments, you should randomly sample blocks, not units, to create your bootstrap re-samples.</p>
<p>For example, if your data is clustered in cities, you should re-sample by cities.</p>
</div>
</div>
</div>
<p><br></p>
<p><br></p>
<hr>
</section>
</section>
<section id="other-randomisation-procedures" class="level1">
<h1><strong>Other Randomisation Procedures</strong></h1>
<section id="stratified-randomisation" class="level3">
<h3 class="anchored" data-anchor-id="stratified-randomisation">Stratified Randomisation</h3>
<p>Stratified (also called blocked or conditional) randomisation are when randomisation occurs separately within levels of some covariates(s) <span class="math inline">X</span>.</p>
<p>For example, you could split people up into male or female, and random sample within each group, rather than everyone together.</p>
<p>This can prevent imbalances as normal randomisation can have a high probability (in certain situations) of creating imbalances.</p>
<p><br></p>
</section>
<section id="cluster-randomisation" class="level3">
<h3 class="anchored" data-anchor-id="cluster-randomisation">Cluster Randomisation</h3>
<p>Cluster randomisation is when we randomly assign units (or have individuals naturally) in groups. Every unit within a group (called a cluster) will get the same treatment. We randomly sample the groups to get the treatment or control.</p>
<p>For example, we could randomise development treatment at the village level, or randomise treatment of a cirriculum at the school level.</p>
<p>The main reason for this is to prevent SUTVA violations.</p>
<p>For example, imagine you are testing the effects of a new curriculum. If you randomise by each student, students will talk to their friends, and treated individuals may teach control individuals about the new curriculum. But by randomising by school (either an entire school gets or does not get the new curriculum), this concern is not a huge issue.</p>
<p><br></p>
<p><br></p>
<hr>
</section>
</section>
<section id="extension-survey-experiments" class="level1">
<h1><strong>Extension: Survey Experiments</strong></h1>
<p><br></p>
<p><br></p>
<hr>
</section>
<section id="implementation-in-r" class="level1">
<h1><strong>Implementation in R</strong></h1>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>