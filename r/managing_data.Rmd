---
title: "Managing Data"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

[Handbook Homepage](https://politicalscience.github.io)

## Table of Contents

-   [Importing Data: read_csv()](#importing-data-read_csv)

-   [Understanding Our Data: head(), tail(), glimpse()](#understanding-our-data-head-tail-glimpse)

-   [Selecting and Filtering Data: select(), filter()](#selecting-and-filtering-data-select-filter)

-   [Rearranging/Sorting Data: arrange()](#rearrangingsorting-data-arrange)

-   [Adding Columns: mutate(), transmute()](#adding-columns-mutate-transmute)

-   [Renaming Columns: colnames(), rename()](#renaming-columns-colnames-rename)

-   [Merging Data Frames: merge(), leftjoin()](#merging-data-frames-merge-leftjoin)

------------------------------------------------------------------------

Remember to load tidyverse

```{r, message=FALSE}
library(tidyverse)
```

------------------------------------------------------------------------

## Importing Data: read_csv() {#importing-data-read_csv}

To import data, use the **read_csv()** function as follows:

-   In the example below, **df** is the name of the dataframe. You can change this to whatever name you want it to be.

-   Between the "", add the csv file. This can be a local file on your computer, or a web url (make sure the web url ends in .csv).

```{r}
df <- read_csv("https://raw.githubusercontent.com/lse-me314/lse-me314.github.io/master/data/const-econ-vars.csv")
```

------------------------------------------------------------------------

## Understanding Our Data: head(), tail(), glimpse() {#understanding-our-data-head-tail-glimpse}

We can quickly explore our data frame with the following functions:

**head()** shows the first 6 rows of the dataframe by default. We can tell it to show more/less if needed.

-   In the example below, **df** is the name of the dataframe. You can change this to whatever name you want it to be.

-   You can delete the **, 3** part, if you only want the default 6 rows to display.

-   You can change the **3** to any number, depending on how many rows you want to see.

```{r}
head(df, 3)
```

**tail()** shows the last 6 rows of the dataframe by default. We can tell it to show more/less if needed. Use the same syntax above as **head()**.

```{r}
tail(df, 3)
```

**glimpse()** gives us a short description of the dataframe and variables.

```{r}
# replace df with the name of the data frame you want to see
glimpse(df)
```

------------------------------------------------------------------------

## Selecting and Filtering Data: select(), filter() {#selecting-and-filtering-data-select-filter}

Note: We will be using pipe operators (%\>%) from now on. This allows us to avoid restating the data frame.

**select()** selects the variables (columns) you want to include.

-   Simply list columns within the (), separated by commas.

**filter()** allows you to input conditions for what observations (rows) you want to include

-   Conditions are statements that are either TRUE or FALSE. For example, Var1 \> 0 can be TRUE or FALSE, or Var2 == 0 can be TRUE or FALSE. The TRUE values are kept in the dataset.

-   We can make multiple filter conditions by separating with commas. This will tell R to treat these conditions as an AND (meaning both have to be TRUE for a TRUE value to be produced).

-   If you want multiple conditions of OR (meaning if 1 of multiple is TRUE, the output is TRUE), separate conditions with **\|**

In the example below:

-   **subset1_df** is the new data frame we are storing the changes to. You can name this dataframe whatever you want to. It is good practice to store changes in new data frames, so we can go back to the old one if needed.

-   As previously, **df** is the original dataframe, and you can alter this to whatever your data frame is called.

```{r}

subset1_df <- df %>%
  select(ConstituencyName, social_mobility_score) %>% #selecting these two columns
  filter(social_mobility_score > 0) #only observations(rows) that meet this condition will be kept

# let us take a look at this data. See it only has 2 variables and less rows.
glimpse(subset1_df)
  
```

We can use the negative sign to exclude columns/rows. This can be useful when we want to keep most of the columns/rows, so we can specify only the ones to leave out.

-   In the example below, **HouseWageRatio** is being un-selected, or excluded. You can change this to whatever variable you want it to be.

-   You can deselect multiple variables by separating them with commas. Remember to put a negative sign in front of each one.

```{r}
subset2_df <- df %>%
  select(-HouseWageRatio) # selecting everything EXCEPT one variable

# Look at the data, Notice how that variable is gone now
glimpse(subset2_df)
```

Alternatively, we can use [x, ] to select rows, [, y] to select columns, and [x,y] to select columns and rows.

-   Note: the sytax of **1:3** means all integers between 1 and 3, including 1 and 3. For example, 2:20 would be counting 2, 3, 4, 5, .... 20.

-   Similar to the select function, we can use negative signs before the numbers to deselect them.

```{r}
#only keeping columns 1 through 3
subset3_df <- df[,1:3]
glimpse(subset3_df)

# only keeping first 100 rows
subset4_df <- df[1:100,]
glimpse(subset4_df)

# only keeping first 100 rows, and keeping all columns except one
subset5_df <- df[1:100,-3]
glimpse(subset5_df)
```

------------------------------------------------------------------------

## Rearranging/Sorting Data: arrange() {#rearrangingsorting-data-arrange}

**arrange()** allows us to sort data in alphabetical/ascending order.

-   In the example below, you can replace **WageMedianConst** with whatever variable/column you want to sort by.

```{r}
arranged_df <- df %>%
  arrange(WageMedianConst)

# lets see if it worked
head(arranged_df)
```

We can add **desc()** inside arrange to sort in descending order.

```{r}
arranged_df <- df %>%
  arrange(desc(WageMedianConst))

# lets see if it worked
head(arranged_df)
```

------------------------------------------------------------------------

## Adding Columns: mutate(), transmute() {#adding-columns-mutate-transmute}

**mutate()** adds columns/variables to the dataframe. First, we include the new variable name, then we indicate how we calculate the new variable.

In the example below:

-   **new_df** is the new data frame object with the added columns. You can name this whatever you want.

-   **df** is the original data frame we are modifying. Replace with whatever your original data frame is called.

-   **newvariable** is the new variable/column we are adding. You can name this whatever you want.

-   After the equal sign, is the condition of how to calculate this new variable. You can replace the **UnempConstRate \* 100** by any formula you want.

-   We can add multiple columns by separating each addition by commas.

```{r}
new_df <- df %>%
  mutate(newvariable = UnempConstRate * 100, newvariable2 = NA) 

# see the new variables at the bottom of the dataframe
glimpse(new_df)
```

**transmute()** is a variation of **mutate()**. It adds the new column you want to add, but deletes the other columns. If you want to keep maybe 1 column from the old dataset, you can create a new variable, and set it equal to that old variable.

Note that in the example below, we copy over **ConstituencyName** from the old data set, so that it isn't deleted.

```{r}
new1_df <- df %>%
  transmute(newvariable = HouseWageRatio + 5, ContituencyName = ConstituencyName)

# notice the other vairables have been deleted, but ConstiutencyName carries over
glimpse(new1_df)
```

------------------------------------------------------------------------

## Renaming Columns: colnames(), rename() {#renaming-columns-colnames-rename}

Each column in R can be named. We can see, and rename the columns as follows:

-   To see column names, use the **colnames()** function, with the data frame in question within the ().

-   To change a specific column name, first use the **colnames()** function to determine the position-number of that name. Then, reference it within the **[]**, seen below.

```{r}
colnames(df)

# Lets change the ConstituencyName column to just Name.
# We do this by noting, it is position 2 in the colnames() vector
colnames(df)[2] <- "Name"

# lets check if the name has changed.
colnames(df)
```

We can also use the **rename()** function, which allows us to avoid the **[]** indexing mess, and just use the names. Note: the new column name comes before the old column name when using this function.

-   **df** is the data frame we are renaming. Change it to the object you are modifying.

-   **newname1** is our new name to our first variable we are changing. The old name is **UnempConstRate**.

-   **newname2** is our new name to our second variable that we are changing. The old name is **ONSConstID**.

```{r}
# let us rename UnempConstRate to newname1
# let us also rename ONSConstID to newname2
df <- df %>%
  rename(newname1 = UnempConstRate, newname2 = ONSConstID)

# lets check if the name has changed
colnames(df)
```

------------------------------------------------------------------------

## Merging Data Frames: merge(), leftjoin() {#merging-data-frames-merge-leftjoin}

```{r, echo = FALSE}
id <- 1:5
names <- c("Kevin", "Elene", "Janice", "Daphne", "Gayatri")
coolness <- c(4, 10, 9, 10, 9)

x <- data.frame(id, names)
y <- data.frame(id, coolness)
```

Sometimes, we need to merge data frames. Lets take the following dataframes: x, and y. We want to merge them. We can do this with the **merge()** function

First, let us view the two data frames we are trying to combine:

```{r}
print(x)
print(y)
```

The **merge()** function will autmoatically merge the two datasets, based on the common column they have: **ID**. If you are trying to combine two datasets but their common column has slightly different names, it is best to rename the columns to be the same.

```{r}
merged_df <- merge(x, y)
print(merged_df)
```

**leftjoin()** works the same way. Leftjoin just keeps all rows of x, and adds y onto it. This can be useful in some situations, although most of the time, it is the same as merge. Another difference is that merge will sort the "common" column that was used to join alphabetically, while left join will mantain the "common" column order as in the x data set. However, this doesn't really matter for the above example, as the column "id" is already in alphabetical/ascending order. **leftjoin()** uses the same syntax, just replace merge with leftjoin

------------------------------------------------------------------------

[Handbook Homepage](https://politicalscience.github.io)
