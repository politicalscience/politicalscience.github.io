<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Introduction and Static Games</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="9_files/libs/clipboard/clipboard.min.js"></script>
<script src="9_files/libs/quarto-html/quarto.js"></script>
<script src="9_files/libs/quarto-html/popper.min.js"></script>
<script src="9_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="9_files/libs/quarto-html/anchor.min.js"></script>
<link href="9_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="9_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="9_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="9_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="9_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="99">
    <h2 id="toc-title">Chapters</h2>
   
  <ul>
  <li><a href="#preface" id="toc-preface" class="nav-link active" data-scroll-target="#preface">Preface</a></li>
  <li><a href="#chapter-1-basics-of-games" id="toc-chapter-1-basics-of-games" class="nav-link" data-scroll-target="#chapter-1-basics-of-games">Chapter 1: Basics of Games</a>
  <ul class="collapse">
  <li><a href="#game-theory-and-mathematical-modelling" id="toc-game-theory-and-mathematical-modelling" class="nav-link" data-scroll-target="#game-theory-and-mathematical-modelling">1.1: Game Theory and Mathematical Modelling</a></li>
  <li><a href="#structure-of-a-game" id="toc-structure-of-a-game" class="nav-link" data-scroll-target="#structure-of-a-game">1.2: Structure of a Game</a></li>
  <li><a href="#types-of-games" id="toc-types-of-games" class="nav-link" data-scroll-target="#types-of-games">1.3: Types of Games</a></li>
  <li><a href="#game-theory-notation" id="toc-game-theory-notation" class="nav-link" data-scroll-target="#game-theory-notation">1.4: Game Theory Notation</a></li>
  </ul></li>
  <li><a href="#chapter-2-dominant-strategy-equilibrium" id="toc-chapter-2-dominant-strategy-equilibrium" class="nav-link" data-scroll-target="#chapter-2-dominant-strategy-equilibrium">Chapter 2: Dominant Strategy Equilibrium</a>
  <ul class="collapse">
  <li><a href="#dominant-strategies" id="toc-dominant-strategies" class="nav-link" data-scroll-target="#dominant-strategies">2.1: Dominant Strategies</a></li>
  <li><a href="#dominant-strategy-equilibrium" id="toc-dominant-strategy-equilibrium" class="nav-link" data-scroll-target="#dominant-strategy-equilibrium">2.2: Dominant Strategy Equilibrium</a></li>
  <li><a href="#prisoners-dilemma" id="toc-prisoners-dilemma" class="nav-link" data-scroll-target="#prisoners-dilemma">2.3: Prisoner’s Dilemma</a></li>
  </ul></li>
  <li><a href="#chapter-3-nash-equilibrium" id="toc-chapter-3-nash-equilibrium" class="nav-link" data-scroll-target="#chapter-3-nash-equilibrium">Chapter 3: Nash Equilibrium</a>
  <ul class="collapse">
  <li><a href="#best-responses" id="toc-best-responses" class="nav-link" data-scroll-target="#best-responses">3.1: Best Responses</a></li>
  <li><a href="#nash-equilibrium" id="toc-nash-equilibrium" class="nav-link" data-scroll-target="#nash-equilibrium">3.2: Nash Equilibrium</a></li>
  <li><a href="#nash-equilibrium-examples" id="toc-nash-equilibrium-examples" class="nav-link" data-scroll-target="#nash-equilibrium-examples">3.3: Nash Equilibrium Examples</a></li>
  <li><a href="#trembling-hand-perfect-equilibrium" id="toc-trembling-hand-perfect-equilibrium" class="nav-link" data-scroll-target="#trembling-hand-perfect-equilibrium">3.4: Trembling Hand Perfect Equilibrium</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Introduction and Static Games</h1>
<p class="subtitle lead">Module 9 (Section 2: Formal Mathematical Modelling)</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="preface" class="level1">
<h1>Preface</h1>
<p>In political science, we are often interested in explaining the world around us. The world is incredibly complex - however, models, which make key simplifications, can make understanding the world around us much easier.</p>
<p>This module is an introduction to Formal Mathematical Modelling of political situations, often also called Game Theory or Formal Theory, focusing on the “simplest” type of model: static games.</p>
<p><u>Prerequisites</u>: Section 0: Essentials</p>
<p><br></p>
<hr>
<p><a href="https://politicalscience.github.io">Handbook Homepage</a></p>
</section>
<section id="chapter-1-basics-of-games" class="level1">
<h1>Chapter 1: Basics of Games</h1>
<section id="game-theory-and-mathematical-modelling" class="level3">
<h3 class="anchored" data-anchor-id="game-theory-and-mathematical-modelling">1.1: Game Theory and Mathematical Modelling</h3>
<p>Building models is an exceptionally powerful tool in Political Science. The world is very very complex, especially in the social sciences, where human behaviour can be difficult to predict or anticipate.</p>
<p>Models make key simplifications of reality, often called assumptions, in order to teach us something about the world. A great example of a model is the standard street map on google maps. This street map is not a complete representation of the world - it doesn’t show hills, it doesn’t show the height of buildings, it doesn’t show road markings. Most noticeably, it represents the spherical world on a flat surface. As you can see, it omits a lot of data on the real world.</p>
<p>Yet, despite omitting much of the real world, simple street maps are significantly better for driving navigation than, for example, a full 3D replica of the world. This is the power of models - through simplification, and only focusing on what we care about, it can help us learn something we did not know previously.</p>
<p>There are many different approaches to modelling in the social sciences.</p>
<ol type="1">
<li>Decision theory: modelling how one individual, who aims to maximise his objective, makes his decisions</li>
<li>Competitive equilibrium: price and quantities, as often seen in economics</li>
<li>Game Theory: social interactions that are characterised by strategic interdependence</li>
</ol>
<p><br></p>
<p><u>Game Theory</u> is the study of mathematical models of both conflict and cooperation between rational decision making. Essentially, we model situations where one person’s decisions affect the other people’s outcomes.</p>
<p>A few properties of game theory is as follows:</p>
<ol type="1">
<li>Payoffs are interdependent - one person’s actions affect other people’s payoffs/gains</li>
<li>There is common knowledge of the rules of the game - basically, everyone knows, that everyone knows, the “rules” of the game</li>
<li>A player is rational - they aim to maximise their payoff/gain</li>
<li>A player is aware of the other players, and predicts what other players will do, and will react to other players’ decisions</li>
<li>The optimal action of a player, depends on the beliefs of what others will do.</li>
</ol>
<p><br></p>
<p>The key point about Game Theory, as I have repeated multiple times, is interdependence - where one person’s actions affect other people’s payoffs/gains. This is often called <u>strategic interaction</u>. Here are a few examples of strategic interaction.</p>
<ol type="1">
<li>In football, when a penalty taker is opposed to a goalie. The penalty taker wants to score, and will try to anticipate where the goalkeeper will dive. The Penalty taker tries to anticipate where the goalkeeper will dive, and shoot the other way. One persons’ actions will affect the other person’s response, and their payoffs</li>
<li>Chess - the optimal move of a player, depends on how the other player moves. If the opponent plays a Sicilian defense, you have to adapt. When you move a piece, you have to think about how your opponent will respond.</li>
<li>Businesses - you have to react to your competition. If you want to raise prices, you have to first consider how the competition will react. If the competition cuts prices, you have to decide how to react. However, often times, these occur at the same time - there is no time to read and react - you have to anticipate</li>
</ol>
<p>There are also examples of non-strategic interaction, where game theory does not apply</p>
<ol type="1">
<li>If there is only 1 player, then there is no strategic interaction</li>
<li>If there is perfect competition in a market, there is no strategic interaction. This is because, in economics, perfect competition means that there are so many buyers and sellers, than any seller’s decisions are negligible, so they are price takers, and cannot set their own prices. Since they are not effecting the market or each other, there is no strategic interaction.</li>
</ol>
<p><br></p>
<p>Through creating mathematical models, we can predict how players will react in a political situation. WIth this insight, we can create causal hypothesis, which can be tested using statistical methods in section 1. Knowing how people we act in situations also helps policymakers design policy that encourages certain actions, and avoid counterproductive incentives and loopholes.</p>
<p><br></p>
</section>
<section id="structure-of-a-game" class="level3">
<h3 class="anchored" data-anchor-id="structure-of-a-game">1.2: Structure of a Game</h3>
<p>A game, as defined in game theory, is a situation where the actions of one person, noticeably affect the welfare of another. Game Theory assumes that a rational individual will try to predict what other players will do in response to their actions, and choose the actions that maximises their own utility/payoff given those predictions.</p>
<p>To explore games, we have to define the structure of a game, and some common notation. Here are a few core properties of games:</p>
<p><br></p>
<p><u>The Players</u>: These are the parties that make the relevant decisions.</p>
<ul>
<li>They can be individuals, but also firms, politicians, parties, and so on.</li>
</ul>
<p><br></p>
<p><u>Strategies</u>: a strategy is a <u>complete plan of action</u>.</p>
<ul>
<li><p>A player will have a set of possible decisions to take. If the game is repeated or the player has multiple turns, each turn to make a move will have a set of decisions they could take.</p></li>
<li><p><u>A strategy is a complete plan of action, meaning that it contains how a player will behave in every possible scenario in that game</u>.</p></li>
<li><p>For example, a strategy in chess, would be a plan of how you respond to every possible move in the game.</p></li>
</ul>
<p><br></p>
<p><u>Payoffs</u>: are a measure of what a player achieves, given their objectives, for every possible outcome of the game. These are generally a number which is defined by some payoff function</p>
<ul>
<li><p>So, any possible outcome (the result of any different set of actions by all players), will have a payoff associated with it, for each player</p></li>
<li><p>Payoffs aren’t just money - they include everything a player values, such as compassion, non-monetary payment, happiness, etc.</p></li>
<li><p>Game theory assumes that players will always seek the highest payoff.</p></li>
</ul>
<p><br></p>
<p>The <u>normal form representation</u> of a game includes the players, all possible strategies, and all possible payoffs. The normal form, and all the information within it, is assumed to be <u>common knowledge</u> - that all players know this information, and that they know others know this information</p>
<p><br></p>
</section>
<section id="types-of-games" class="level3">
<h3 class="anchored" data-anchor-id="types-of-games">1.3: Types of Games</h3>
<p>There are many types of games in game theory.</p>
<p><u>Static Games</u> are games where he players determine their actions simultaneously. This doesn’t necessarily mean they move at the same time - rather, this means that they move, without knowing what strategy the other has chosen. Thus, players will need to anticipate their opponents strategies, and counter them with their move.</p>
<p><u>Dynamic Games</u> are games where players move in a sequence/order, such as chess. Since players do not move at the same time, they can observe the strategy the other has chosen, and react to that strategy.</p>
<p><br></p>
<p><u>Zero-Sum Games</u> are when players are in direct conflict with each other - one player’s gain, comes directly from the expense of the other player(s). Basically, there must be winners and losers in a zero sum game.</p>
<p><u>Non-Zero-Sum Games</u> are when one player’s gain, does not come strictly at the expense of their opponents. This often occurs when players have some interests in common. Thus, outcomes that benefit everybody are possible, but they do not always occur (as we will see later).</p>
<p><br></p>
<p><u>One Shot Games</u> are games that are only played once. Thus, since they only occur once, there is no concern about a player’s reputation. Thus, people often act more ruthless in one-shot games.</p>
<p><u>Repeated Games</u> are played more than once. This gives players a opportunity to cultivate a reputation. It also allows other players to punish a player that “betrayed” them.</p>
<p><br></p>
<p><u>Cooperative Games</u> are when players are able to come to a <u>binding agreement</u>. Binding is the important part here - it means that there is some third party (like police/courts) that can force players to act in accordance to the agreement, even if that means it is no longer in the interests of the player to keep the agreement.</p>
<p><u>Non-Cooperative Games</u> are when agreements between players cannot be enforced by a third party. That does not mean agreements are impossible - but, it means that as soon as an agreement becomes non-beneficial to one or more of the players, the players will break off that agreement.</p>
<p><br></p>
</section>
<section id="game-theory-notation" class="level3">
<h3 class="anchored" data-anchor-id="game-theory-notation">1.4: Game Theory Notation</h3>
<p>Notation is frequently used in game theory, so you should get used to how notation is used.</p>
<p><br></p>
<p><u>Players</u> are denoted by <span class="math inline">\(i = 1, 2, ... N\)</span></p>
<ul>
<li><p>If we are talking about a specific player, we will use the number</p></li>
<li><p>If we are talking about any player, we will use <span class="math inline">\(i\)</span></p></li>
<li><p><span class="math inline">\(N\)</span> represents the total amount of players in a game</p></li>
</ul>
<p><br></p>
<p><u>Actions</u> of a player <span class="math inline">\(i\)</span> are denoted as <span class="math inline">\(a_i\)</span></p>
<ul>
<li><p>So, the actions of any player <span class="math inline">\(i\)</span> is denoted <span class="math inline">\(a_i\)</span>, while the actions of player 1 are denoted <span class="math inline">\(a_1\)</span>, etc.</p></li>
<li><p>The <u>Action Profile</u>, containing the actions of all players, is denoted as vector <span class="math inline">\(a = (a_1, a_2, ... a_N)\)</span></p></li>
</ul>
<!-- -->
<ul>
<li>The actions of every other player except <span class="math inline">\(i\)</span> is denoted as <span class="math inline">\(a_{-i}\)</span></li>
</ul>
<p><br></p>
<p><u>Strategies</u> of a player are denoted <span class="math inline">\(s_i\)</span></p>
<ul>
<li><p>Player <span class="math inline">\(i\)</span>’s selected strategy is denoted with a star: <span class="math inline">\(s_i^*\)</span></p></li>
<li><p>All other strategies that are not selected are denoted with a complement sign ’: <span class="math inline">\(s_i'\)</span></p></li>
<li><p>We will sometimes use a upper-small-script to denote special types of strategies, such as a dominant strategy (more on this later): <span class="math inline">\(s_i^D\)</span></p></li>
</ul>
<p><br></p>
<p><u>Preferences</u> are represented by a payoff function in the form of <span class="math inline">\(u_i(a_i,a_{-i})\)</span></p>
<ul>
<li><p>The input <span class="math inline">\(a_i\)</span> of the function is player <span class="math inline">\(i\)</span>’s action, while the input <span class="math inline">\(a_{-i}\)</span> is all other player’s actions</p></li>
<li><p>This reflects how in game theory, one player’s utility depends on both their actions, and the actions of their opponents</p></li>
</ul>
<p><br></p>
<hr>
<p><a href="https://politicalscience.github.io">Handbook Homepage</a></p>
</section>
</section>
<section id="chapter-2-dominant-strategy-equilibrium" class="level1">
<h1>Chapter 2: Dominant Strategy Equilibrium</h1>
<section id="dominant-strategies" class="level3">
<h3 class="anchored" data-anchor-id="dominant-strategies">2.1: Dominant Strategies</h3>
</section>
<section id="dominant-strategy-equilibrium" class="level3">
<h3 class="anchored" data-anchor-id="dominant-strategy-equilibrium">2.2: Dominant Strategy Equilibrium</h3>
</section>
<section id="prisoners-dilemma" class="level3">
<h3 class="anchored" data-anchor-id="prisoners-dilemma">2.3: Prisoner’s Dilemma</h3>
<p><br></p>
<hr>
<p><a href="https://politicalscience.github.io">Handbook Homepage</a></p>
</section>
</section>
<section id="chapter-3-nash-equilibrium" class="level1">
<h1>Chapter 3: Nash Equilibrium</h1>
<section id="best-responses" class="level3">
<h3 class="anchored" data-anchor-id="best-responses">3.1: Best Responses</h3>
</section>
<section id="nash-equilibrium" class="level3">
<h3 class="anchored" data-anchor-id="nash-equilibrium">3.2: Nash Equilibrium</h3>
</section>
<section id="nash-equilibrium-examples" class="level3">
<h3 class="anchored" data-anchor-id="nash-equilibrium-examples">3.3: Nash Equilibrium Examples</h3>
</section>
<section id="trembling-hand-perfect-equilibrium" class="level3">
<h3 class="anchored" data-anchor-id="trembling-hand-perfect-equilibrium">3.4: Trembling Hand Perfect Equilibrium</h3>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>